(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@angular/core'),exports, require('rxjs'), require('rxjs/operators'), require('@angular/core'), require('@angular/fire'), require('firebase/database')) :
    typeof define === 'function' && define.amd ? define(['@angular/core','exports', 'rxjs', 'rxjs/operators', '@angular/core', '@angular/fire', 'firebase/database'], factory) :
    (factory(global.ng.core,(global.angularfire2 = global.angularfire2 || {}, global.angularfire2.database = {}),global.rxjs,global.rxjs.operators,global.ng.core,global.angularfire2));
}(this, (function (Éµngcc0,exports,rxjs,operators,core,fire) { 'use strict';

    function isString(value) {
        return typeof value === 'string';
    }
    function isFirebaseDataSnapshot(value) {
        return typeof value.exportVal === 'function';
    }
    function isNil(obj) {
        return obj === undefined || obj === null;
    }
    function isFirebaseRef(value) {
        return typeof value.set === 'function';
    }
    function getRef(database$$1, pathRef) {
        return isFirebaseRef(pathRef) ? pathRef
            : database$$1.ref(pathRef);
    }
    function checkOperationCases(item, cases) {
        if (isString(item)) {
            return cases.stringCase();
        }
        else if (isFirebaseRef(item)) {
            return cases.firebaseCase();
        }
        else if (isFirebaseDataSnapshot(item)) {
            return cases.snapshotCase();
        }
        throw new Error("Expects a string, snapshot, or reference. Got: " + typeof item);
    }

    function fromRef(ref, event, listenType, scheduler) {
        if (listenType === void 0) { listenType = 'on'; }
        if (scheduler === void 0) { scheduler = rxjs.asyncScheduler; }
        return new rxjs.Observable(function (subscriber) {
            var fn = null;
            fn = ref[listenType](event, function (snapshot, prevKey) {
                scheduler.schedule(function () {
                    subscriber.next({ snapshot: snapshot, prevKey: prevKey });
                });
                if (listenType == 'once') {
                    scheduler.schedule(function () { return subscriber.complete(); });
                }
            }, function (err) {
                scheduler.schedule(function () { return subscriber.error(err); });
            });
            if (listenType == 'on') {
                return {
                    unsubscribe: function () {
                        if (fn != null) {
                            ref.off(event, fn);
                        }
                    }
                };
            }
            else {
                return { unsubscribe: function () { } };
            }
        }).pipe(operators.map(function (payload) {
            var snapshot = payload.snapshot, prevKey = payload.prevKey;
            var key = null;
            if (snapshot.exists()) {
                key = snapshot.key;
            }
            return { type: event, payload: snapshot, prevKey: prevKey, key: key };
        }), operators.share());
    }

    function listChanges(ref, events, scheduler) {
        return fromRef(ref, 'value', 'once', scheduler).pipe(operators.switchMap(function (snapshotAction) {
            var childEvent$ = [rxjs.of(snapshotAction)];
            events.forEach(function (event) { return childEvent$.push(fromRef(ref, event, 'on', scheduler)); });
            return rxjs.merge.apply(void 0, childEvent$).pipe(operators.scan(buildView, []));
        }), operators.distinctUntilChanged());
    }
    function positionFor(changes, key) {
        var len = changes.length;
        for (var i = 0; i < len; i++) {
            if (changes[i].payload.key === key) {
                return i;
            }
        }
        return -1;
    }
    function positionAfter(changes, prevKey) {
        if (isNil(prevKey)) {
            return 0;
        }
        else {
            var i = positionFor(changes, prevKey);
            if (i === -1) {
                return changes.length;
            }
            else {
                return i + 1;
            }
        }
    }
    function buildView(current, action) {
        var payload = action.payload, type = action.type, prevKey = action.prevKey, key = action.key;
        var currentKeyPosition = positionFor(current, key);
        var afterPreviousKeyPosition = positionAfter(current, prevKey);
        switch (action.type) {
            case 'value':
                if (action.payload && action.payload.exists()) {
                    var prevKey_1 = null;
                    action.payload.forEach(function (payload) {
                        var action = { payload: payload, type: 'value', prevKey: prevKey_1, key: payload.key };
                        prevKey_1 = payload.key;
                        current = current.concat([action]);
                        return false;
                    });
                }
                return current;
            case 'child_added':
                if (currentKeyPosition > -1) {
                    var previous = current[currentKeyPosition - 1];
                    if ((previous && previous.key || null) != prevKey) {
                        current = current.filter(function (x) { return x.payload.key !== payload.key; });
                        current.splice(afterPreviousKeyPosition, 0, action);
                    }
                }
                else if (prevKey == null) {
                    return [action].concat(current);
                }
                else {
                    current = current.slice();
                    current.splice(afterPreviousKeyPosition, 0, action);
                }
                return current;
            case 'child_removed':
                return current.filter(function (x) { return x.payload.key !== payload.key; });
            case 'child_changed':
                return current.map(function (x) { return x.payload.key === key ? action : x; });
            case 'child_moved':
                if (currentKeyPosition > -1) {
                    var data = current.splice(currentKeyPosition, 1)[0];
                    current = current.slice();
                    current.splice(afterPreviousKeyPosition, 0, data);
                    return current;
                }
                return current;
            default:
                return current;
        }
    }

    function validateEventsArray(events) {
        if (isNil(events) || events.length === 0) {
            events = ['child_added', 'child_removed', 'child_changed', 'child_moved'];
        }
        return events;
    }

    function snapshotChanges(query, events, scheduler) {
        events = validateEventsArray(events);
        return listChanges(query, events, scheduler);
    }

    function stateChanges(query, events, scheduler) {
        events = validateEventsArray(events);
        var childEvent$ = events.map(function (event) { return fromRef(query, event, 'on', scheduler); });
        return rxjs.merge.apply(void 0, childEvent$);
    }

    function auditTrail(query, events, scheduler) {
        var auditTrail$ = stateChanges(query, events)
            .pipe(operators.scan(function (current, action) { return current.concat([action]); }, []));
        return waitForLoaded(query, auditTrail$, scheduler);
    }
    function loadedData(query, scheduler) {
        return fromRef(query, 'value', 'on', scheduler)
            .pipe(operators.map(function (data) {
            var lastKeyToLoad;
            data.payload.forEach(function (child) {
                lastKeyToLoad = child.key;
                return false;
            });
            return { data: data, lastKeyToLoad: lastKeyToLoad };
        }));
    }
    function waitForLoaded(query, action$, scheduler) {
        var loaded$ = loadedData(query, scheduler);
        return loaded$
            .pipe(operators.withLatestFrom(action$), operators.map(function (_a) {
            var loaded = _a[0], actions = _a[1];
            var lastKeyToLoad = loaded.lastKeyToLoad;
            var loadedKeys = actions.map(function (snap) { return snap.key; });
            return { actions: actions, lastKeyToLoad: lastKeyToLoad, loadedKeys: loadedKeys };
        }), operators.skipWhile(function (meta) { return meta.loadedKeys.indexOf(meta.lastKeyToLoad) === -1; }), operators.map(function (meta) { return meta.actions; }));
    }

    function createDataOperationMethod(ref, operation) {
        return function dataOperation(item, value) {
            return checkOperationCases(item, {
                stringCase: function () { return ref.child(item)[operation](value); },
                firebaseCase: function () { return item[operation](value); },
                snapshotCase: function () { return item.ref[operation](value); }
            });
        };
    }

    function createRemoveMethod(ref) {
        return function remove(item) {
            if (!item) {
                return ref.remove();
            }
            return checkOperationCases(item, {
                stringCase: function () { return ref.child(item).remove(); },
                firebaseCase: function () { return item.remove(); },
                snapshotCase: function () { return item.ref.remove(); }
            });
        };
    }

    function createListReference(query, afDatabase) {
        var outsideAngularScheduler = afDatabase.schedulers.outsideAngular;
        return {
            query: query,
            update: createDataOperationMethod(query.ref, 'update'),
            set: createDataOperationMethod(query.ref, 'set'),
            push: function (data) { return query.ref.push(data); },
            remove: createRemoveMethod(query.ref),
            snapshotChanges: function (events) {
                return snapshotChanges(query, events, outsideAngularScheduler).pipe(afDatabase.keepUnstableUntilFirst);
            },
            stateChanges: function (events) {
                return stateChanges(query, events, outsideAngularScheduler).pipe(afDatabase.keepUnstableUntilFirst);
            },
            auditTrail: function (events) {
                return auditTrail(query, events, outsideAngularScheduler).pipe(afDatabase.keepUnstableUntilFirst);
            },
            valueChanges: function (events) {
                var snapshotChanges$ = snapshotChanges(query, events, outsideAngularScheduler);
                return snapshotChanges$.pipe(afDatabase.keepUnstableUntilFirst, operators.map(function (actions) { return actions.map(function (a) { return a.payload.val(); }); }));
            }
        };
    }

    function createObjectSnapshotChanges(query, scheduler) {
        return function snapshotChanges() {
            return fromRef(query, 'value', 'on', scheduler);
        };
    }

    function createObjectReference(query, afDatabase) {
        return {
            query: query,
            snapshotChanges: function () {
                return createObjectSnapshotChanges(query, afDatabase.schedulers.outsideAngular)().pipe(afDatabase.keepUnstableUntilFirst);
            },
            update: function (data) { return query.ref.update(data); },
            set: function (data) { return query.ref.set(data); },
            remove: function () { return query.ref.remove(); },
            valueChanges: function () {
                var snapshotChanges$ = createObjectSnapshotChanges(query, afDatabase.schedulers.outsideAngular)();
                return snapshotChanges$.pipe(afDatabase.keepUnstableUntilFirst, operators.map(function (action) { return action.payload.exists() ? action.payload.val() : null; }));
            },
        };
    }

    var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };
    var AngularFireDatabase = (function () {
        function AngularFireDatabase(options, nameOrConfig, databaseURL, platformId, zone) {
            this.schedulers = new fire.ÉµAngularFireSchedulers(zone);
            this.keepUnstableUntilFirst = fire.ÉµkeepUnstableUntilFirstFactory(this.schedulers, platformId);
            this.database = zone.runOutsideAngular(function () {
                var app = fire._firebaseAppFactory(options, zone, nameOrConfig);
                return app.database(databaseURL || undefined);
            });
        }
        AngularFireDatabase.prototype.list = function (pathOrRef, queryFn) {
            var ref = getRef(this.database, pathOrRef);
            var query = ref;
            if (queryFn) {
                query = queryFn(ref);
            }
            return createListReference(query, this);
        };
        AngularFireDatabase.prototype.object = function (pathOrRef) {
            var ref = getRef(this.database, pathOrRef);
            return createObjectReference(ref, this);
        };
        AngularFireDatabase.prototype.createPushId = function () {
            return this.database.ref().push().key;
        };
        AngularFireDatabase = __decorate([ __param(0, core.Inject(fire.FIREBASE_OPTIONS)),
            __param(1, core.Optional()), __param(1, core.Inject(fire.FIREBASE_APP_NAME)),
            __param(2, core.Optional()), __param(2, core.Inject(fire.DATABASE_URL)),
            __param(3, core.Inject(core.PLATFORM_ID)),
            __metadata("design:paramtypes", [Object, Object, Object, Object,
                core.NgZone])
        ], AngularFireDatabase);
AngularFireDatabase.Éµfac = function AngularFireDatabase_Factory(t) { return new (t || AngularFireDatabase)(Éµngcc0.ÉµÉµinject(fire.FIREBASE_OPTIONS), Éµngcc0.ÉµÉµinject(fire.FIREBASE_APP_NAME, 8), Éµngcc0.ÉµÉµinject(fire.DATABASE_URL, 8), Éµngcc0.ÉµÉµinject(core.PLATFORM_ID), Éµngcc0.ÉµÉµinject(Éµngcc0.NgZone)); };
AngularFireDatabase.Éµprov = Éµngcc0.ÉµÉµdefineInjectable({ token: AngularFireDatabase, factory: function (t) { return AngularFireDatabase.Éµfac(t); } });
/*@__PURE__*/ (function () { Éµngcc0.ÉµsetClassMetadata(AngularFireDatabase, [{
        type: core.Injectable
    }], function () { return [{ type: Object, decorators: [{
                type: core.Inject,
                args: [fire.FIREBASE_OPTIONS]
            }] }, { type: Object, decorators: [{
                type: core.Optional
            }, {
                type: core.Inject,
                args: [fire.FIREBASE_APP_NAME]
            }] }, { type: Object, decorators: [{
                type: core.Optional
            }, {
                type: core.Inject,
                args: [fire.DATABASE_URL]
            }] }, { type: Object, decorators: [{
                type: core.Inject,
                args: [core.PLATFORM_ID]
            }] }, { type: Éµngcc0.NgZone }]; }, null); })();
        return AngularFireDatabase;
    }());

    var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var AngularFireDatabaseModule = (function () {
        function AngularFireDatabaseModule() {
        }
AngularFireDatabaseModule.Éµmod = Éµngcc0.ÉµÉµdefineNgModule({ type: AngularFireDatabaseModule });
AngularFireDatabaseModule.Éµinj = Éµngcc0.ÉµÉµdefineInjector({ factory: function AngularFireDatabaseModule_Factory(t) { return new (t || AngularFireDatabaseModule)(); }, providers: [AngularFireDatabase] });
/*@__PURE__*/ (function () { Éµngcc0.ÉµsetClassMetadata(AngularFireDatabaseModule, [{
        type: core.NgModule,
        args: [{
                providers: [AngularFireDatabase]
            }]
    }], function () { return []; }, null); })();
        return AngularFireDatabaseModule;
    }());

    exports.RealtimeDatabaseURL = fire.RealtimeDatabaseURL;
    exports.DATABASE_URL = fire.DATABASE_URL;
    exports.URL = fire.DATABASE_URL;
    exports.AngularFireDatabase = AngularFireDatabase;
    exports.listChanges = listChanges;
    exports.createListReference = createListReference;
    exports.snapshotChanges = snapshotChanges;
    exports.stateChanges = stateChanges;
    exports.auditTrail = auditTrail;
    exports.fromRef = fromRef;
    exports.AngularFireDatabaseModule = AngularFireDatabaseModule;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YWJhc2UudW1kLmpzIiwic291cmNlcyI6WyJkYXRhYmFzZS51bWQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7b0dBQzJFO3lFQUNsQjs0QkFDNUM7MEJBQ007Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQ0F5U3VCLEFBRS9COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MkRBTXFCOzs7Ozs7Ozs7Ozs7U0FZdkI7Ozs7Ozs7O2dEQUs2QiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdyeGpzJyksIHJlcXVpcmUoJ3J4anMvb3BlcmF0b3JzJyksIHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKSwgcmVxdWlyZSgnQGFuZ3VsYXIvZmlyZScpLCByZXF1aXJlKCdmaXJlYmFzZS9kYXRhYmFzZScpKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdyeGpzJywgJ3J4anMvb3BlcmF0b3JzJywgJ0Bhbmd1bGFyL2NvcmUnLCAnQGFuZ3VsYXIvZmlyZScsICdmaXJlYmFzZS9kYXRhYmFzZSddLCBmYWN0b3J5KSA6XG4gICAgKGZhY3RvcnkoKGdsb2JhbC5hbmd1bGFyZmlyZTIgPSBnbG9iYWwuYW5ndWxhcmZpcmUyIHx8IHt9LCBnbG9iYWwuYW5ndWxhcmZpcmUyLmRhdGFiYXNlID0ge30pLGdsb2JhbC5yeGpzLGdsb2JhbC5yeGpzLm9wZXJhdG9ycyxnbG9iYWwubmcuY29yZSxnbG9iYWwuYW5ndWxhcmZpcmUyKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cyxyeGpzLG9wZXJhdG9ycyxjb3JlLGZpcmUpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzRmlyZWJhc2VEYXRhU25hcHNob3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZS5leHBvcnRWYWwgPT09ICdmdW5jdGlvbic7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTmlsKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqID09PSB1bmRlZmluZWQgfHwgb2JqID09PSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0ZpcmViYXNlUmVmKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUuc2V0ID09PSAnZnVuY3Rpb24nO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRSZWYoZGF0YWJhc2UkJDEsIHBhdGhSZWYpIHtcbiAgICAgICAgcmV0dXJuIGlzRmlyZWJhc2VSZWYocGF0aFJlZikgPyBwYXRoUmVmXG4gICAgICAgICAgICA6IGRhdGFiYXNlJCQxLnJlZihwYXRoUmVmKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tPcGVyYXRpb25DYXNlcyhpdGVtLCBjYXNlcykge1xuICAgICAgICBpZiAoaXNTdHJpbmcoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjYXNlcy5zdHJpbmdDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNGaXJlYmFzZVJlZihpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhc2VzLmZpcmViYXNlQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRmlyZWJhc2VEYXRhU25hcHNob3QoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjYXNlcy5zbmFwc2hvdENhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RzIGEgc3RyaW5nLCBzbmFwc2hvdCwgb3IgcmVmZXJlbmNlLiBHb3Q6IFwiICsgdHlwZW9mIGl0ZW0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZyb21SZWYocmVmLCBldmVudCwgbGlzdGVuVHlwZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIGlmIChsaXN0ZW5UeXBlID09PSB2b2lkIDApIHsgbGlzdGVuVHlwZSA9ICdvbic7IH1cbiAgICAgICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IHJ4anMuYXN5bmNTY2hlZHVsZXI7IH1cbiAgICAgICAgcmV0dXJuIG5ldyByeGpzLk9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHZhciBmbiA9IG51bGw7XG4gICAgICAgICAgICBmbiA9IHJlZltsaXN0ZW5UeXBlXShldmVudCwgZnVuY3Rpb24gKHNuYXBzaG90LCBwcmV2S2V5KSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHsgc25hcHNob3Q6IHNuYXBzaG90LCBwcmV2S2V5OiBwcmV2S2V5IH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5UeXBlID09ICdvbmNlJykge1xuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZXIuc2NoZWR1bGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gc3Vic2NyaWJlci5jb21wbGV0ZSgpOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1YnNjcmliZXIuZXJyb3IoZXJyKTsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5UeXBlID09ICdvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWYub2ZmKGV2ZW50LCBmbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uICgpIHsgfSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5waXBlKG9wZXJhdG9ycy5tYXAoZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgICAgIHZhciBzbmFwc2hvdCA9IHBheWxvYWQuc25hcHNob3QsIHByZXZLZXkgPSBwYXlsb2FkLnByZXZLZXk7XG4gICAgICAgICAgICB2YXIga2V5ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChzbmFwc2hvdC5leGlzdHMoKSkge1xuICAgICAgICAgICAgICAgIGtleSA9IHNuYXBzaG90LmtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IGV2ZW50LCBwYXlsb2FkOiBzbmFwc2hvdCwgcHJldktleTogcHJldktleSwga2V5OiBrZXkgfTtcbiAgICAgICAgfSksIG9wZXJhdG9ycy5zaGFyZSgpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0Q2hhbmdlcyhyZWYsIGV2ZW50cywgc2NoZWR1bGVyKSB7XG4gICAgICAgIHJldHVybiBmcm9tUmVmKHJlZiwgJ3ZhbHVlJywgJ29uY2UnLCBzY2hlZHVsZXIpLnBpcGUob3BlcmF0b3JzLnN3aXRjaE1hcChmdW5jdGlvbiAoc25hcHNob3RBY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBjaGlsZEV2ZW50JCA9IFtyeGpzLm9mKHNuYXBzaG90QWN0aW9uKV07XG4gICAgICAgICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIGNoaWxkRXZlbnQkLnB1c2goZnJvbVJlZihyZWYsIGV2ZW50LCAnb24nLCBzY2hlZHVsZXIpKTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gcnhqcy5tZXJnZS5hcHBseSh2b2lkIDAsIGNoaWxkRXZlbnQkKS5waXBlKG9wZXJhdG9ycy5zY2FuKGJ1aWxkVmlldywgW10pKTtcbiAgICAgICAgfSksIG9wZXJhdG9ycy5kaXN0aW5jdFVudGlsQ2hhbmdlZCgpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9zaXRpb25Gb3IoY2hhbmdlcywga2V5KSB7XG4gICAgICAgIHZhciBsZW4gPSBjaGFuZ2VzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGNoYW5nZXNbaV0ucGF5bG9hZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9zaXRpb25BZnRlcihjaGFuZ2VzLCBwcmV2S2V5KSB7XG4gICAgICAgIGlmIChpc05pbChwcmV2S2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgaSA9IHBvc2l0aW9uRm9yKGNoYW5nZXMsIHByZXZLZXkpO1xuICAgICAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5nZXMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJ1aWxkVmlldyhjdXJyZW50LCBhY3Rpb24pIHtcbiAgICAgICAgdmFyIHBheWxvYWQgPSBhY3Rpb24ucGF5bG9hZCwgdHlwZSA9IGFjdGlvbi50eXBlLCBwcmV2S2V5ID0gYWN0aW9uLnByZXZLZXksIGtleSA9IGFjdGlvbi5rZXk7XG4gICAgICAgIHZhciBjdXJyZW50S2V5UG9zaXRpb24gPSBwb3NpdGlvbkZvcihjdXJyZW50LCBrZXkpO1xuICAgICAgICB2YXIgYWZ0ZXJQcmV2aW91c0tleVBvc2l0aW9uID0gcG9zaXRpb25BZnRlcihjdXJyZW50LCBwcmV2S2V5KTtcbiAgICAgICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24ucGF5bG9hZCAmJiBhY3Rpb24ucGF5bG9hZC5leGlzdHMoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldktleV8xID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uLnBheWxvYWQuZm9yRWFjaChmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFjdGlvbiA9IHsgcGF5bG9hZDogcGF5bG9hZCwgdHlwZTogJ3ZhbHVlJywgcHJldktleTogcHJldktleV8xLCBrZXk6IHBheWxvYWQua2V5IH07XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2S2V5XzEgPSBwYXlsb2FkLmtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmNvbmNhdChbYWN0aW9uXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgICAgIGNhc2UgJ2NoaWxkX2FkZGVkJzpcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEtleVBvc2l0aW9uID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gY3VycmVudFtjdXJyZW50S2V5UG9zaXRpb24gLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcmV2aW91cyAmJiBwcmV2aW91cy5rZXkgfHwgbnVsbCkgIT0gcHJldktleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnBheWxvYWQua2V5ICE9PSBwYXlsb2FkLmtleTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50LnNwbGljZShhZnRlclByZXZpb3VzS2V5UG9zaXRpb24sIDAsIGFjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJldktleSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbYWN0aW9uXS5jb25jYXQoY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LnNwbGljZShhZnRlclByZXZpb3VzS2V5UG9zaXRpb24sIDAsIGFjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgICAgICAgY2FzZSAnY2hpbGRfcmVtb3ZlZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnBheWxvYWQua2V5ICE9PSBwYXlsb2FkLmtleTsgfSk7XG4gICAgICAgICAgICBjYXNlICdjaGlsZF9jaGFuZ2VkJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudC5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgucGF5bG9hZC5rZXkgPT09IGtleSA/IGFjdGlvbiA6IHg7IH0pO1xuICAgICAgICAgICAgY2FzZSAnY2hpbGRfbW92ZWQnOlxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50S2V5UG9zaXRpb24gPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGN1cnJlbnQuc3BsaWNlKGN1cnJlbnRLZXlQb3NpdGlvbiwgMSlbMF07XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuc3BsaWNlKGFmdGVyUHJldmlvdXNLZXlQb3NpdGlvbiwgMCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUV2ZW50c0FycmF5KGV2ZW50cykge1xuICAgICAgICBpZiAoaXNOaWwoZXZlbnRzKSB8fCBldmVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBldmVudHMgPSBbJ2NoaWxkX2FkZGVkJywgJ2NoaWxkX3JlbW92ZWQnLCAnY2hpbGRfY2hhbmdlZCcsICdjaGlsZF9tb3ZlZCddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc25hcHNob3RDaGFuZ2VzKHF1ZXJ5LCBldmVudHMsIHNjaGVkdWxlcikge1xuICAgICAgICBldmVudHMgPSB2YWxpZGF0ZUV2ZW50c0FycmF5KGV2ZW50cyk7XG4gICAgICAgIHJldHVybiBsaXN0Q2hhbmdlcyhxdWVyeSwgZXZlbnRzLCBzY2hlZHVsZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXRlQ2hhbmdlcyhxdWVyeSwgZXZlbnRzLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgZXZlbnRzID0gdmFsaWRhdGVFdmVudHNBcnJheShldmVudHMpO1xuICAgICAgICB2YXIgY2hpbGRFdmVudCQgPSBldmVudHMubWFwKGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gZnJvbVJlZihxdWVyeSwgZXZlbnQsICdvbicsIHNjaGVkdWxlcik7IH0pO1xuICAgICAgICByZXR1cm4gcnhqcy5tZXJnZS5hcHBseSh2b2lkIDAsIGNoaWxkRXZlbnQkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhdWRpdFRyYWlsKHF1ZXJ5LCBldmVudHMsIHNjaGVkdWxlcikge1xuICAgICAgICB2YXIgYXVkaXRUcmFpbCQgPSBzdGF0ZUNoYW5nZXMocXVlcnksIGV2ZW50cylcbiAgICAgICAgICAgIC5waXBlKG9wZXJhdG9ycy5zY2FuKGZ1bmN0aW9uIChjdXJyZW50LCBhY3Rpb24pIHsgcmV0dXJuIGN1cnJlbnQuY29uY2F0KFthY3Rpb25dKTsgfSwgW10pKTtcbiAgICAgICAgcmV0dXJuIHdhaXRGb3JMb2FkZWQocXVlcnksIGF1ZGl0VHJhaWwkLCBzY2hlZHVsZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsb2FkZWREYXRhKHF1ZXJ5LCBzY2hlZHVsZXIpIHtcbiAgICAgICAgcmV0dXJuIGZyb21SZWYocXVlcnksICd2YWx1ZScsICdvbicsIHNjaGVkdWxlcilcbiAgICAgICAgICAgIC5waXBlKG9wZXJhdG9ycy5tYXAoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBsYXN0S2V5VG9Mb2FkO1xuICAgICAgICAgICAgZGF0YS5wYXlsb2FkLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgbGFzdEtleVRvTG9hZCA9IGNoaWxkLmtleTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IGRhdGEsIGxhc3RLZXlUb0xvYWQ6IGxhc3RLZXlUb0xvYWQgfTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YWl0Rm9yTG9hZGVkKHF1ZXJ5LCBhY3Rpb24kLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgdmFyIGxvYWRlZCQgPSBsb2FkZWREYXRhKHF1ZXJ5LCBzY2hlZHVsZXIpO1xuICAgICAgICByZXR1cm4gbG9hZGVkJFxuICAgICAgICAgICAgLnBpcGUob3BlcmF0b3JzLndpdGhMYXRlc3RGcm9tKGFjdGlvbiQpLCBvcGVyYXRvcnMubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGxvYWRlZCA9IF9hWzBdLCBhY3Rpb25zID0gX2FbMV07XG4gICAgICAgICAgICB2YXIgbGFzdEtleVRvTG9hZCA9IGxvYWRlZC5sYXN0S2V5VG9Mb2FkO1xuICAgICAgICAgICAgdmFyIGxvYWRlZEtleXMgPSBhY3Rpb25zLm1hcChmdW5jdGlvbiAoc25hcCkgeyByZXR1cm4gc25hcC5rZXk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIHsgYWN0aW9uczogYWN0aW9ucywgbGFzdEtleVRvTG9hZDogbGFzdEtleVRvTG9hZCwgbG9hZGVkS2V5czogbG9hZGVkS2V5cyB9O1xuICAgICAgICB9KSwgb3BlcmF0b3JzLnNraXBXaGlsZShmdW5jdGlvbiAobWV0YSkgeyByZXR1cm4gbWV0YS5sb2FkZWRLZXlzLmluZGV4T2YobWV0YS5sYXN0S2V5VG9Mb2FkKSA9PT0gLTE7IH0pLCBvcGVyYXRvcnMubWFwKGZ1bmN0aW9uIChtZXRhKSB7IHJldHVybiBtZXRhLmFjdGlvbnM7IH0pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEYXRhT3BlcmF0aW9uTWV0aG9kKHJlZiwgb3BlcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBkYXRhT3BlcmF0aW9uKGl0ZW0sIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tPcGVyYXRpb25DYXNlcyhpdGVtLCB7XG4gICAgICAgICAgICAgICAgc3RyaW5nQ2FzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVmLmNoaWxkKGl0ZW0pW29wZXJhdGlvbl0odmFsdWUpOyB9LFxuICAgICAgICAgICAgICAgIGZpcmViYXNlQ2FzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlbVtvcGVyYXRpb25dKHZhbHVlKTsgfSxcbiAgICAgICAgICAgICAgICBzbmFwc2hvdENhc2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZW0ucmVmW29wZXJhdGlvbl0odmFsdWUpOyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVSZW1vdmVNZXRob2QocmVmKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiByZW1vdmUoaXRlbSkge1xuICAgICAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZi5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaGVja09wZXJhdGlvbkNhc2VzKGl0ZW0sIHtcbiAgICAgICAgICAgICAgICBzdHJpbmdDYXNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWYuY2hpbGQoaXRlbSkucmVtb3ZlKCk7IH0sXG4gICAgICAgICAgICAgICAgZmlyZWJhc2VDYXNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVtLnJlbW92ZSgpOyB9LFxuICAgICAgICAgICAgICAgIHNuYXBzaG90Q2FzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlbS5yZWYucmVtb3ZlKCk7IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxpc3RSZWZlcmVuY2UocXVlcnksIGFmRGF0YWJhc2UpIHtcbiAgICAgICAgdmFyIG91dHNpZGVBbmd1bGFyU2NoZWR1bGVyID0gYWZEYXRhYmFzZS5zY2hlZHVsZXJzLm91dHNpZGVBbmd1bGFyO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgdXBkYXRlOiBjcmVhdGVEYXRhT3BlcmF0aW9uTWV0aG9kKHF1ZXJ5LnJlZiwgJ3VwZGF0ZScpLFxuICAgICAgICAgICAgc2V0OiBjcmVhdGVEYXRhT3BlcmF0aW9uTWV0aG9kKHF1ZXJ5LnJlZiwgJ3NldCcpLFxuICAgICAgICAgICAgcHVzaDogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIHF1ZXJ5LnJlZi5wdXNoKGRhdGEpOyB9LFxuICAgICAgICAgICAgcmVtb3ZlOiBjcmVhdGVSZW1vdmVNZXRob2QocXVlcnkucmVmKSxcbiAgICAgICAgICAgIHNuYXBzaG90Q2hhbmdlczogZnVuY3Rpb24gKGV2ZW50cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzbmFwc2hvdENoYW5nZXMocXVlcnksIGV2ZW50cywgb3V0c2lkZUFuZ3VsYXJTY2hlZHVsZXIpLnBpcGUoYWZEYXRhYmFzZS5rZWVwVW5zdGFibGVVbnRpbEZpcnN0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdGF0ZUNoYW5nZXM6IGZ1bmN0aW9uIChldmVudHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGVDaGFuZ2VzKHF1ZXJ5LCBldmVudHMsIG91dHNpZGVBbmd1bGFyU2NoZWR1bGVyKS5waXBlKGFmRGF0YWJhc2Uua2VlcFVuc3RhYmxlVW50aWxGaXJzdCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXVkaXRUcmFpbDogZnVuY3Rpb24gKGV2ZW50cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhdWRpdFRyYWlsKHF1ZXJ5LCBldmVudHMsIG91dHNpZGVBbmd1bGFyU2NoZWR1bGVyKS5waXBlKGFmRGF0YWJhc2Uua2VlcFVuc3RhYmxlVW50aWxGaXJzdCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsdWVDaGFuZ2VzOiBmdW5jdGlvbiAoZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNuYXBzaG90Q2hhbmdlcyQgPSBzbmFwc2hvdENoYW5nZXMocXVlcnksIGV2ZW50cywgb3V0c2lkZUFuZ3VsYXJTY2hlZHVsZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzbmFwc2hvdENoYW5nZXMkLnBpcGUoYWZEYXRhYmFzZS5rZWVwVW5zdGFibGVVbnRpbEZpcnN0LCBvcGVyYXRvcnMubWFwKGZ1bmN0aW9uIChhY3Rpb25zKSB7IHJldHVybiBhY3Rpb25zLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS5wYXlsb2FkLnZhbCgpOyB9KTsgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdFNuYXBzaG90Q2hhbmdlcyhxdWVyeSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzbmFwc2hvdENoYW5nZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbVJlZihxdWVyeSwgJ3ZhbHVlJywgJ29uJywgc2NoZWR1bGVyKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVPYmplY3RSZWZlcmVuY2UocXVlcnksIGFmRGF0YWJhc2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgICAgIHNuYXBzaG90Q2hhbmdlczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVPYmplY3RTbmFwc2hvdENoYW5nZXMocXVlcnksIGFmRGF0YWJhc2Uuc2NoZWR1bGVycy5vdXRzaWRlQW5ndWxhcikoKS5waXBlKGFmRGF0YWJhc2Uua2VlcFVuc3RhYmxlVW50aWxGaXJzdCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gcXVlcnkucmVmLnVwZGF0ZShkYXRhKTsgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIHF1ZXJ5LnJlZi5zZXQoZGF0YSk7IH0sXG4gICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHF1ZXJ5LnJlZi5yZW1vdmUoKTsgfSxcbiAgICAgICAgICAgIHZhbHVlQ2hhbmdlczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBzbmFwc2hvdENoYW5nZXMkID0gY3JlYXRlT2JqZWN0U25hcHNob3RDaGFuZ2VzKHF1ZXJ5LCBhZkRhdGFiYXNlLnNjaGVkdWxlcnMub3V0c2lkZUFuZ3VsYXIpKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNuYXBzaG90Q2hhbmdlcyQucGlwZShhZkRhdGFiYXNlLmtlZXBVbnN0YWJsZVVudGlsRmlyc3QsIG9wZXJhdG9ycy5tYXAoZnVuY3Rpb24gKGFjdGlvbikgeyByZXR1cm4gYWN0aW9uLnBheWxvYWQuZXhpc3RzKCkgPyBhY3Rpb24ucGF5bG9hZC52YWwoKSA6IG51bGw7IH0pKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIF9fZGVjb3JhdGUgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICAgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICAgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgICB9O1xuICAgIHZhciBfX21ldGFkYXRhID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xuICAgIH07XG4gICAgdmFyIF9fcGFyYW0gPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxuICAgIH07XG4gICAgdmFyIEFuZ3VsYXJGaXJlRGF0YWJhc2UgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBbmd1bGFyRmlyZURhdGFiYXNlKG9wdGlvbnMsIG5hbWVPckNvbmZpZywgZGF0YWJhc2VVUkwsIHBsYXRmb3JtSWQsIHpvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVycyA9IG5ldyBmaXJlLsm1QW5ndWxhckZpcmVTY2hlZHVsZXJzKHpvbmUpO1xuICAgICAgICAgICAgdGhpcy5rZWVwVW5zdGFibGVVbnRpbEZpcnN0ID0gZmlyZS7JtWtlZXBVbnN0YWJsZVVudGlsRmlyc3RGYWN0b3J5KHRoaXMuc2NoZWR1bGVycywgcGxhdGZvcm1JZCk7XG4gICAgICAgICAgICB0aGlzLmRhdGFiYXNlID0gem9uZS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFwcCA9IGZpcmUuX2ZpcmViYXNlQXBwRmFjdG9yeShvcHRpb25zLCB6b25lLCBuYW1lT3JDb25maWcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhcHAuZGF0YWJhc2UoZGF0YWJhc2VVUkwgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIEFuZ3VsYXJGaXJlRGF0YWJhc2UucHJvdG90eXBlLmxpc3QgPSBmdW5jdGlvbiAocGF0aE9yUmVmLCBxdWVyeUZuKSB7XG4gICAgICAgICAgICB2YXIgcmVmID0gZ2V0UmVmKHRoaXMuZGF0YWJhc2UsIHBhdGhPclJlZik7XG4gICAgICAgICAgICB2YXIgcXVlcnkgPSByZWY7XG4gICAgICAgICAgICBpZiAocXVlcnlGbikge1xuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gcXVlcnlGbihyZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxpc3RSZWZlcmVuY2UocXVlcnksIHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICBBbmd1bGFyRmlyZURhdGFiYXNlLnByb3RvdHlwZS5vYmplY3QgPSBmdW5jdGlvbiAocGF0aE9yUmVmKSB7XG4gICAgICAgICAgICB2YXIgcmVmID0gZ2V0UmVmKHRoaXMuZGF0YWJhc2UsIHBhdGhPclJlZik7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlT2JqZWN0UmVmZXJlbmNlKHJlZiwgdGhpcyk7XG4gICAgICAgIH07XG4gICAgICAgIEFuZ3VsYXJGaXJlRGF0YWJhc2UucHJvdG90eXBlLmNyZWF0ZVB1c2hJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFiYXNlLnJlZigpLnB1c2goKS5rZXk7XG4gICAgICAgIH07XG4gICAgICAgIEFuZ3VsYXJGaXJlRGF0YWJhc2UgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgICAgIGNvcmUuSW5qZWN0YWJsZSgpLFxuICAgICAgICAgICAgX19wYXJhbSgwLCBjb3JlLkluamVjdChmaXJlLkZJUkVCQVNFX09QVElPTlMpKSxcbiAgICAgICAgICAgIF9fcGFyYW0oMSwgY29yZS5PcHRpb25hbCgpKSwgX19wYXJhbSgxLCBjb3JlLkluamVjdChmaXJlLkZJUkVCQVNFX0FQUF9OQU1FKSksXG4gICAgICAgICAgICBfX3BhcmFtKDIsIGNvcmUuT3B0aW9uYWwoKSksIF9fcGFyYW0oMiwgY29yZS5JbmplY3QoZmlyZS5EQVRBQkFTRV9VUkwpKSxcbiAgICAgICAgICAgIF9fcGFyYW0oMywgY29yZS5JbmplY3QoY29yZS5QTEFURk9STV9JRCkpLFxuICAgICAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3QsIE9iamVjdCwgT2JqZWN0LCBPYmplY3QsXG4gICAgICAgICAgICAgICAgY29yZS5OZ1pvbmVdKVxuICAgICAgICBdLCBBbmd1bGFyRmlyZURhdGFiYXNlKTtcbiAgICAgICAgcmV0dXJuIEFuZ3VsYXJGaXJlRGF0YWJhc2U7XG4gICAgfSgpKTtcblxuICAgIHZhciBfX2RlY29yYXRlJDEgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICAgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICAgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgICB9O1xuICAgIHZhciBBbmd1bGFyRmlyZURhdGFiYXNlTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQW5ndWxhckZpcmVEYXRhYmFzZU1vZHVsZSgpIHtcbiAgICAgICAgfVxuICAgICAgICBBbmd1bGFyRmlyZURhdGFiYXNlTW9kdWxlID0gX19kZWNvcmF0ZSQxKFtcbiAgICAgICAgICAgIGNvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW0FuZ3VsYXJGaXJlRGF0YWJhc2VdXG4gICAgICAgICAgICB9KVxuICAgICAgICBdLCBBbmd1bGFyRmlyZURhdGFiYXNlTW9kdWxlKTtcbiAgICAgICAgcmV0dXJuIEFuZ3VsYXJGaXJlRGF0YWJhc2VNb2R1bGU7XG4gICAgfSgpKTtcblxuICAgIGV4cG9ydHMuUmVhbHRpbWVEYXRhYmFzZVVSTCA9IGZpcmUuUmVhbHRpbWVEYXRhYmFzZVVSTDtcbiAgICBleHBvcnRzLkRBVEFCQVNFX1VSTCA9IGZpcmUuREFUQUJBU0VfVVJMO1xuICAgIGV4cG9ydHMuVVJMID0gZmlyZS5EQVRBQkFTRV9VUkw7XG4gICAgZXhwb3J0cy5Bbmd1bGFyRmlyZURhdGFiYXNlID0gQW5ndWxhckZpcmVEYXRhYmFzZTtcbiAgICBleHBvcnRzLmxpc3RDaGFuZ2VzID0gbGlzdENoYW5nZXM7XG4gICAgZXhwb3J0cy5jcmVhdGVMaXN0UmVmZXJlbmNlID0gY3JlYXRlTGlzdFJlZmVyZW5jZTtcbiAgICBleHBvcnRzLnNuYXBzaG90Q2hhbmdlcyA9IHNuYXBzaG90Q2hhbmdlcztcbiAgICBleHBvcnRzLnN0YXRlQ2hhbmdlcyA9IHN0YXRlQ2hhbmdlcztcbiAgICBleHBvcnRzLmF1ZGl0VHJhaWwgPSBhdWRpdFRyYWlsO1xuICAgIGV4cG9ydHMuZnJvbVJlZiA9IGZyb21SZWY7XG4gICAgZXhwb3J0cy5Bbmd1bGFyRmlyZURhdGFiYXNlTW9kdWxlID0gQW5ndWxhckZpcmVEYXRhYmFzZU1vZHVsZTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iXX0=