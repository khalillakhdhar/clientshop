(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@angular/core'),require('@angular/common'),require('@angular/platform-browser'),exports, require('@angular/core'), require('rxjs'), require('@angular/common'), require('rxjs/operators'), require('@angular/fire'), require('@angular/platform-browser')) :
    typeof define === 'function' && define.amd ? define(['@angular/core','@angular/common','@angular/platform-browser','exports', '@angular/core', 'rxjs', '@angular/common', 'rxjs/operators', '@angular/fire', '@angular/platform-browser'], factory) :
    (factory(global.ng.core,global.ng.common,global.ng.platformBrowser,(global.angularfire2 = global.angularfire2 || {}, global.angularfire2.analytics = {}),global.ng.core,global.rxjs,global.ng.common,global.rxjs.operators,global.angularfire2,global.ng.platformBrowser));
}(this, (function (ɵngcc0,ɵngcc1,ɵngcc2,exports,core,rxjs,common,operators,fire,platformBrowser) { 'use strict';

    var __assign = (undefined && undefined.__assign) || function () {
        __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };
    var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var COLLECTION_ENABLED = new core.InjectionToken('angularfire2.analytics.analyticsCollectionEnabled');
    var APP_VERSION = new core.InjectionToken('angularfire2.analytics.appVersion');
    var APP_NAME = new core.InjectionToken('angularfire2.analytics.appName');
    var DEBUG_MODE = new core.InjectionToken('angularfire2.analytics.debugMode');
    var CONFIG = new core.InjectionToken('angularfire2.analytics.config');
    var APP_NAME_KEY = 'app_name';
    var APP_VERSION_KEY = 'app_version';
    var DEBUG_MODE_KEY = 'debug_mode';
    var ANALYTICS_ID_FIELD = 'measurementId';
    var GTAG_CONFIG_COMMAND = 'config';
    var GTAG_FUNCTION_NAME = 'gtag';
    var DATA_LAYER_NAME = 'dataLayer';
    var AngularFireAnalytics = (function () {
        function AngularFireAnalytics(options, nameOrConfig, analyticsCollectionEnabled, providedAppVersion, providedAppName, debugModeEnabled, providedConfig, platformId, zone) {
            var _this = this;
            var _a, _b, _c;
            this.options = options;
            var schedulers = new fire.ɵAngularFireSchedulers(zone);
            if (common.isPlatformBrowser(platformId)) {
                window[DATA_LAYER_NAME] = window[DATA_LAYER_NAME] || [];
                this.gtag = window[GTAG_FUNCTION_NAME] || function () { window[DATA_LAYER_NAME].push(arguments); };
                this.analyticsInitialized = zone.runOutsideAngular(function () {
                    return new Promise(function (resolve) {
                        window[GTAG_FUNCTION_NAME] = function () {
                            var args = [];
                            for (var _i = 0; _i < arguments.length; _i++) {
                                args[_i] = arguments[_i];
                            }
                            if (args[0] == 'js') {
                                resolve();
                            }
                            _this.gtag.apply(_this, args);
                        };
                    });
                });
            }
            else {
                this.analyticsInitialized = Promise.resolve();
                this.gtag = function () { };
            }
            if (providedConfig) {
                this.updateConfig(providedConfig);
            }
            if (providedAppName) {
                this.updateConfig((_a = {}, _a[APP_NAME_KEY] = providedAppName, _a));
            }
            if (providedAppVersion) {
                this.updateConfig((_b = {}, _b[APP_VERSION_KEY] = providedAppVersion, _b));
            }
            if (debugModeEnabled) {
                this.updateConfig((_c = {}, _c[DEBUG_MODE_KEY] = 1, _c));
            }
            var analytics = rxjs.of(undefined).pipe(operators.observeOn(schedulers.outsideAngular), operators.switchMap(function () { return rxjs.empty(); }), operators.map(function () { return fire._firebaseAppFactory(options, zone, nameOrConfig); }), operators.map(function (app) { return app.analytics(); }), operators.tap(function (analytics) {
                if (analyticsCollectionEnabled === false) {
                    analytics.setAnalyticsCollectionEnabled(false);
                }
            }), operators.shareReplay({ bufferSize: 1, refCount: false }));
            return fire.ɵlazySDKProxy(this, analytics, zone);
        }
        AngularFireAnalytics.prototype.updateConfig = function (config) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.analyticsInitialized];
                        case 1:
                            _a.sent();
                            this.gtag(GTAG_CONFIG_COMMAND, this.options[ANALYTICS_ID_FIELD], __assign({}, config, { update: true }));
                            return [2];
                    }
                });
            });
        };
        AngularFireAnalytics = __decorate([ __param(0, core.Inject(fire.FIREBASE_OPTIONS)),
            __param(1, core.Optional()), __param(1, core.Inject(fire.FIREBASE_APP_NAME)),
            __param(2, core.Optional()), __param(2, core.Inject(COLLECTION_ENABLED)),
            __param(3, core.Optional()), __param(3, core.Inject(APP_VERSION)),
            __param(4, core.Optional()), __param(4, core.Inject(APP_NAME)),
            __param(5, core.Optional()), __param(5, core.Inject(DEBUG_MODE)),
            __param(6, core.Optional()), __param(6, core.Inject(CONFIG)),
            __param(7, core.Inject(core.PLATFORM_ID)),
            __metadata("design:paramtypes", [Object, Object, Object, Object, Object, Object, Object, Object,
                core.NgZone])
        ], AngularFireAnalytics);
AngularFireAnalytics.ɵfac = function AngularFireAnalytics_Factory(t) { return new (t || AngularFireAnalytics)(ɵngcc0.ɵɵinject(fire.FIREBASE_OPTIONS), ɵngcc0.ɵɵinject(fire.FIREBASE_APP_NAME, 8), ɵngcc0.ɵɵinject(COLLECTION_ENABLED, 8), ɵngcc0.ɵɵinject(APP_VERSION, 8), ɵngcc0.ɵɵinject(APP_NAME, 8), ɵngcc0.ɵɵinject(DEBUG_MODE, 8), ɵngcc0.ɵɵinject(CONFIG, 8), ɵngcc0.ɵɵinject(core.PLATFORM_ID), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
AngularFireAnalytics.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AngularFireAnalytics, factory: function (t) { return AngularFireAnalytics.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AngularFireAnalytics, [{
        type: core.Injectable
    }], function () { return [{ type: Object, decorators: [{
                type: core.Inject,
                args: [fire.FIREBASE_OPTIONS]
            }] }, { type: Object, decorators: [{
                type: core.Optional
            }, {
                type: core.Inject,
                args: [fire.FIREBASE_APP_NAME]
            }] }, { type: Object, decorators: [{
                type: core.Optional
            }, {
                type: core.Inject,
                args: [COLLECTION_ENABLED]
            }] }, { type: Object, decorators: [{
                type: core.Optional
            }, {
                type: core.Inject,
                args: [APP_VERSION]
            }] }, { type: Object, decorators: [{
                type: core.Optional
            }, {
                type: core.Inject,
                args: [APP_NAME]
            }] }, { type: Object, decorators: [{
                type: core.Optional
            }, {
                type: core.Inject,
                args: [DEBUG_MODE]
            }] }, { type: Object, decorators: [{
                type: core.Optional
            }, {
                type: core.Inject,
                args: [CONFIG]
            }] }, { type: Object, decorators: [{
                type: core.Inject,
                args: [core.PLATFORM_ID]
            }] }, { type: ɵngcc0.NgZone }]; }, null); })();
        return AngularFireAnalytics;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign$1 = function() {
        __assign$1 = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign$1.apply(this, arguments);
    };

    function __decorate$1(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param$1(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata$1(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @license Angular v8.0.0
     * (c) 2010-2019 Google LLC. https://angular.io/
     * License: MIT
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @description
     *
     * Base for events the Router goes through, as opposed to events tied to a specific
     * Route. `RouterEvent`s will only be fired one time for any given navigation.
     *
     * Example:
     *
     * ```
     * class MyService {
     *   constructor(public router: Router, logger: Logger) {
     *     router.events.pipe(
     *       filter(e => e instanceof RouterEvent)
     *     ).subscribe(e => {
     *       logger.log(e.id, e.url);
     *     });
     *   }
     * }
     * ```
     *
     * @publicApi
     */
    var RouterEvent = /** @class */ (function () {
        function RouterEvent(
        /** @docsNotRequired */
        id, 
        /** @docsNotRequired */
        url) {
            this.id = id;
            this.url = url;
        }
        return RouterEvent;
    }());
    /**
     * @description
     *
     * Represents an event triggered when a navigation starts.
     *
     * @publicApi
     */
    var NavigationStart = /** @class */ (function (_super) {
        __extends(NavigationStart, _super);
        function NavigationStart(
        /** @docsNotRequired */
        id, 
        /** @docsNotRequired */
        url, 
        /** @docsNotRequired */
        navigationTrigger, 
        /** @docsNotRequired */
        restoredState) {
            if (navigationTrigger === void 0) { navigationTrigger = 'imperative'; }
            if (restoredState === void 0) { restoredState = null; }
            var _this = _super.call(this, id, url) || this;
            _this.navigationTrigger = navigationTrigger;
            _this.restoredState = restoredState;
            return _this;
        }
        /** @docsNotRequired */
        NavigationStart.prototype.toString = function () { return "NavigationStart(id: " + this.id + ", url: '" + this.url + "')"; };
        return NavigationStart;
    }(RouterEvent));
    /**
     * @description
     *
     * Represents an event triggered when a navigation ends successfully.
     *
     * @publicApi
     */
    var NavigationEnd = /** @class */ (function (_super) {
        __extends(NavigationEnd, _super);
        function NavigationEnd(
        /** @docsNotRequired */
        id, 
        /** @docsNotRequired */
        url, 
        /** @docsNotRequired */
        urlAfterRedirects) {
            var _this = _super.call(this, id, url) || this;
            _this.urlAfterRedirects = urlAfterRedirects;
            return _this;
        }
        /** @docsNotRequired */
        NavigationEnd.prototype.toString = function () {
            return "NavigationEnd(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "')";
        };
        return NavigationEnd;
    }(RouterEvent));
    /**
     * @description
     *
     * Represents an event triggered when a navigation is canceled.
     *
     * @publicApi
     */
    var NavigationCancel = /** @class */ (function (_super) {
        __extends(NavigationCancel, _super);
        function NavigationCancel(
        /** @docsNotRequired */
        id, 
        /** @docsNotRequired */
        url, 
        /** @docsNotRequired */
        reason) {
            var _this = _super.call(this, id, url) || this;
            _this.reason = reason;
            return _this;
        }
        /** @docsNotRequired */
        NavigationCancel.prototype.toString = function () { return "NavigationCancel(id: " + this.id + ", url: '" + this.url + "')"; };
        return NavigationCancel;
    }(RouterEvent));
    /**
     * @description
     *
     * Represents an event triggered when a navigation fails due to an unexpected error.
     *
     * @publicApi
     */
    var NavigationError = /** @class */ (function (_super) {
        __extends(NavigationError, _super);
        function NavigationError(
        /** @docsNotRequired */
        id, 
        /** @docsNotRequired */
        url, 
        /** @docsNotRequired */
        error) {
            var _this = _super.call(this, id, url) || this;
            _this.error = error;
            return _this;
        }
        /** @docsNotRequired */
        NavigationError.prototype.toString = function () {
            return "NavigationError(id: " + this.id + ", url: '" + this.url + "', error: " + this.error + ")";
        };
        return NavigationError;
    }(RouterEvent));
    /**
     * @description
     *
     * Represents an event triggered when routes are recognized.
     *
     * @publicApi
     */
    var RoutesRecognized = /** @class */ (function (_super) {
        __extends(RoutesRecognized, _super);
        function RoutesRecognized(
        /** @docsNotRequired */
        id, 
        /** @docsNotRequired */
        url, 
        /** @docsNotRequired */
        urlAfterRedirects, 
        /** @docsNotRequired */
        state) {
            var _this = _super.call(this, id, url) || this;
            _this.urlAfterRedirects = urlAfterRedirects;
            _this.state = state;
            return _this;
        }
        /** @docsNotRequired */
        RoutesRecognized.prototype.toString = function () {
            return "RoutesRecognized(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "', state: " + this.state + ")";
        };
        return RoutesRecognized;
    }(RouterEvent));
    /**
     * @description
     *
     * Represents the start of the Guard phase of routing.
     *
     * @publicApi
     */
    var GuardsCheckStart = /** @class */ (function (_super) {
        __extends(GuardsCheckStart, _super);
        function GuardsCheckStart(
        /** @docsNotRequired */
        id, 
        /** @docsNotRequired */
        url, 
        /** @docsNotRequired */
        urlAfterRedirects, 
        /** @docsNotRequired */
        state) {
            var _this = _super.call(this, id, url) || this;
            _this.urlAfterRedirects = urlAfterRedirects;
            _this.state = state;
            return _this;
        }
        GuardsCheckStart.prototype.toString = function () {
            return "GuardsCheckStart(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "', state: " + this.state + ")";
        };
        return GuardsCheckStart;
    }(RouterEvent));
    /**
     * @description
     *
     * Represents the end of the Guard phase of routing.
     *
     * @publicApi
     */
    var GuardsCheckEnd = /** @class */ (function (_super) {
        __extends(GuardsCheckEnd, _super);
        function GuardsCheckEnd(
        /** @docsNotRequired */
        id, 
        /** @docsNotRequired */
        url, 
        /** @docsNotRequired */
        urlAfterRedirects, 
        /** @docsNotRequired */
        state, 
        /** @docsNotRequired */
        shouldActivate) {
            var _this = _super.call(this, id, url) || this;
            _this.urlAfterRedirects = urlAfterRedirects;
            _this.state = state;
            _this.shouldActivate = shouldActivate;
            return _this;
        }
        GuardsCheckEnd.prototype.toString = function () {
            return "GuardsCheckEnd(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "', state: " + this.state + ", shouldActivate: " + this.shouldActivate + ")";
        };
        return GuardsCheckEnd;
    }(RouterEvent));
    /**
     * @description
     *
     * Represents the start of the Resolve phase of routing. The timing of this
     * event may change, thus it's experimental. In the current iteration it will run
     * in the "resolve" phase whether there's things to resolve or not. In the future this
     * behavior may change to only run when there are things to be resolved.
     *
     * @publicApi
     */
    var ResolveStart = /** @class */ (function (_super) {
        __extends(ResolveStart, _super);
        function ResolveStart(
        /** @docsNotRequired */
        id, 
        /** @docsNotRequired */
        url, 
        /** @docsNotRequired */
        urlAfterRedirects, 
        /** @docsNotRequired */
        state) {
            var _this = _super.call(this, id, url) || this;
            _this.urlAfterRedirects = urlAfterRedirects;
            _this.state = state;
            return _this;
        }
        ResolveStart.prototype.toString = function () {
            return "ResolveStart(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "', state: " + this.state + ")";
        };
        return ResolveStart;
    }(RouterEvent));
    /**
     * @description
     *
     * Represents the end of the Resolve phase of routing. See note on
     * `ResolveStart` for use of this experimental API.
     *
     * @publicApi
     */
    var ResolveEnd = /** @class */ (function (_super) {
        __extends(ResolveEnd, _super);
        function ResolveEnd(
        /** @docsNotRequired */
        id, 
        /** @docsNotRequired */
        url, 
        /** @docsNotRequired */
        urlAfterRedirects, 
        /** @docsNotRequired */
        state) {
            var _this = _super.call(this, id, url) || this;
            _this.urlAfterRedirects = urlAfterRedirects;
            _this.state = state;
            return _this;
        }
        ResolveEnd.prototype.toString = function () {
            return "ResolveEnd(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "', state: " + this.state + ")";
        };
        return ResolveEnd;
    }(RouterEvent));
    /**
     * @description
     *
     * Represents an event triggered before lazy loading a route config.
     *
     * @publicApi
     */
    var RouteConfigLoadStart = /** @class */ (function () {
        function RouteConfigLoadStart(
        /** @docsNotRequired */
        route) {
            this.route = route;
        }
        RouteConfigLoadStart.prototype.toString = function () { return "RouteConfigLoadStart(path: " + this.route.path + ")"; };
        return RouteConfigLoadStart;
    }());
    /**
     * @description
     *
     * Represents an event triggered when a route has been lazy loaded.
     *
     * @publicApi
     */
    var RouteConfigLoadEnd = /** @class */ (function () {
        function RouteConfigLoadEnd(
        /** @docsNotRequired */
        route) {
            this.route = route;
        }
        RouteConfigLoadEnd.prototype.toString = function () { return "RouteConfigLoadEnd(path: " + this.route.path + ")"; };
        return RouteConfigLoadEnd;
    }());
    /**
     * @description
     *
     * Represents the start of end of the Resolve phase of routing. See note on
     * `ChildActivationEnd` for use of this experimental API.
     *
     * @publicApi
     */
    var ChildActivationStart = /** @class */ (function () {
        function ChildActivationStart(
        /** @docsNotRequired */
        snapshot) {
            this.snapshot = snapshot;
        }
        ChildActivationStart.prototype.toString = function () {
            var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';
            return "ChildActivationStart(path: '" + path + "')";
        };
        return ChildActivationStart;
    }());
    /**
     * @description
     *
     * Represents the start of end of the Resolve phase of routing. See note on
     * `ChildActivationStart` for use of this experimental API.
     *
     * @publicApi
     */
    var ChildActivationEnd = /** @class */ (function () {
        function ChildActivationEnd(
        /** @docsNotRequired */
        snapshot) {
            this.snapshot = snapshot;
        }
        ChildActivationEnd.prototype.toString = function () {
            var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';
            return "ChildActivationEnd(path: '" + path + "')";
        };
        return ChildActivationEnd;
    }());
    /**
     * @description
     *
     * Represents the start of end of the Resolve phase of routing. See note on
     * `ActivationEnd` for use of this experimental API.
     *
     * @publicApi
     */
    var ActivationStart = /** @class */ (function () {
        function ActivationStart(
        /** @docsNotRequired */
        snapshot) {
            this.snapshot = snapshot;
        }
        ActivationStart.prototype.toString = function () {
            var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';
            return "ActivationStart(path: '" + path + "')";
        };
        return ActivationStart;
    }());
    /**
     * @description
     *
     * Represents the start of end of the Resolve phase of routing. See note on
     * `ActivationStart` for use of this experimental API.
     *
     * @publicApi
     */
    var ActivationEnd = /** @class */ (function () {
        function ActivationEnd(
        /** @docsNotRequired */
        snapshot) {
            this.snapshot = snapshot;
        }
        ActivationEnd.prototype.toString = function () {
            var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';
            return "ActivationEnd(path: '" + path + "')";
        };
        return ActivationEnd;
    }());
    /**
     * @description
     *
     * Represents a scrolling event.
     *
     * @publicApi
     */
    var Scroll = /** @class */ (function () {
        function Scroll(
        /** @docsNotRequired */
        routerEvent, 
        /** @docsNotRequired */
        position, 
        /** @docsNotRequired */
        anchor) {
            this.routerEvent = routerEvent;
            this.position = position;
            this.anchor = anchor;
        }
        Scroll.prototype.toString = function () {
            var pos = this.position ? this.position[0] + ", " + this.position[1] : null;
            return "Scroll(anchor: '" + this.anchor + "', position: '" + pos + "')";
        };
        return Scroll;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * This component is used internally within the router to be a placeholder when an empty
     * router-outlet is needed. For example, with a config such as:
     *
     * `{path: 'parent', outlet: 'nav', children: [...]}`
     *
     * In order to render, there needs to be a component on this config, which will default
     * to this `EmptyOutletComponent`.
     */
    var ɵEmptyOutletComponent = /** @class */ (function () {
        function ɵEmptyOutletComponent() {
        }
ɵEmptyOutletComponent.ɵfac = function ɵEmptyOutletComponent_Factory(t) { return new (t || ɵEmptyOutletComponent)(); };
ɵEmptyOutletComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ɵEmptyOutletComponent, selectors: [["ng-component"]], decls: 1, vars: 0, template: function ɵEmptyOutletComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "router-outlet");
    } }, directives: function () { return [RouterOutlet]; }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ɵEmptyOutletComponent, [{
        type: core.Component,
        args: [{ template: "<router-outlet></router-outlet>" }]
    }], function () { return []; }, null); })();
        return ɵEmptyOutletComponent;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @description
     *
     * Name of the primary outlet.
     *
     * @publicApi
     */
    var PRIMARY_OUTLET = 'primary';
    var ParamsAsMap = /** @class */ (function () {
        function ParamsAsMap(params) {
            this.params = params || {};
        }
        ParamsAsMap.prototype.has = function (name) { return this.params.hasOwnProperty(name); };
        ParamsAsMap.prototype.get = function (name) {
            if (this.has(name)) {
                var v = this.params[name];
                return Array.isArray(v) ? v[0] : v;
            }
            return null;
        };
        ParamsAsMap.prototype.getAll = function (name) {
            if (this.has(name)) {
                var v = this.params[name];
                return Array.isArray(v) ? v : [v];
            }
            return [];
        };
        Object.defineProperty(ParamsAsMap.prototype, "keys", {
            get: function () { return Object.keys(this.params); },
            enumerable: true,
            configurable: true
        });
        return ParamsAsMap;
    }());
    /**
     * Convert a `Params` instance to a `ParamMap`.
     *
     * @publicApi
     */
    function convertToParamMap(params) {
        return new ParamsAsMap(params);
    }
    var NAVIGATION_CANCELING_ERROR = 'ngNavigationCancelingError';
    function navigationCancelingError(message) {
        var error = Error('NavigationCancelingError: ' + message);
        error[NAVIGATION_CANCELING_ERROR] = true;
        return error;
    }
    function isNavigationCancelingError(error) {
        return error && error[NAVIGATION_CANCELING_ERROR];
    }
    // Matches the route configuration (`route`) against the actual URL (`segments`).
    function defaultUrlMatcher(segments, segmentGroup, route) {
        var parts = route.path.split('/');
        if (parts.length > segments.length) {
            // The actual URL is shorter than the config, no match
            return null;
        }
        if (route.pathMatch === 'full' &&
            (segmentGroup.hasChildren() || parts.length < segments.length)) {
            // The config is longer than the actual URL but we are looking for a full match, return null
            return null;
        }
        var posParams = {};
        // Check each config part against the actual URL
        for (var index = 0; index < parts.length; index++) {
            var part = parts[index];
            var segment = segments[index];
            var isParameter = part.startsWith(':');
            if (isParameter) {
                posParams[part.substring(1)] = segment;
            }
            else if (part !== segment.path) {
                // The actual URL part does not match the config, no match
                return null;
            }
        }
        return { consumed: segments.slice(0, parts.length), posParams: posParams };
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var LoadedRouterConfig = /** @class */ (function () {
        function LoadedRouterConfig(routes, module) {
            this.routes = routes;
            this.module = module;
        }
        return LoadedRouterConfig;
    }());
    function validateConfig(config, parentPath) {
        if (parentPath === void 0) { parentPath = ''; }
        // forEach doesn't iterate undefined values
        for (var i = 0; i < config.length; i++) {
            var route = config[i];
            var fullPath = getFullPath(parentPath, route);
            validateNode(route, fullPath);
        }
    }
    function validateNode(route, fullPath) {
        if (!route) {
            throw new Error("\n      Invalid configuration of route '" + fullPath + "': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    ");
        }
        if (Array.isArray(route)) {
            throw new Error("Invalid configuration of route '" + fullPath + "': Array cannot be specified");
        }
        if (!route.component && !route.children && !route.loadChildren &&
            (route.outlet && route.outlet !== PRIMARY_OUTLET)) {
            throw new Error("Invalid configuration of route '" + fullPath + "': a componentless route without children or loadChildren cannot have a named outlet set");
        }
        if (route.redirectTo && route.children) {
            throw new Error("Invalid configuration of route '" + fullPath + "': redirectTo and children cannot be used together");
        }
        if (route.redirectTo && route.loadChildren) {
            throw new Error("Invalid configuration of route '" + fullPath + "': redirectTo and loadChildren cannot be used together");
        }
        if (route.children && route.loadChildren) {
            throw new Error("Invalid configuration of route '" + fullPath + "': children and loadChildren cannot be used together");
        }
        if (route.redirectTo && route.component) {
            throw new Error("Invalid configuration of route '" + fullPath + "': redirectTo and component cannot be used together");
        }
        if (route.path && route.matcher) {
            throw new Error("Invalid configuration of route '" + fullPath + "': path and matcher cannot be used together");
        }
        if (route.redirectTo === void 0 && !route.component && !route.children && !route.loadChildren) {
            throw new Error("Invalid configuration of route '" + fullPath + "'. One of the following must be provided: component, redirectTo, children or loadChildren");
        }
        if (route.path === void 0 && route.matcher === void 0) {
            throw new Error("Invalid configuration of route '" + fullPath + "': routes must have either a path or a matcher specified");
        }
        if (typeof route.path === 'string' && route.path.charAt(0) === '/') {
            throw new Error("Invalid configuration of route '" + fullPath + "': path cannot start with a slash");
        }
        if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {
            var exp = "The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.";
            throw new Error("Invalid configuration of route '{path: \"" + fullPath + "\", redirectTo: \"" + route.redirectTo + "\"}': please provide 'pathMatch'. " + exp);
        }
        if (route.pathMatch !== void 0 && route.pathMatch !== 'full' && route.pathMatch !== 'prefix') {
            throw new Error("Invalid configuration of route '" + fullPath + "': pathMatch can only be set to 'prefix' or 'full'");
        }
        if (route.children) {
            validateConfig(route.children, fullPath);
        }
    }
    function getFullPath(parentPath, currentRoute) {
        if (!currentRoute) {
            return parentPath;
        }
        if (!parentPath && !currentRoute.path) {
            return '';
        }
        else if (parentPath && !currentRoute.path) {
            return parentPath + "/";
        }
        else if (!parentPath && currentRoute.path) {
            return currentRoute.path;
        }
        else {
            return parentPath + "/" + currentRoute.path;
        }
    }
    /**
     * Makes a copy of the config and adds any default required properties.
     */
    function standardizeConfig(r) {
        var children = r.children && r.children.map(standardizeConfig);
        var c = children ? __assign$1({}, r, { children: children }) : __assign$1({}, r);
        if (!c.component && (children || c.loadChildren) && (c.outlet && c.outlet !== PRIMARY_OUTLET)) {
            c.component = ɵEmptyOutletComponent;
        }
        return c;
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function shallowEqualArrays(a, b) {
        if (a.length !== b.length)
            return false;
        for (var i = 0; i < a.length; ++i) {
            if (!shallowEqual(a[i], b[i]))
                return false;
        }
        return true;
    }
    function shallowEqual(a, b) {
        // Casting Object.keys return values to include `undefined` as there are some cases
        // in IE 11 where this can happen. Cannot provide a test because the behavior only
        // exists in certain circumstances in IE 11, therefore doing this cast ensures the
        // logic is correct for when this edge case is hit.
        var k1 = Object.keys(a);
        var k2 = Object.keys(b);
        if (!k1 || !k2 || k1.length != k2.length) {
            return false;
        }
        var key;
        for (var i = 0; i < k1.length; i++) {
            key = k1[i];
            if (a[key] !== b[key]) {
                return false;
            }
        }
        return true;
    }
    /**
     * Flattens single-level nested arrays.
     */
    function flatten(arr) {
        return Array.prototype.concat.apply([], arr);
    }
    /**
     * Return the last element of an array.
     */
    function last(a) {
        return a.length > 0 ? a[a.length - 1] : null;
    }
    function forEach(map, callback) {
        for (var prop in map) {
            if (map.hasOwnProperty(prop)) {
                callback(map[prop], prop);
            }
        }
    }
    function waitForMap(obj, fn) {
        if (Object.keys(obj).length === 0) {
            return rxjs.of({});
        }
        var waitHead = [];
        var waitTail = [];
        var res = {};
        forEach(obj, function (a, k) {
            var mapped = fn(k, a).pipe(operators.map(function (r) { return res[k] = r; }));
            if (k === PRIMARY_OUTLET) {
                waitHead.push(mapped);
            }
            else {
                waitTail.push(mapped);
            }
        });
        // Closure compiler has problem with using spread operator here. So just using Array.concat.
        return rxjs.of.apply(null, waitHead.concat(waitTail)).pipe(operators.concatAll(), operators.last(), operators.map(function () { return res; }));
    }
    function wrapIntoObservable(value) {
        if (core.ɵisObservable(value)) {
            return value;
        }
        if (core.ɵisPromise(value)) {
            // Use `Promise.resolve()` to wrap promise-like instances.
            // Required ie when a Resolver returns a AngularJS `$q` promise to correctly trigger the
            // change detection.
            return rxjs.from(Promise.resolve(value));
        }
        return rxjs.of(value);
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function createEmptyUrlTree() {
        return new UrlTree(new UrlSegmentGroup([], {}), {}, null);
    }
    function containsTree(container, containee, exact) {
        if (exact) {
            return equalQueryParams(container.queryParams, containee.queryParams) &&
                equalSegmentGroups(container.root, containee.root);
        }
        return containsQueryParams(container.queryParams, containee.queryParams) &&
            containsSegmentGroup(container.root, containee.root);
    }
    function equalQueryParams(container, containee) {
        // TODO: This does not handle array params correctly.
        return shallowEqual(container, containee);
    }
    function equalSegmentGroups(container, containee) {
        if (!equalPath(container.segments, containee.segments))
            return false;
        if (container.numberOfChildren !== containee.numberOfChildren)
            return false;
        for (var c in containee.children) {
            if (!container.children[c])
                return false;
            if (!equalSegmentGroups(container.children[c], containee.children[c]))
                return false;
        }
        return true;
    }
    function containsQueryParams(container, containee) {
        // TODO: This does not handle array params correctly.
        return Object.keys(containee).length <= Object.keys(container).length &&
            Object.keys(containee).every(function (key) { return containee[key] === container[key]; });
    }
    function containsSegmentGroup(container, containee) {
        return containsSegmentGroupHelper(container, containee, containee.segments);
    }
    function containsSegmentGroupHelper(container, containee, containeePaths) {
        if (container.segments.length > containeePaths.length) {
            var current = container.segments.slice(0, containeePaths.length);
            if (!equalPath(current, containeePaths))
                return false;
            if (containee.hasChildren())
                return false;
            return true;
        }
        else if (container.segments.length === containeePaths.length) {
            if (!equalPath(container.segments, containeePaths))
                return false;
            for (var c in containee.children) {
                if (!container.children[c])
                    return false;
                if (!containsSegmentGroup(container.children[c], containee.children[c]))
                    return false;
            }
            return true;
        }
        else {
            var current = containeePaths.slice(0, container.segments.length);
            var next = containeePaths.slice(container.segments.length);
            if (!equalPath(container.segments, current))
                return false;
            if (!container.children[PRIMARY_OUTLET])
                return false;
            return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next);
        }
    }
    /**
     * @description
     *
     * Represents the parsed URL.
     *
     * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a
     * serialized tree.
     * UrlTree is a data structure that provides a lot of affordances in dealing with URLs
     *
     * @usageNotes
     * ### Example
     *
     * ```
     * @Component({templateUrl:'template.html'})
     * class MyComponent {
     *   constructor(router: Router) {
     *     const tree: UrlTree =
     *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');
     *     const f = tree.fragment; // return 'fragment'
     *     const q = tree.queryParams; // returns {debug: 'true'}
     *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];
     *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'
     *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'
     *     g.children['support'].segments; // return 1 segment 'help'
     *   }
     * }
     * ```
     *
     * @publicApi
     */
    var UrlTree = /** @class */ (function () {
        /** @internal */
        function UrlTree(
        /** The root segment group of the URL tree */
        root, 
        /** The query params of the URL */
        queryParams, 
        /** The fragment of the URL */
        fragment) {
            this.root = root;
            this.queryParams = queryParams;
            this.fragment = fragment;
        }
        Object.defineProperty(UrlTree.prototype, "queryParamMap", {
            get: function () {
                if (!this._queryParamMap) {
                    this._queryParamMap = convertToParamMap(this.queryParams);
                }
                return this._queryParamMap;
            },
            enumerable: true,
            configurable: true
        });
        /** @docsNotRequired */
        UrlTree.prototype.toString = function () { return DEFAULT_SERIALIZER.serialize(this); };
        return UrlTree;
    }());
    /**
     * @description
     *
     * Represents the parsed URL segment group.
     *
     * See `UrlTree` for more information.
     *
     * @publicApi
     */
    var UrlSegmentGroup = /** @class */ (function () {
        function UrlSegmentGroup(
        /** The URL segments of this group. See `UrlSegment` for more information */
        segments, 
        /** The list of children of this group */
        children) {
            var _this = this;
            this.segments = segments;
            this.children = children;
            /** The parent node in the url tree */
            this.parent = null;
            forEach(children, function (v, k) { return v.parent = _this; });
        }
        /** Whether the segment has child segments */
        UrlSegmentGroup.prototype.hasChildren = function () { return this.numberOfChildren > 0; };
        Object.defineProperty(UrlSegmentGroup.prototype, "numberOfChildren", {
            /** Number of child segments */
            get: function () { return Object.keys(this.children).length; },
            enumerable: true,
            configurable: true
        });
        /** @docsNotRequired */
        UrlSegmentGroup.prototype.toString = function () { return serializePaths(this); };
        return UrlSegmentGroup;
    }());
    /**
     * @description
     *
     * Represents a single URL segment.
     *
     * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix
     * parameters associated with the segment.
     *
     * @usageNotes
     * ### Example
     *
     * ```
     * @Component({templateUrl:'template.html'})
     * class MyComponent {
     *   constructor(router: Router) {
     *     const tree: UrlTree = router.parseUrl('/team;id=33');
     *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];
     *     const s: UrlSegment[] = g.segments;
     *     s[0].path; // returns 'team'
     *     s[0].parameters; // returns {id: 33}
     *   }
     * }
     * ```
     *
     * @publicApi
     */
    var UrlSegment = /** @class */ (function () {
        function UrlSegment(
        /** The path part of a URL segment */
        path, 
        /** The matrix parameters associated with a segment */
        parameters) {
            this.path = path;
            this.parameters = parameters;
        }
        Object.defineProperty(UrlSegment.prototype, "parameterMap", {
            get: function () {
                if (!this._parameterMap) {
                    this._parameterMap = convertToParamMap(this.parameters);
                }
                return this._parameterMap;
            },
            enumerable: true,
            configurable: true
        });
        /** @docsNotRequired */
        UrlSegment.prototype.toString = function () { return serializePath(this); };
        return UrlSegment;
    }());
    function equalSegments(as, bs) {
        return equalPath(as, bs) && as.every(function (a, i) { return shallowEqual(a.parameters, bs[i].parameters); });
    }
    function equalPath(as, bs) {
        if (as.length !== bs.length)
            return false;
        return as.every(function (a, i) { return a.path === bs[i].path; });
    }
    function mapChildrenIntoArray(segment, fn) {
        var res = [];
        forEach(segment.children, function (child, childOutlet) {
            if (childOutlet === PRIMARY_OUTLET) {
                res = res.concat(fn(child, childOutlet));
            }
        });
        forEach(segment.children, function (child, childOutlet) {
            if (childOutlet !== PRIMARY_OUTLET) {
                res = res.concat(fn(child, childOutlet));
            }
        });
        return res;
    }
    /**
     * @description
     *
     * Serializes and deserializes a URL string into a URL tree.
     *
     * The url serialization strategy is customizable. You can
     * make all URLs case insensitive by providing a custom UrlSerializer.
     *
     * See `DefaultUrlSerializer` for an example of a URL serializer.
     *
     * @publicApi
     */
    var UrlSerializer = /** @class */ (function () {
        function UrlSerializer() {
        }
        return UrlSerializer;
    }());
    /**
     * @description
     *
     * A default implementation of the `UrlSerializer`.
     *
     * Example URLs:
     *
     * ```
     * /inbox/33(popup:compose)
     * /inbox/33;open=true/messages/44
     * ```
     *
     * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the
     * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to
     * specify route specific parameters.
     *
     * @publicApi
     */
    var DefaultUrlSerializer = /** @class */ (function () {
        function DefaultUrlSerializer() {
        }
        /** Parses a url into a `UrlTree` */
        DefaultUrlSerializer.prototype.parse = function (url) {
            var p = new UrlParser(url);
            return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());
        };
        /** Converts a `UrlTree` into a url */
        DefaultUrlSerializer.prototype.serialize = function (tree) {
            var segment = "/" + serializeSegment(tree.root, true);
            var query = serializeQueryParams(tree.queryParams);
            var fragment = typeof tree.fragment === "string" ? "#" + encodeUriFragment(tree.fragment) : '';
            return "" + segment + query + fragment;
        };
        return DefaultUrlSerializer;
    }());
    var DEFAULT_SERIALIZER = new DefaultUrlSerializer();
    function serializePaths(segment) {
        return segment.segments.map(function (p) { return serializePath(p); }).join('/');
    }
    function serializeSegment(segment, root) {
        if (!segment.hasChildren()) {
            return serializePaths(segment);
        }
        if (root) {
            var primary = segment.children[PRIMARY_OUTLET] ?
                serializeSegment(segment.children[PRIMARY_OUTLET], false) :
                '';
            var children_1 = [];
            forEach(segment.children, function (v, k) {
                if (k !== PRIMARY_OUTLET) {
                    children_1.push(k + ":" + serializeSegment(v, false));
                }
            });
            return children_1.length > 0 ? primary + "(" + children_1.join('//') + ")" : primary;
        }
        else {
            var children = mapChildrenIntoArray(segment, function (v, k) {
                if (k === PRIMARY_OUTLET) {
                    return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];
                }
                return [k + ":" + serializeSegment(v, false)];
            });
            return serializePaths(segment) + "/(" + children.join('//') + ")";
        }
    }
    /**
     * Encodes a URI string with the default encoding. This function will only ever be called from
     * `encodeUriQuery` or `encodeUriSegment` as it's the base set of encodings to be used. We need
     * a custom encoding because encodeURIComponent is too aggressive and encodes stuff that doesn't
     * have to be encoded per https://url.spec.whatwg.org.
     */
    function encodeUriString(s) {
        return encodeURIComponent(s)
            .replace(/%40/g, '@')
            .replace(/%3A/gi, ':')
            .replace(/%24/g, '$')
            .replace(/%2C/gi, ',');
    }
    /**
     * This function should be used to encode both keys and values in a query string key/value. In
     * the following URL, you need to call encodeUriQuery on "k" and "v":
     *
     * http://www.site.org/html;mk=mv?k=v#f
     */
    function encodeUriQuery(s) {
        return encodeUriString(s).replace(/%3B/gi, ';');
    }
    /**
     * This function should be used to encode a URL fragment. In the following URL, you need to call
     * encodeUriFragment on "f":
     *
     * http://www.site.org/html;mk=mv?k=v#f
     */
    function encodeUriFragment(s) {
        return encodeURI(s);
    }
    /**
     * This function should be run on any URI segment as well as the key and value in a key/value
     * pair for matrix params. In the following URL, you need to call encodeUriSegment on "html",
     * "mk", and "mv":
     *
     * http://www.site.org/html;mk=mv?k=v#f
     */
    function encodeUriSegment(s) {
        return encodeUriString(s).replace(/\(/g, '%28').replace(/\)/g, '%29').replace(/%26/gi, '&');
    }
    function decode(s) {
        return decodeURIComponent(s);
    }
    // Query keys/values should have the "+" replaced first, as "+" in a query string is " ".
    // decodeURIComponent function will not decode "+" as a space.
    function decodeQuery(s) {
        return decode(s.replace(/\+/g, '%20'));
    }
    function serializePath(path) {
        return "" + encodeUriSegment(path.path) + serializeMatrixParams(path.parameters);
    }
    function serializeMatrixParams(params) {
        return Object.keys(params)
            .map(function (key) { return ";" + encodeUriSegment(key) + "=" + encodeUriSegment(params[key]); })
            .join('');
    }
    function serializeQueryParams(params) {
        var strParams = Object.keys(params).map(function (name) {
            var value = params[name];
            return Array.isArray(value) ?
                value.map(function (v) { return encodeUriQuery(name) + "=" + encodeUriQuery(v); }).join('&') :
                encodeUriQuery(name) + "=" + encodeUriQuery(value);
        });
        return strParams.length ? "?" + strParams.join("&") : '';
    }
    var SEGMENT_RE = /^[^\/()?;=#]+/;
    function matchSegments(str) {
        var match = str.match(SEGMENT_RE);
        return match ? match[0] : '';
    }
    var QUERY_PARAM_RE = /^[^=?&#]+/;
    // Return the name of the query param at the start of the string or an empty string
    function matchQueryParams(str) {
        var match = str.match(QUERY_PARAM_RE);
        return match ? match[0] : '';
    }
    var QUERY_PARAM_VALUE_RE = /^[^?&#]+/;
    // Return the value of the query param at the start of the string or an empty string
    function matchUrlQueryParamValue(str) {
        var match = str.match(QUERY_PARAM_VALUE_RE);
        return match ? match[0] : '';
    }
    var UrlParser = /** @class */ (function () {
        function UrlParser(url) {
            this.url = url;
            this.remaining = url;
        }
        UrlParser.prototype.parseRootSegment = function () {
            this.consumeOptional('/');
            if (this.remaining === '' || this.peekStartsWith('?') || this.peekStartsWith('#')) {
                return new UrlSegmentGroup([], {});
            }
            // The root segment group never has segments
            return new UrlSegmentGroup([], this.parseChildren());
        };
        UrlParser.prototype.parseQueryParams = function () {
            var params = {};
            if (this.consumeOptional('?')) {
                do {
                    this.parseQueryParam(params);
                } while (this.consumeOptional('&'));
            }
            return params;
        };
        UrlParser.prototype.parseFragment = function () {
            return this.consumeOptional('#') ? decodeURIComponent(this.remaining) : null;
        };
        UrlParser.prototype.parseChildren = function () {
            if (this.remaining === '') {
                return {};
            }
            this.consumeOptional('/');
            var segments = [];
            if (!this.peekStartsWith('(')) {
                segments.push(this.parseSegment());
            }
            while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {
                this.capture('/');
                segments.push(this.parseSegment());
            }
            var children = {};
            if (this.peekStartsWith('/(')) {
                this.capture('/');
                children = this.parseParens(true);
            }
            var res = {};
            if (this.peekStartsWith('(')) {
                res = this.parseParens(false);
            }
            if (segments.length > 0 || Object.keys(children).length > 0) {
                res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);
            }
            return res;
        };
        // parse a segment with its matrix parameters
        // ie `name;k1=v1;k2`
        UrlParser.prototype.parseSegment = function () {
            var path = matchSegments(this.remaining);
            if (path === '' && this.peekStartsWith(';')) {
                throw new Error("Empty path url segment cannot have parameters: '" + this.remaining + "'.");
            }
            this.capture(path);
            return new UrlSegment(decode(path), this.parseMatrixParams());
        };
        UrlParser.prototype.parseMatrixParams = function () {
            var params = {};
            while (this.consumeOptional(';')) {
                this.parseParam(params);
            }
            return params;
        };
        UrlParser.prototype.parseParam = function (params) {
            var key = matchSegments(this.remaining);
            if (!key) {
                return;
            }
            this.capture(key);
            var value = '';
            if (this.consumeOptional('=')) {
                var valueMatch = matchSegments(this.remaining);
                if (valueMatch) {
                    value = valueMatch;
                    this.capture(value);
                }
            }
            params[decode(key)] = decode(value);
        };
        // Parse a single query parameter `name[=value]`
        UrlParser.prototype.parseQueryParam = function (params) {
            var key = matchQueryParams(this.remaining);
            if (!key) {
                return;
            }
            this.capture(key);
            var value = '';
            if (this.consumeOptional('=')) {
                var valueMatch = matchUrlQueryParamValue(this.remaining);
                if (valueMatch) {
                    value = valueMatch;
                    this.capture(value);
                }
            }
            var decodedKey = decodeQuery(key);
            var decodedVal = decodeQuery(value);
            if (params.hasOwnProperty(decodedKey)) {
                // Append to existing values
                var currentVal = params[decodedKey];
                if (!Array.isArray(currentVal)) {
                    currentVal = [currentVal];
                    params[decodedKey] = currentVal;
                }
                currentVal.push(decodedVal);
            }
            else {
                // Create a new value
                params[decodedKey] = decodedVal;
            }
        };
        // parse `(a/b//outlet_name:c/d)`
        UrlParser.prototype.parseParens = function (allowPrimary) {
            var segments = {};
            this.capture('(');
            while (!this.consumeOptional(')') && this.remaining.length > 0) {
                var path = matchSegments(this.remaining);
                var next = this.remaining[path.length];
                // if is is not one of these characters, then the segment was unescaped
                // or the group was not closed
                if (next !== '/' && next !== ')' && next !== ';') {
                    throw new Error("Cannot parse url '" + this.url + "'");
                }
                var outletName = undefined;
                if (path.indexOf(':') > -1) {
                    outletName = path.substr(0, path.indexOf(':'));
                    this.capture(outletName);
                    this.capture(':');
                }
                else if (allowPrimary) {
                    outletName = PRIMARY_OUTLET;
                }
                var children = this.parseChildren();
                segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] :
                    new UrlSegmentGroup([], children);
                this.consumeOptional('//');
            }
            return segments;
        };
        UrlParser.prototype.peekStartsWith = function (str) { return this.remaining.startsWith(str); };
        // Consumes the prefix when it is present and returns whether it has been consumed
        UrlParser.prototype.consumeOptional = function (str) {
            if (this.peekStartsWith(str)) {
                this.remaining = this.remaining.substring(str.length);
                return true;
            }
            return false;
        };
        UrlParser.prototype.capture = function (str) {
            if (!this.consumeOptional(str)) {
                throw new Error("Expected \"" + str + "\".");
            }
        };
        return UrlParser;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var Tree = /** @class */ (function () {
        function Tree(root) {
            this._root = root;
        }
        Object.defineProperty(Tree.prototype, "root", {
            get: function () { return this._root.value; },
            enumerable: true,
            configurable: true
        });
        /**
         * @internal
         */
        Tree.prototype.parent = function (t) {
            var p = this.pathFromRoot(t);
            return p.length > 1 ? p[p.length - 2] : null;
        };
        /**
         * @internal
         */
        Tree.prototype.children = function (t) {
            var n = findNode(t, this._root);
            return n ? n.children.map(function (t) { return t.value; }) : [];
        };
        /**
         * @internal
         */
        Tree.prototype.firstChild = function (t) {
            var n = findNode(t, this._root);
            return n && n.children.length > 0 ? n.children[0].value : null;
        };
        /**
         * @internal
         */
        Tree.prototype.siblings = function (t) {
            var p = findPath(t, this._root);
            if (p.length < 2)
                return [];
            var c = p[p.length - 2].children.map(function (c) { return c.value; });
            return c.filter(function (cc) { return cc !== t; });
        };
        /**
         * @internal
         */
        Tree.prototype.pathFromRoot = function (t) { return findPath(t, this._root).map(function (s) { return s.value; }); };
        return Tree;
    }());
    // DFS for the node matching the value
    function findNode(value, node) {
        var e_1, _a;
        if (value === node.value)
            return node;
        try {
            for (var _b = __values(node.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                var node_1 = findNode(value, child);
                if (node_1)
                    return node_1;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return null;
    }
    // Return the path to the node with the given value using DFS
    function findPath(value, node) {
        var e_2, _a;
        if (value === node.value)
            return [node];
        try {
            for (var _b = __values(node.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                var path = findPath(value, child);
                if (path.length) {
                    path.unshift(node);
                    return path;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return [];
    }
    var TreeNode = /** @class */ (function () {
        function TreeNode(value, children) {
            this.value = value;
            this.children = children;
        }
        TreeNode.prototype.toString = function () { return "TreeNode(" + this.value + ")"; };
        return TreeNode;
    }());
    // Return the list of T indexed by outlet name
    function nodeChildrenAsMap(node) {
        var map = {};
        if (node) {
            node.children.forEach(function (child) { return map[child.value.outlet] = child; });
        }
        return map;
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @description
     *
     * Represents the state of the router.
     *
     * RouterState is a tree of activated routes. Every node in this tree knows about the "consumed" URL
     * segments, the extracted parameters, and the resolved data.
     *
     * @usageNotes
     * ### Example
     *
     * ```
     * @Component({templateUrl:'template.html'})
     * class MyComponent {
     *   constructor(router: Router) {
     *     const state: RouterState = router.routerState;
     *     const root: ActivatedRoute = state.root;
     *     const child = root.firstChild;
     *     const id: Observable<string> = child.params.map(p => p.id);
     *     //...
     *   }
     * }
     * ```
     *
     * See `ActivatedRoute` for more information.
     *
     * @publicApi
     */
    var RouterState = /** @class */ (function (_super) {
        __extends(RouterState, _super);
        /** @internal */
        function RouterState(root, 
        /** The current snapshot of the router state */
        snapshot) {
            var _this = _super.call(this, root) || this;
            _this.snapshot = snapshot;
            setRouterState(_this, root);
            return _this;
        }
        RouterState.prototype.toString = function () { return this.snapshot.toString(); };
        return RouterState;
    }(Tree));
    function createEmptyState(urlTree, rootComponent) {
        var snapshot = createEmptyStateSnapshot(urlTree, rootComponent);
        var emptyUrl = new rxjs.BehaviorSubject([new UrlSegment('', {})]);
        var emptyParams = new rxjs.BehaviorSubject({});
        var emptyData = new rxjs.BehaviorSubject({});
        var emptyQueryParams = new rxjs.BehaviorSubject({});
        var fragment = new rxjs.BehaviorSubject('');
        var activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);
        activated.snapshot = snapshot.root;
        return new RouterState(new TreeNode(activated, []), snapshot);
    }
    function createEmptyStateSnapshot(urlTree, rootComponent) {
        var emptyParams = {};
        var emptyData = {};
        var emptyQueryParams = {};
        var fragment = '';
        var activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, urlTree.root, -1, {});
        return new RouterStateSnapshot('', new TreeNode(activated, []));
    }
    /**
     * @description
     *
     * Contains the information about a route associated with a component loaded in an
     * outlet.  An `ActivatedRoute` can also be used to traverse the router state tree.
     *
     * {@example router/activated-route/module.ts region="activated-route"
     *     header="activated-route.component.ts" linenums="false"}
     *
     * @publicApi
     */
    var ActivatedRoute = /** @class */ (function () {
        /** @internal */
        function ActivatedRoute(
        /** An observable of the URL segments matched by this route */
        url, 
        /** An observable of the matrix parameters scoped to this route */
        params, 
        /** An observable of the query parameters shared by all the routes */
        queryParams, 
        /** An observable of the URL fragment shared by all the routes */
        fragment, 
        /** An observable of the static and resolved data of this route. */
        data, 
        /** The outlet name of the route. It's a constant */
        outlet, 
        /** The component of the route. It's a constant */
        // TODO(vsavkin): remove |string
        component, futureSnapshot) {
            this.url = url;
            this.params = params;
            this.queryParams = queryParams;
            this.fragment = fragment;
            this.data = data;
            this.outlet = outlet;
            this.component = component;
            this._futureSnapshot = futureSnapshot;
        }
        Object.defineProperty(ActivatedRoute.prototype, "routeConfig", {
            /** The configuration used to match this route */
            get: function () { return this._futureSnapshot.routeConfig; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivatedRoute.prototype, "root", {
            /** The root of the router state */
            get: function () { return this._routerState.root; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivatedRoute.prototype, "parent", {
            /** The parent of this route in the router state tree */
            get: function () { return this._routerState.parent(this); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivatedRoute.prototype, "firstChild", {
            /** The first child of this route in the router state tree */
            get: function () { return this._routerState.firstChild(this); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivatedRoute.prototype, "children", {
            /** The children of this route in the router state tree */
            get: function () { return this._routerState.children(this); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivatedRoute.prototype, "pathFromRoot", {
            /** The path from the root of the router state tree to this route */
            get: function () { return this._routerState.pathFromRoot(this); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivatedRoute.prototype, "paramMap", {
            get: function () {
                if (!this._paramMap) {
                    this._paramMap = this.params.pipe(operators.map(function (p) { return convertToParamMap(p); }));
                }
                return this._paramMap;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivatedRoute.prototype, "queryParamMap", {
            get: function () {
                if (!this._queryParamMap) {
                    this._queryParamMap =
                        this.queryParams.pipe(operators.map(function (p) { return convertToParamMap(p); }));
                }
                return this._queryParamMap;
            },
            enumerable: true,
            configurable: true
        });
        ActivatedRoute.prototype.toString = function () {
            return this.snapshot ? this.snapshot.toString() : "Future(" + this._futureSnapshot + ")";
        };
        return ActivatedRoute;
    }());
    /**
     * Returns the inherited params, data, and resolve for a given route.
     * By default, this only inherits values up to the nearest path-less or component-less route.
     * @internal
     */
    function inheritedParamsDataResolve(route, paramsInheritanceStrategy) {
        if (paramsInheritanceStrategy === void 0) { paramsInheritanceStrategy = 'emptyOnly'; }
        var pathFromRoot = route.pathFromRoot;
        var inheritingStartingFrom = 0;
        if (paramsInheritanceStrategy !== 'always') {
            inheritingStartingFrom = pathFromRoot.length - 1;
            while (inheritingStartingFrom >= 1) {
                var current = pathFromRoot[inheritingStartingFrom];
                var parent_1 = pathFromRoot[inheritingStartingFrom - 1];
                // current route is an empty path => inherits its parent's params and data
                if (current.routeConfig && current.routeConfig.path === '') {
                    inheritingStartingFrom--;
                    // parent is componentless => current route should inherit its params and data
                }
                else if (!parent_1.component) {
                    inheritingStartingFrom--;
                }
                else {
                    break;
                }
            }
        }
        return flattenInherited(pathFromRoot.slice(inheritingStartingFrom));
    }
    /** @internal */
    function flattenInherited(pathFromRoot) {
        return pathFromRoot.reduce(function (res, curr) {
            var params = __assign$1({}, res.params, curr.params);
            var data = __assign$1({}, res.data, curr.data);
            var resolve = __assign$1({}, res.resolve, curr._resolvedData);
            return { params: params, data: data, resolve: resolve };
        }, { params: {}, data: {}, resolve: {} });
    }
    /**
     * @description
     *
     * Contains the information about a route associated with a component loaded in an
     * outlet at a particular moment in time. ActivatedRouteSnapshot can also be used to
     * traverse the router state tree.
     *
     * ```
     * @Component({templateUrl:'./my-component.html'})
     * class MyComponent {
     *   constructor(route: ActivatedRoute) {
     *     const id: string = route.snapshot.params.id;
     *     const url: string = route.snapshot.url.join('');
     *     const user = route.snapshot.data.user;
     *   }
     * }
     * ```
     *
     * @publicApi
     */
    var ActivatedRouteSnapshot = /** @class */ (function () {
        /** @internal */
        function ActivatedRouteSnapshot(
        /** The URL segments matched by this route */
        url, 
        /** The matrix parameters scoped to this route */
        params, 
        /** The query parameters shared by all the routes */
        queryParams, 
        /** The URL fragment shared by all the routes */
        fragment, 
        /** The static and resolved data of this route */
        data, 
        /** The outlet name of the route */
        outlet, 
        /** The component of the route */
        component, routeConfig, urlSegment, lastPathIndex, resolve) {
            this.url = url;
            this.params = params;
            this.queryParams = queryParams;
            this.fragment = fragment;
            this.data = data;
            this.outlet = outlet;
            this.component = component;
            this.routeConfig = routeConfig;
            this._urlSegment = urlSegment;
            this._lastPathIndex = lastPathIndex;
            this._resolve = resolve;
        }
        Object.defineProperty(ActivatedRouteSnapshot.prototype, "root", {
            /** The root of the router state */
            get: function () { return this._routerState.root; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivatedRouteSnapshot.prototype, "parent", {
            /** The parent of this route in the router state tree */
            get: function () { return this._routerState.parent(this); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivatedRouteSnapshot.prototype, "firstChild", {
            /** The first child of this route in the router state tree */
            get: function () { return this._routerState.firstChild(this); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivatedRouteSnapshot.prototype, "children", {
            /** The children of this route in the router state tree */
            get: function () { return this._routerState.children(this); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivatedRouteSnapshot.prototype, "pathFromRoot", {
            /** The path from the root of the router state tree to this route */
            get: function () { return this._routerState.pathFromRoot(this); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivatedRouteSnapshot.prototype, "paramMap", {
            get: function () {
                if (!this._paramMap) {
                    this._paramMap = convertToParamMap(this.params);
                }
                return this._paramMap;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivatedRouteSnapshot.prototype, "queryParamMap", {
            get: function () {
                if (!this._queryParamMap) {
                    this._queryParamMap = convertToParamMap(this.queryParams);
                }
                return this._queryParamMap;
            },
            enumerable: true,
            configurable: true
        });
        ActivatedRouteSnapshot.prototype.toString = function () {
            var url = this.url.map(function (segment) { return segment.toString(); }).join('/');
            var matched = this.routeConfig ? this.routeConfig.path : '';
            return "Route(url:'" + url + "', path:'" + matched + "')";
        };
        return ActivatedRouteSnapshot;
    }());
    /**
     * @description
     *
     * Represents the state of the router at a moment in time.
     *
     * This is a tree of activated route snapshots. Every node in this tree knows about
     * the "consumed" URL segments, the extracted parameters, and the resolved data.
     *
     * @usageNotes
     * ### Example
     *
     * ```
     * @Component({templateUrl:'template.html'})
     * class MyComponent {
     *   constructor(router: Router) {
     *     const state: RouterState = router.routerState;
     *     const snapshot: RouterStateSnapshot = state.snapshot;
     *     const root: ActivatedRouteSnapshot = snapshot.root;
     *     const child = root.firstChild;
     *     const id: Observable<string> = child.params.map(p => p.id);
     *     //...
     *   }
     * }
     * ```
     *
     * @publicApi
     */
    var RouterStateSnapshot = /** @class */ (function (_super) {
        __extends(RouterStateSnapshot, _super);
        /** @internal */
        function RouterStateSnapshot(
        /** The url from which this snapshot was created */
        url, root) {
            var _this = _super.call(this, root) || this;
            _this.url = url;
            setRouterState(_this, root);
            return _this;
        }
        RouterStateSnapshot.prototype.toString = function () { return serializeNode(this._root); };
        return RouterStateSnapshot;
    }(Tree));
    function setRouterState(state, node) {
        node.value._routerState = state;
        node.children.forEach(function (c) { return setRouterState(state, c); });
    }
    function serializeNode(node) {
        var c = node.children.length > 0 ? " { " + node.children.map(serializeNode).join(', ') + " } " : '';
        return "" + node.value + c;
    }
    /**
     * The expectation is that the activate route is created with the right set of parameters.
     * So we push new values into the observables only when they are not the initial values.
     * And we detect that by checking if the snapshot field is set.
     */
    function advanceActivatedRoute(route) {
        if (route.snapshot) {
            var currentSnapshot = route.snapshot;
            var nextSnapshot = route._futureSnapshot;
            route.snapshot = nextSnapshot;
            if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {
                route.queryParams.next(nextSnapshot.queryParams);
            }
            if (currentSnapshot.fragment !== nextSnapshot.fragment) {
                route.fragment.next(nextSnapshot.fragment);
            }
            if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {
                route.params.next(nextSnapshot.params);
            }
            if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {
                route.url.next(nextSnapshot.url);
            }
            if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {
                route.data.next(nextSnapshot.data);
            }
        }
        else {
            route.snapshot = route._futureSnapshot;
            // this is for resolved data
            route.data.next(route._futureSnapshot.data);
        }
    }
    function equalParamsAndUrlSegments(a, b) {
        var equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);
        var parentsMismatch = !a.parent !== !b.parent;
        return equalUrlParams && !parentsMismatch &&
            (!a.parent || equalParamsAndUrlSegments(a.parent, b.parent));
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function createRouterState(routeReuseStrategy, curr, prevState) {
        var root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : undefined);
        return new RouterState(root, curr);
    }
    function createNode(routeReuseStrategy, curr, prevState) {
        // reuse an activated route that is currently displayed on the screen
        if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {
            var value = prevState.value;
            value._futureSnapshot = curr.value;
            var children = createOrReuseChildren(routeReuseStrategy, curr, prevState);
            return new TreeNode(value, children);
            // retrieve an activated route that is used to be displayed, but is not currently displayed
        }
        else {
            var detachedRouteHandle = routeReuseStrategy.retrieve(curr.value);
            if (detachedRouteHandle) {
                var tree = detachedRouteHandle.route;
                setFutureSnapshotsOfActivatedRoutes(curr, tree);
                return tree;
            }
            else {
                var value = createActivatedRoute(curr.value);
                var children = curr.children.map(function (c) { return createNode(routeReuseStrategy, c); });
                return new TreeNode(value, children);
            }
        }
    }
    function setFutureSnapshotsOfActivatedRoutes(curr, result) {
        if (curr.value.routeConfig !== result.value.routeConfig) {
            throw new Error('Cannot reattach ActivatedRouteSnapshot created from a different route');
        }
        if (curr.children.length !== result.children.length) {
            throw new Error('Cannot reattach ActivatedRouteSnapshot with a different number of children');
        }
        result.value._futureSnapshot = curr.value;
        for (var i = 0; i < curr.children.length; ++i) {
            setFutureSnapshotsOfActivatedRoutes(curr.children[i], result.children[i]);
        }
    }
    function createOrReuseChildren(routeReuseStrategy, curr, prevState) {
        return curr.children.map(function (child) {
            var e_1, _a;
            try {
                for (var _b = __values(prevState.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var p = _c.value;
                    if (routeReuseStrategy.shouldReuseRoute(p.value.snapshot, child.value)) {
                        return createNode(routeReuseStrategy, child, p);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return createNode(routeReuseStrategy, child);
        });
    }
    function createActivatedRoute(c) {
        return new ActivatedRoute(new rxjs.BehaviorSubject(c.url), new rxjs.BehaviorSubject(c.params), new rxjs.BehaviorSubject(c.queryParams), new rxjs.BehaviorSubject(c.fragment), new rxjs.BehaviorSubject(c.data), c.outlet, c.component, c);
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function createUrlTree(route, urlTree, commands, queryParams, fragment) {
        if (commands.length === 0) {
            return tree(urlTree.root, urlTree.root, urlTree, queryParams, fragment);
        }
        var nav = computeNavigation(commands);
        if (nav.toRoot()) {
            return tree(urlTree.root, new UrlSegmentGroup([], {}), urlTree, queryParams, fragment);
        }
        var startingPosition = findStartingPosition(nav, urlTree, route);
        var segmentGroup = startingPosition.processChildren ?
            updateSegmentGroupChildren(startingPosition.segmentGroup, startingPosition.index, nav.commands) :
            updateSegmentGroup(startingPosition.segmentGroup, startingPosition.index, nav.commands);
        return tree(startingPosition.segmentGroup, segmentGroup, urlTree, queryParams, fragment);
    }
    function isMatrixParams(command) {
        return typeof command === 'object' && command != null && !command.outlets && !command.segmentPath;
    }
    function tree(oldSegmentGroup, newSegmentGroup, urlTree, queryParams, fragment) {
        var qp = {};
        if (queryParams) {
            forEach(queryParams, function (value, name) {
                qp[name] = Array.isArray(value) ? value.map(function (v) { return "" + v; }) : "" + value;
            });
        }
        if (urlTree.root === oldSegmentGroup) {
            return new UrlTree(newSegmentGroup, qp, fragment);
        }
        return new UrlTree(replaceSegment(urlTree.root, oldSegmentGroup, newSegmentGroup), qp, fragment);
    }
    function replaceSegment(current, oldSegment, newSegment) {
        var children = {};
        forEach(current.children, function (c, outletName) {
            if (c === oldSegment) {
                children[outletName] = newSegment;
            }
            else {
                children[outletName] = replaceSegment(c, oldSegment, newSegment);
            }
        });
        return new UrlSegmentGroup(current.segments, children);
    }
    var Navigation = /** @class */ (function () {
        function Navigation(isAbsolute, numberOfDoubleDots, commands) {
            this.isAbsolute = isAbsolute;
            this.numberOfDoubleDots = numberOfDoubleDots;
            this.commands = commands;
            if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {
                throw new Error('Root segment cannot have matrix parameters');
            }
            var cmdWithOutlet = commands.find(function (c) { return typeof c === 'object' && c != null && c.outlets; });
            if (cmdWithOutlet && cmdWithOutlet !== last(commands)) {
                throw new Error('{outlets:{}} has to be the last command');
            }
        }
        Navigation.prototype.toRoot = function () {
            return this.isAbsolute && this.commands.length === 1 && this.commands[0] == '/';
        };
        return Navigation;
    }());
    /** Transforms commands to a normalized `Navigation` */
    function computeNavigation(commands) {
        if ((typeof commands[0] === 'string') && commands.length === 1 && commands[0] === '/') {
            return new Navigation(true, 0, commands);
        }
        var numberOfDoubleDots = 0;
        var isAbsolute = false;
        var res = commands.reduce(function (res, cmd, cmdIdx) {
            if (typeof cmd === 'object' && cmd != null) {
                if (cmd.outlets) {
                    var outlets_1 = {};
                    forEach(cmd.outlets, function (commands, name) {
                        outlets_1[name] = typeof commands === 'string' ? commands.split('/') : commands;
                    });
                    return __spread(res, [{ outlets: outlets_1 }]);
                }
                if (cmd.segmentPath) {
                    return __spread(res, [cmd.segmentPath]);
                }
            }
            if (!(typeof cmd === 'string')) {
                return __spread(res, [cmd]);
            }
            if (cmdIdx === 0) {
                cmd.split('/').forEach(function (urlPart, partIndex) {
                    if (partIndex == 0 && urlPart === '.') ;
                    else if (partIndex == 0 && urlPart === '') { //  '/a'
                        isAbsolute = true;
                    }
                    else if (urlPart === '..') { //  '../a'
                        numberOfDoubleDots++;
                    }
                    else if (urlPart != '') {
                        res.push(urlPart);
                    }
                });
                return res;
            }
            return __spread(res, [cmd]);
        }, []);
        return new Navigation(isAbsolute, numberOfDoubleDots, res);
    }
    var Position = /** @class */ (function () {
        function Position(segmentGroup, processChildren, index) {
            this.segmentGroup = segmentGroup;
            this.processChildren = processChildren;
            this.index = index;
        }
        return Position;
    }());
    function findStartingPosition(nav, tree, route) {
        if (nav.isAbsolute) {
            return new Position(tree.root, true, 0);
        }
        if (route.snapshot._lastPathIndex === -1) {
            return new Position(route.snapshot._urlSegment, true, 0);
        }
        var modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;
        var index = route.snapshot._lastPathIndex + modifier;
        return createPositionApplyingDoubleDots(route.snapshot._urlSegment, index, nav.numberOfDoubleDots);
    }
    function createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {
        var g = group;
        var ci = index;
        var dd = numberOfDoubleDots;
        while (dd > ci) {
            dd -= ci;
            g = g.parent;
            if (!g) {
                throw new Error('Invalid number of \'../\'');
            }
            ci = g.segments.length;
        }
        return new Position(g, false, ci - dd);
    }
    function getPath(command) {
        if (typeof command === 'object' && command != null && command.outlets) {
            return command.outlets[PRIMARY_OUTLET];
        }
        return "" + command;
    }
    function getOutlets(commands) {
        var _a, _b;
        if (!(typeof commands[0] === 'object'))
            return _a = {}, _a[PRIMARY_OUTLET] = commands, _a;
        if (commands[0].outlets === undefined)
            return _b = {}, _b[PRIMARY_OUTLET] = commands, _b;
        return commands[0].outlets;
    }
    function updateSegmentGroup(segmentGroup, startIndex, commands) {
        if (!segmentGroup) {
            segmentGroup = new UrlSegmentGroup([], {});
        }
        if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
            return updateSegmentGroupChildren(segmentGroup, startIndex, commands);
        }
        var m = prefixedWith(segmentGroup, startIndex, commands);
        var slicedCommands = commands.slice(m.commandIndex);
        if (m.match && m.pathIndex < segmentGroup.segments.length) {
            var g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});
            g.children[PRIMARY_OUTLET] =
                new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);
            return updateSegmentGroupChildren(g, 0, slicedCommands);
        }
        else if (m.match && slicedCommands.length === 0) {
            return new UrlSegmentGroup(segmentGroup.segments, {});
        }
        else if (m.match && !segmentGroup.hasChildren()) {
            return createNewSegmentGroup(segmentGroup, startIndex, commands);
        }
        else if (m.match) {
            return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);
        }
        else {
            return createNewSegmentGroup(segmentGroup, startIndex, commands);
        }
    }
    function updateSegmentGroupChildren(segmentGroup, startIndex, commands) {
        if (commands.length === 0) {
            return new UrlSegmentGroup(segmentGroup.segments, {});
        }
        else {
            var outlets_2 = getOutlets(commands);
            var children_1 = {};
            forEach(outlets_2, function (commands, outlet) {
                if (commands !== null) {
                    children_1[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);
                }
            });
            forEach(segmentGroup.children, function (child, childOutlet) {
                if (outlets_2[childOutlet] === undefined) {
                    children_1[childOutlet] = child;
                }
            });
            return new UrlSegmentGroup(segmentGroup.segments, children_1);
        }
    }
    function prefixedWith(segmentGroup, startIndex, commands) {
        var currentCommandIndex = 0;
        var currentPathIndex = startIndex;
        var noMatch = { match: false, pathIndex: 0, commandIndex: 0 };
        while (currentPathIndex < segmentGroup.segments.length) {
            if (currentCommandIndex >= commands.length)
                return noMatch;
            var path = segmentGroup.segments[currentPathIndex];
            var curr = getPath(commands[currentCommandIndex]);
            var next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;
            if (currentPathIndex > 0 && curr === undefined)
                break;
            if (curr && next && (typeof next === 'object') && next.outlets === undefined) {
                if (!compare(curr, next, path))
                    return noMatch;
                currentCommandIndex += 2;
            }
            else {
                if (!compare(curr, {}, path))
                    return noMatch;
                currentCommandIndex++;
            }
            currentPathIndex++;
        }
        return { match: true, pathIndex: currentPathIndex, commandIndex: currentCommandIndex };
    }
    function createNewSegmentGroup(segmentGroup, startIndex, commands) {
        var paths = segmentGroup.segments.slice(0, startIndex);
        var i = 0;
        while (i < commands.length) {
            if (typeof commands[i] === 'object' && commands[i].outlets !== undefined) {
                var children = createNewSegmentChildren(commands[i].outlets);
                return new UrlSegmentGroup(paths, children);
            }
            // if we start with an object literal, we need to reuse the path part from the segment
            if (i === 0 && isMatrixParams(commands[0])) {
                var p = segmentGroup.segments[startIndex];
                paths.push(new UrlSegment(p.path, commands[0]));
                i++;
                continue;
            }
            var curr = getPath(commands[i]);
            var next = (i < commands.length - 1) ? commands[i + 1] : null;
            if (curr && next && isMatrixParams(next)) {
                paths.push(new UrlSegment(curr, stringify(next)));
                i += 2;
            }
            else {
                paths.push(new UrlSegment(curr, {}));
                i++;
            }
        }
        return new UrlSegmentGroup(paths, {});
    }
    function createNewSegmentChildren(outlets) {
        var children = {};
        forEach(outlets, function (commands, outlet) {
            if (commands !== null) {
                children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);
            }
        });
        return children;
    }
    function stringify(params) {
        var res = {};
        forEach(params, function (v, k) { return res[k] = "" + v; });
        return res;
    }
    function compare(path, params, segment) {
        return path == segment.path && shallowEqual(params, segment.parameters);
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var activateRoutes = function (rootContexts, routeReuseStrategy, forwardEvent) {
        return operators.map(function (t) {
            new ActivateRoutes(routeReuseStrategy, t.targetRouterState, t.currentRouterState, forwardEvent)
                .activate(rootContexts);
            return t;
        });
    };
    var ActivateRoutes = /** @class */ (function () {
        function ActivateRoutes(routeReuseStrategy, futureState, currState, forwardEvent) {
            this.routeReuseStrategy = routeReuseStrategy;
            this.futureState = futureState;
            this.currState = currState;
            this.forwardEvent = forwardEvent;
        }
        ActivateRoutes.prototype.activate = function (parentContexts) {
            var futureRoot = this.futureState._root;
            var currRoot = this.currState ? this.currState._root : null;
            this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);
            advanceActivatedRoute(this.futureState.root);
            this.activateChildRoutes(futureRoot, currRoot, parentContexts);
        };
        // De-activate the child route that are not re-used for the future state
        ActivateRoutes.prototype.deactivateChildRoutes = function (futureNode, currNode, contexts) {
            var _this = this;
            var children = nodeChildrenAsMap(currNode);
            // Recurse on the routes active in the future state to de-activate deeper children
            futureNode.children.forEach(function (futureChild) {
                var childOutletName = futureChild.value.outlet;
                _this.deactivateRoutes(futureChild, children[childOutletName], contexts);
                delete children[childOutletName];
            });
            // De-activate the routes that will not be re-used
            forEach(children, function (v, childName) {
                _this.deactivateRouteAndItsChildren(v, contexts);
            });
        };
        ActivateRoutes.prototype.deactivateRoutes = function (futureNode, currNode, parentContext) {
            var future = futureNode.value;
            var curr = currNode ? currNode.value : null;
            if (future === curr) {
                // Reusing the node, check to see if the children need to be de-activated
                if (future.component) {
                    // If we have a normal route, we need to go through an outlet.
                    var context = parentContext.getContext(future.outlet);
                    if (context) {
                        this.deactivateChildRoutes(futureNode, currNode, context.children);
                    }
                }
                else {
                    // if we have a componentless route, we recurse but keep the same outlet map.
                    this.deactivateChildRoutes(futureNode, currNode, parentContext);
                }
            }
            else {
                if (curr) {
                    // Deactivate the current route which will not be re-used
                    this.deactivateRouteAndItsChildren(currNode, parentContext);
                }
            }
        };
        ActivateRoutes.prototype.deactivateRouteAndItsChildren = function (route, parentContexts) {
            if (this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {
                this.detachAndStoreRouteSubtree(route, parentContexts);
            }
            else {
                this.deactivateRouteAndOutlet(route, parentContexts);
            }
        };
        ActivateRoutes.prototype.detachAndStoreRouteSubtree = function (route, parentContexts) {
            var context = parentContexts.getContext(route.value.outlet);
            if (context && context.outlet) {
                var componentRef = context.outlet.detach();
                var contexts = context.children.onOutletDeactivated();
                this.routeReuseStrategy.store(route.value.snapshot, { componentRef: componentRef, route: route, contexts: contexts });
            }
        };
        ActivateRoutes.prototype.deactivateRouteAndOutlet = function (route, parentContexts) {
            var _this = this;
            var context = parentContexts.getContext(route.value.outlet);
            if (context) {
                var children = nodeChildrenAsMap(route);
                var contexts_1 = route.value.component ? context.children : parentContexts;
                forEach(children, function (v, k) { return _this.deactivateRouteAndItsChildren(v, contexts_1); });
                if (context.outlet) {
                    // Destroy the component
                    context.outlet.deactivate();
                    // Destroy the contexts for all the outlets that were in the component
                    context.children.onOutletDeactivated();
                }
            }
        };
        ActivateRoutes.prototype.activateChildRoutes = function (futureNode, currNode, contexts) {
            var _this = this;
            var children = nodeChildrenAsMap(currNode);
            futureNode.children.forEach(function (c) {
                _this.activateRoutes(c, children[c.value.outlet], contexts);
                _this.forwardEvent(new ActivationEnd(c.value.snapshot));
            });
            if (futureNode.children.length) {
                this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));
            }
        };
        ActivateRoutes.prototype.activateRoutes = function (futureNode, currNode, parentContexts) {
            var future = futureNode.value;
            var curr = currNode ? currNode.value : null;
            advanceActivatedRoute(future);
            // reusing the node
            if (future === curr) {
                if (future.component) {
                    // If we have a normal route, we need to go through an outlet.
                    var context = parentContexts.getOrCreateContext(future.outlet);
                    this.activateChildRoutes(futureNode, currNode, context.children);
                }
                else {
                    // if we have a componentless route, we recurse but keep the same outlet map.
                    this.activateChildRoutes(futureNode, currNode, parentContexts);
                }
            }
            else {
                if (future.component) {
                    // if we have a normal route, we need to place the component into the outlet and recurse.
                    var context = parentContexts.getOrCreateContext(future.outlet);
                    if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {
                        var stored = this.routeReuseStrategy.retrieve(future.snapshot);
                        this.routeReuseStrategy.store(future.snapshot, null);
                        context.children.onOutletReAttached(stored.contexts);
                        context.attachRef = stored.componentRef;
                        context.route = stored.route.value;
                        if (context.outlet) {
                            // Attach right away when the outlet has already been instantiated
                            // Otherwise attach from `RouterOutlet.ngOnInit` when it is instantiated
                            context.outlet.attach(stored.componentRef, stored.route.value);
                        }
                        advanceActivatedRouteNodeAndItsChildren(stored.route);
                    }
                    else {
                        var config = parentLoadedConfig(future.snapshot);
                        var cmpFactoryResolver = config ? config.module.componentFactoryResolver : null;
                        context.attachRef = null;
                        context.route = future;
                        context.resolver = cmpFactoryResolver;
                        if (context.outlet) {
                            // Activate the outlet when it has already been instantiated
                            // Otherwise it will get activated from its `ngOnInit` when instantiated
                            context.outlet.activateWith(future, cmpFactoryResolver);
                        }
                        this.activateChildRoutes(futureNode, null, context.children);
                    }
                }
                else {
                    // if we have a componentless route, we recurse but keep the same outlet map.
                    this.activateChildRoutes(futureNode, null, parentContexts);
                }
            }
        };
        return ActivateRoutes;
    }());
    function advanceActivatedRouteNodeAndItsChildren(node) {
        advanceActivatedRoute(node.value);
        node.children.forEach(advanceActivatedRouteNodeAndItsChildren);
    }
    function parentLoadedConfig(snapshot) {
        for (var s = snapshot.parent; s; s = s.parent) {
            var route = s.routeConfig;
            if (route && route._loadedConfig)
                return route._loadedConfig;
            if (route && route.component)
                return null;
        }
        return null;
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Simple function check, but generic so type inference will flow. Example:
     *
     * function product(a: number, b: number) {
     *   return a * b;
     * }
     *
     * if (isFunction<product>(fn)) {
     *   return fn(1, 2);
     * } else {
     *   throw "Must provide the `product` function";
     * }
     */
    function isFunction(v) {
        return typeof v === 'function';
    }
    function isBoolean(v) {
        return typeof v === 'boolean';
    }
    function isUrlTree(v) {
        return v instanceof UrlTree;
    }
    function isCanLoad(guard) {
        return guard && isFunction(guard.canLoad);
    }
    function isCanActivate(guard) {
        return guard && isFunction(guard.canActivate);
    }
    function isCanActivateChild(guard) {
        return guard && isFunction(guard.canActivateChild);
    }
    function isCanDeactivate(guard) {
        return guard && isFunction(guard.canDeactivate);
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var NoMatch = /** @class */ (function () {
        function NoMatch(segmentGroup) {
            this.segmentGroup = segmentGroup || null;
        }
        return NoMatch;
    }());
    var AbsoluteRedirect = /** @class */ (function () {
        function AbsoluteRedirect(urlTree) {
            this.urlTree = urlTree;
        }
        return AbsoluteRedirect;
    }());
    function noMatch(segmentGroup) {
        return new rxjs.Observable(function (obs) { return obs.error(new NoMatch(segmentGroup)); });
    }
    function absoluteRedirect(newTree) {
        return new rxjs.Observable(function (obs) { return obs.error(new AbsoluteRedirect(newTree)); });
    }
    function namedOutletsRedirect(redirectTo) {
        return new rxjs.Observable(function (obs) { return obs.error(new Error("Only absolute redirects can have named outlets. redirectTo: '" + redirectTo + "'")); });
    }
    function canLoadFails(route) {
        return new rxjs.Observable(function (obs) { return obs.error(navigationCancelingError("Cannot load children because the guard of the route \"path: '" + route.path + "'\" returned false")); });
    }
    /**
     * Returns the `UrlTree` with the redirection applied.
     *
     * Lazy modules are loaded along the way.
     */
    function applyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config) {
        return new ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config).apply();
    }
    var ApplyRedirects = /** @class */ (function () {
        function ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config) {
            this.configLoader = configLoader;
            this.urlSerializer = urlSerializer;
            this.urlTree = urlTree;
            this.config = config;
            this.allowRedirects = true;
            this.ngModule = moduleInjector.get(core.NgModuleRef);
        }
        ApplyRedirects.prototype.apply = function () {
            var _this = this;
            var expanded$ = this.expandSegmentGroup(this.ngModule, this.config, this.urlTree.root, PRIMARY_OUTLET);
            var urlTrees$ = expanded$.pipe(operators.map(function (rootSegmentGroup) { return _this.createUrlTree(rootSegmentGroup, _this.urlTree.queryParams, _this.urlTree.fragment); }));
            return urlTrees$.pipe(operators.catchError(function (e) {
                if (e instanceof AbsoluteRedirect) {
                    // after an absolute redirect we do not apply any more redirects!
                    _this.allowRedirects = false;
                    // we need to run matching, so we can fetch all lazy-loaded modules
                    return _this.match(e.urlTree);
                }
                if (e instanceof NoMatch) {
                    throw _this.noMatchError(e);
                }
                throw e;
            }));
        };
        ApplyRedirects.prototype.match = function (tree) {
            var _this = this;
            var expanded$ = this.expandSegmentGroup(this.ngModule, this.config, tree.root, PRIMARY_OUTLET);
            var mapped$ = expanded$.pipe(operators.map(function (rootSegmentGroup) {
                return _this.createUrlTree(rootSegmentGroup, tree.queryParams, tree.fragment);
            }));
            return mapped$.pipe(operators.catchError(function (e) {
                if (e instanceof NoMatch) {
                    throw _this.noMatchError(e);
                }
                throw e;
            }));
        };
        ApplyRedirects.prototype.noMatchError = function (e) {
            return new Error("Cannot match any routes. URL Segment: '" + e.segmentGroup + "'");
        };
        ApplyRedirects.prototype.createUrlTree = function (rootCandidate, queryParams, fragment) {
            var _a;
            var root = rootCandidate.segments.length > 0 ?
                new UrlSegmentGroup([], (_a = {}, _a[PRIMARY_OUTLET] = rootCandidate, _a)) :
                rootCandidate;
            return new UrlTree(root, queryParams, fragment);
        };
        ApplyRedirects.prototype.expandSegmentGroup = function (ngModule, routes, segmentGroup, outlet) {
            if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
                return this.expandChildren(ngModule, routes, segmentGroup)
                    .pipe(operators.map(function (children) { return new UrlSegmentGroup([], children); }));
            }
            return this.expandSegment(ngModule, segmentGroup, routes, segmentGroup.segments, outlet, true);
        };
        // Recursively expand segment groups for all the child outlets
        ApplyRedirects.prototype.expandChildren = function (ngModule, routes, segmentGroup) {
            var _this = this;
            return waitForMap(segmentGroup.children, function (childOutlet, child) { return _this.expandSegmentGroup(ngModule, routes, child, childOutlet); });
        };
        ApplyRedirects.prototype.expandSegment = function (ngModule, segmentGroup, routes, segments, outlet, allowRedirects) {
            var _this = this;
            return rxjs.of.apply(void 0, __spread(routes)).pipe(operators.map(function (r) {
                var expanded$ = _this.expandSegmentAgainstRoute(ngModule, segmentGroup, routes, r, segments, outlet, allowRedirects);
                return expanded$.pipe(operators.catchError(function (e) {
                    if (e instanceof NoMatch) {
                        // TODO(i): this return type doesn't match the declared Observable<UrlSegmentGroup> -
                        // talk to Jason
                        return rxjs.of(null);
                    }
                    throw e;
                }));
            }), operators.concatAll(), operators.first(function (s) { return !!s; }), operators.catchError(function (e, _) {
                if (e instanceof rxjs.EmptyError || e.name === 'EmptyError') {
                    if (_this.noLeftoversInUrl(segmentGroup, segments, outlet)) {
                        return rxjs.of(new UrlSegmentGroup([], {}));
                    }
                    throw new NoMatch(segmentGroup);
                }
                throw e;
            }));
        };
        ApplyRedirects.prototype.noLeftoversInUrl = function (segmentGroup, segments, outlet) {
            return segments.length === 0 && !segmentGroup.children[outlet];
        };
        ApplyRedirects.prototype.expandSegmentAgainstRoute = function (ngModule, segmentGroup, routes, route, paths, outlet, allowRedirects) {
            if (getOutlet(route) !== outlet) {
                return noMatch(segmentGroup);
            }
            if (route.redirectTo === undefined) {
                return this.matchSegmentAgainstRoute(ngModule, segmentGroup, route, paths);
            }
            if (allowRedirects && this.allowRedirects) {
                return this.expandSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, paths, outlet);
            }
            return noMatch(segmentGroup);
        };
        ApplyRedirects.prototype.expandSegmentAgainstRouteUsingRedirect = function (ngModule, segmentGroup, routes, route, segments, outlet) {
            if (route.path === '**') {
                return this.expandWildCardWithParamsAgainstRouteUsingRedirect(ngModule, routes, route, outlet);
            }
            return this.expandRegularSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, segments, outlet);
        };
        ApplyRedirects.prototype.expandWildCardWithParamsAgainstRouteUsingRedirect = function (ngModule, routes, route, outlet) {
            var _this = this;
            var newTree = this.applyRedirectCommands([], route.redirectTo, {});
            if (route.redirectTo.startsWith('/')) {
                return absoluteRedirect(newTree);
            }
            return this.lineralizeSegments(route, newTree).pipe(operators.mergeMap(function (newSegments) {
                var group = new UrlSegmentGroup(newSegments, {});
                return _this.expandSegment(ngModule, group, routes, newSegments, outlet, false);
            }));
        };
        ApplyRedirects.prototype.expandRegularSegmentAgainstRouteUsingRedirect = function (ngModule, segmentGroup, routes, route, segments, outlet) {
            var _this = this;
            var _a = match(segmentGroup, route, segments), matched = _a.matched, consumedSegments = _a.consumedSegments, lastChild = _a.lastChild, positionalParamSegments = _a.positionalParamSegments;
            if (!matched)
                return noMatch(segmentGroup);
            var newTree = this.applyRedirectCommands(consumedSegments, route.redirectTo, positionalParamSegments);
            if (route.redirectTo.startsWith('/')) {
                return absoluteRedirect(newTree);
            }
            return this.lineralizeSegments(route, newTree).pipe(operators.mergeMap(function (newSegments) {
                return _this.expandSegment(ngModule, segmentGroup, routes, newSegments.concat(segments.slice(lastChild)), outlet, false);
            }));
        };
        ApplyRedirects.prototype.matchSegmentAgainstRoute = function (ngModule, rawSegmentGroup, route, segments) {
            var _this = this;
            if (route.path === '**') {
                if (route.loadChildren) {
                    return this.configLoader.load(ngModule.injector, route)
                        .pipe(operators.map(function (cfg) {
                        route._loadedConfig = cfg;
                        return new UrlSegmentGroup(segments, {});
                    }));
                }
                return rxjs.of(new UrlSegmentGroup(segments, {}));
            }
            var _a = match(rawSegmentGroup, route, segments), matched = _a.matched, consumedSegments = _a.consumedSegments, lastChild = _a.lastChild;
            if (!matched)
                return noMatch(rawSegmentGroup);
            var rawSlicedSegments = segments.slice(lastChild);
            var childConfig$ = this.getChildConfig(ngModule, route, segments);
            return childConfig$.pipe(operators.mergeMap(function (routerConfig) {
                var childModule = routerConfig.module;
                var childConfig = routerConfig.routes;
                var _a = split(rawSegmentGroup, consumedSegments, rawSlicedSegments, childConfig), segmentGroup = _a.segmentGroup, slicedSegments = _a.slicedSegments;
                if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {
                    var expanded$_1 = _this.expandChildren(childModule, childConfig, segmentGroup);
                    return expanded$_1.pipe(operators.map(function (children) { return new UrlSegmentGroup(consumedSegments, children); }));
                }
                if (childConfig.length === 0 && slicedSegments.length === 0) {
                    return rxjs.of(new UrlSegmentGroup(consumedSegments, {}));
                }
                var expanded$ = _this.expandSegment(childModule, segmentGroup, childConfig, slicedSegments, PRIMARY_OUTLET, true);
                return expanded$.pipe(operators.map(function (cs) {
                    return new UrlSegmentGroup(consumedSegments.concat(cs.segments), cs.children);
                }));
            }));
        };
        ApplyRedirects.prototype.getChildConfig = function (ngModule, route, segments) {
            var _this = this;
            if (route.children) {
                // The children belong to the same module
                return rxjs.of(new LoadedRouterConfig(route.children, ngModule));
            }
            if (route.loadChildren) {
                // lazy children belong to the loaded module
                if (route._loadedConfig !== undefined) {
                    return rxjs.of(route._loadedConfig);
                }
                return runCanLoadGuard(ngModule.injector, route, segments)
                    .pipe(operators.mergeMap(function (shouldLoad) {
                    if (shouldLoad) {
                        return _this.configLoader.load(ngModule.injector, route)
                            .pipe(operators.map(function (cfg) {
                            route._loadedConfig = cfg;
                            return cfg;
                        }));
                    }
                    return canLoadFails(route);
                }));
            }
            return rxjs.of(new LoadedRouterConfig([], ngModule));
        };
        ApplyRedirects.prototype.lineralizeSegments = function (route, urlTree) {
            var res = [];
            var c = urlTree.root;
            while (true) {
                res = res.concat(c.segments);
                if (c.numberOfChildren === 0) {
                    return rxjs.of(res);
                }
                if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {
                    return namedOutletsRedirect(route.redirectTo);
                }
                c = c.children[PRIMARY_OUTLET];
            }
        };
        ApplyRedirects.prototype.applyRedirectCommands = function (segments, redirectTo, posParams) {
            return this.applyRedirectCreatreUrlTree(redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);
        };
        ApplyRedirects.prototype.applyRedirectCreatreUrlTree = function (redirectTo, urlTree, segments, posParams) {
            var newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);
            return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);
        };
        ApplyRedirects.prototype.createQueryParams = function (redirectToParams, actualParams) {
            var res = {};
            forEach(redirectToParams, function (v, k) {
                var copySourceValue = typeof v === 'string' && v.startsWith(':');
                if (copySourceValue) {
                    var sourceName = v.substring(1);
                    res[k] = actualParams[sourceName];
                }
                else {
                    res[k] = v;
                }
            });
            return res;
        };
        ApplyRedirects.prototype.createSegmentGroup = function (redirectTo, group, segments, posParams) {
            var _this = this;
            var updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);
            var children = {};
            forEach(group.children, function (child, name) {
                children[name] = _this.createSegmentGroup(redirectTo, child, segments, posParams);
            });
            return new UrlSegmentGroup(updatedSegments, children);
        };
        ApplyRedirects.prototype.createSegments = function (redirectTo, redirectToSegments, actualSegments, posParams) {
            var _this = this;
            return redirectToSegments.map(function (s) { return s.path.startsWith(':') ? _this.findPosParam(redirectTo, s, posParams) :
                _this.findOrReturn(s, actualSegments); });
        };
        ApplyRedirects.prototype.findPosParam = function (redirectTo, redirectToUrlSegment, posParams) {
            var pos = posParams[redirectToUrlSegment.path.substring(1)];
            if (!pos)
                throw new Error("Cannot redirect to '" + redirectTo + "'. Cannot find '" + redirectToUrlSegment.path + "'.");
            return pos;
        };
        ApplyRedirects.prototype.findOrReturn = function (redirectToUrlSegment, actualSegments) {
            var e_1, _a;
            var idx = 0;
            try {
                for (var actualSegments_1 = __values(actualSegments), actualSegments_1_1 = actualSegments_1.next(); !actualSegments_1_1.done; actualSegments_1_1 = actualSegments_1.next()) {
                    var s = actualSegments_1_1.value;
                    if (s.path === redirectToUrlSegment.path) {
                        actualSegments.splice(idx);
                        return s;
                    }
                    idx++;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (actualSegments_1_1 && !actualSegments_1_1.done && (_a = actualSegments_1.return)) _a.call(actualSegments_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return redirectToUrlSegment;
        };
        return ApplyRedirects;
    }());
    function runCanLoadGuard(moduleInjector, route, segments) {
        var canLoad = route.canLoad;
        if (!canLoad || canLoad.length === 0)
            return rxjs.of(true);
        var obs = rxjs.from(canLoad).pipe(operators.map(function (injectionToken) {
            var guard = moduleInjector.get(injectionToken);
            var guardVal;
            if (isCanLoad(guard)) {
                guardVal = guard.canLoad(route, segments);
            }
            else if (isFunction(guard)) {
                guardVal = guard(route, segments);
            }
            else {
                throw new Error('Invalid CanLoad guard');
            }
            return wrapIntoObservable(guardVal);
        }));
        return obs.pipe(operators.concatAll(), operators.every(function (result) { return result === true; }));
    }
    function match(segmentGroup, route, segments) {
        if (route.path === '') {
            if ((route.pathMatch === 'full') && (segmentGroup.hasChildren() || segments.length > 0)) {
                return { matched: false, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };
            }
            return { matched: true, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };
        }
        var matcher = route.matcher || defaultUrlMatcher;
        var res = matcher(segments, segmentGroup, route);
        if (!res) {
            return {
                matched: false,
                consumedSegments: [],
                lastChild: 0,
                positionalParamSegments: {},
            };
        }
        return {
            matched: true,
            consumedSegments: res.consumed,
            lastChild: res.consumed.length,
            positionalParamSegments: res.posParams,
        };
    }
    function split(segmentGroup, consumedSegments, slicedSegments, config) {
        if (slicedSegments.length > 0 &&
            containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, slicedSegments, config)) {
            var s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptySegments(config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));
            return { segmentGroup: mergeTrivialChildren(s), slicedSegments: [] };
        }
        if (slicedSegments.length === 0 &&
            containsEmptyPathRedirects(segmentGroup, slicedSegments, config)) {
            var s = new UrlSegmentGroup(segmentGroup.segments, addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));
            return { segmentGroup: mergeTrivialChildren(s), slicedSegments: slicedSegments };
        }
        return { segmentGroup: segmentGroup, slicedSegments: slicedSegments };
    }
    function mergeTrivialChildren(s) {
        if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {
            var c = s.children[PRIMARY_OUTLET];
            return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);
        }
        return s;
    }
    function addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {
        var e_2, _a;
        var res = {};
        try {
            for (var routes_1 = __values(routes), routes_1_1 = routes_1.next(); !routes_1_1.done; routes_1_1 = routes_1.next()) {
                var r = routes_1_1.value;
                if (isEmptyPathRedirect(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {
                    res[getOutlet(r)] = new UrlSegmentGroup([], {});
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (routes_1_1 && !routes_1_1.done && (_a = routes_1.return)) _a.call(routes_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return __assign$1({}, children, res);
    }
    function createChildrenForEmptySegments(routes, primarySegmentGroup) {
        var e_3, _a;
        var res = {};
        res[PRIMARY_OUTLET] = primarySegmentGroup;
        try {
            for (var routes_2 = __values(routes), routes_2_1 = routes_2.next(); !routes_2_1.done; routes_2_1 = routes_2.next()) {
                var r = routes_2_1.value;
                if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {
                    res[getOutlet(r)] = new UrlSegmentGroup([], {});
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (routes_2_1 && !routes_2_1.done && (_a = routes_2.return)) _a.call(routes_2);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return res;
    }
    function containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, segments, routes) {
        return routes.some(function (r) { return isEmptyPathRedirect(segmentGroup, segments, r) && getOutlet(r) !== PRIMARY_OUTLET; });
    }
    function containsEmptyPathRedirects(segmentGroup, segments, routes) {
        return routes.some(function (r) { return isEmptyPathRedirect(segmentGroup, segments, r); });
    }
    function isEmptyPathRedirect(segmentGroup, segments, r) {
        if ((segmentGroup.hasChildren() || segments.length > 0) && r.pathMatch === 'full') {
            return false;
        }
        return r.path === '' && r.redirectTo !== undefined;
    }
    function getOutlet(route) {
        return route.outlet || PRIMARY_OUTLET;
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function applyRedirects$1(moduleInjector, configLoader, urlSerializer, config) {
        return function (source) {
            return source.pipe(operators.switchMap(function (t) { return applyRedirects(moduleInjector, configLoader, urlSerializer, t.extractedUrl, config)
                .pipe(operators.map(function (urlAfterRedirects) { return (__assign$1({}, t, { urlAfterRedirects: urlAfterRedirects })); })); }));
        };
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var CanActivate = /** @class */ (function () {
        function CanActivate(path) {
            this.path = path;
            this.route = this.path[this.path.length - 1];
        }
        return CanActivate;
    }());
    var CanDeactivate = /** @class */ (function () {
        function CanDeactivate(component, route) {
            this.component = component;
            this.route = route;
        }
        return CanDeactivate;
    }());
    function getAllRouteGuards(future, curr, parentContexts) {
        var futureRoot = future._root;
        var currRoot = curr ? curr._root : null;
        return getChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);
    }
    function getCanActivateChild(p) {
        var canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;
        if (!canActivateChild || canActivateChild.length === 0)
            return null;
        return { node: p, guards: canActivateChild };
    }
    function getToken(token, snapshot, moduleInjector) {
        var config = getClosestLoadedConfig(snapshot);
        var injector = config ? config.module.injector : moduleInjector;
        return injector.get(token);
    }
    function getClosestLoadedConfig(snapshot) {
        if (!snapshot)
            return null;
        for (var s = snapshot.parent; s; s = s.parent) {
            var route = s.routeConfig;
            if (route && route._loadedConfig)
                return route._loadedConfig;
        }
        return null;
    }
    function getChildRouteGuards(futureNode, currNode, contexts, futurePath, checks) {
        if (checks === void 0) { checks = {
            canDeactivateChecks: [],
            canActivateChecks: []
        }; }
        var prevChildren = nodeChildrenAsMap(currNode);
        // Process the children of the future route
        futureNode.children.forEach(function (c) {
            getRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]), checks);
            delete prevChildren[c.value.outlet];
        });
        // Process any children left from the current route (not active for the future route)
        forEach(prevChildren, function (v, k) {
            return deactivateRouteAndItsChildren(v, contexts.getContext(k), checks);
        });
        return checks;
    }
    function getRouteGuards(futureNode, currNode, parentContexts, futurePath, checks) {
        if (checks === void 0) { checks = {
            canDeactivateChecks: [],
            canActivateChecks: []
        }; }
        var future = futureNode.value;
        var curr = currNode ? currNode.value : null;
        var context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;
        // reusing the node
        if (curr && future.routeConfig === curr.routeConfig) {
            var shouldRun = shouldRunGuardsAndResolvers(curr, future, future.routeConfig.runGuardsAndResolvers);
            if (shouldRun) {
                checks.canActivateChecks.push(new CanActivate(futurePath));
            }
            else {
                // we need to set the data
                future.data = curr.data;
                future._resolvedData = curr._resolvedData;
            }
            // If we have a component, we need to go through an outlet.
            if (future.component) {
                getChildRouteGuards(futureNode, currNode, context ? context.children : null, futurePath, checks);
                // if we have a componentless route, we recurse but keep the same outlet map.
            }
            else {
                getChildRouteGuards(futureNode, currNode, parentContexts, futurePath, checks);
            }
            if (shouldRun) {
                var component = context && context.outlet && context.outlet.component || null;
                checks.canDeactivateChecks.push(new CanDeactivate(component, curr));
            }
        }
        else {
            if (curr) {
                deactivateRouteAndItsChildren(currNode, context, checks);
            }
            checks.canActivateChecks.push(new CanActivate(futurePath));
            // If we have a component, we need to go through an outlet.
            if (future.component) {
                getChildRouteGuards(futureNode, null, context ? context.children : null, futurePath, checks);
                // if we have a componentless route, we recurse but keep the same outlet map.
            }
            else {
                getChildRouteGuards(futureNode, null, parentContexts, futurePath, checks);
            }
        }
        return checks;
    }
    function shouldRunGuardsAndResolvers(curr, future, mode) {
        if (typeof mode === 'function') {
            return mode(curr, future);
        }
        switch (mode) {
            case 'pathParamsChange':
                return !equalPath(curr.url, future.url);
            case 'pathParamsOrQueryParamsChange':
                return !equalPath(curr.url, future.url) ||
                    !shallowEqual(curr.queryParams, future.queryParams);
            case 'always':
                return true;
            case 'paramsOrQueryParamsChange':
                return !equalParamsAndUrlSegments(curr, future) ||
                    !shallowEqual(curr.queryParams, future.queryParams);
            case 'paramsChange':
            default:
                return !equalParamsAndUrlSegments(curr, future);
        }
    }
    function deactivateRouteAndItsChildren(route, context, checks) {
        var children = nodeChildrenAsMap(route);
        var r = route.value;
        forEach(children, function (node, childName) {
            if (!r.component) {
                deactivateRouteAndItsChildren(node, context, checks);
            }
            else if (context) {
                deactivateRouteAndItsChildren(node, context.children.getContext(childName), checks);
            }
            else {
                deactivateRouteAndItsChildren(node, null, checks);
            }
        });
        if (!r.component) {
            checks.canDeactivateChecks.push(new CanDeactivate(null, r));
        }
        else if (context && context.outlet && context.outlet.isActivated) {
            checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));
        }
        else {
            checks.canDeactivateChecks.push(new CanDeactivate(null, r));
        }
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var INITIAL_VALUE = Symbol('INITIAL_VALUE');
    function prioritizedGuardValue() {
        return operators.switchMap(function (obs) {
            return rxjs.combineLatest.apply(void 0, __spread(obs.map(function (o) { return o.pipe(operators.take(1), operators.startWith(INITIAL_VALUE)); }))).pipe(operators.scan(function (acc, list) {
                var isPending = false;
                return list.reduce(function (innerAcc, val, i) {
                    if (innerAcc !== INITIAL_VALUE)
                        return innerAcc;
                    // Toggle pending flag if any values haven't been set yet
                    if (val === INITIAL_VALUE)
                        isPending = true;
                    // Any other return values are only valid if we haven't yet hit a pending call.
                    // This guarantees that in the case of a guard at the bottom of the tree that
                    // returns a redirect, we will wait for the higher priority guard at the top to
                    // finish before performing the redirect.
                    if (!isPending) {
                        // Early return when we hit a `false` value as that should always cancel
                        // navigation
                        if (val === false)
                            return val;
                        if (i === list.length - 1 || isUrlTree(val)) {
                            return val;
                        }
                    }
                    return innerAcc;
                }, acc);
            }, INITIAL_VALUE), operators.filter(function (item) { return item !== INITIAL_VALUE; }), operators.map(function (item) { return isUrlTree(item) ? item : item === true; }), //
            operators.take(1));
        });
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function checkGuards(moduleInjector, forwardEvent) {
        return function (source) {
            return source.pipe(operators.mergeMap(function (t) {
                var targetSnapshot = t.targetSnapshot, currentSnapshot = t.currentSnapshot, _a = t.guards, canActivateChecks = _a.canActivateChecks, canDeactivateChecks = _a.canDeactivateChecks;
                if (canDeactivateChecks.length === 0 && canActivateChecks.length === 0) {
                    return rxjs.of(__assign$1({}, t, { guardsResult: true }));
                }
                return runCanDeactivateChecks(canDeactivateChecks, targetSnapshot, currentSnapshot, moduleInjector)
                    .pipe(operators.mergeMap(function (canDeactivate) {
                    return canDeactivate && isBoolean(canDeactivate) ?
                        runCanActivateChecks(targetSnapshot, canActivateChecks, moduleInjector, forwardEvent) :
                        rxjs.of(canDeactivate);
                }), operators.map(function (guardsResult) { return (__assign$1({}, t, { guardsResult: guardsResult })); }));
            }));
        };
    }
    function runCanDeactivateChecks(checks, futureRSS, currRSS, moduleInjector) {
        return rxjs.from(checks).pipe(operators.mergeMap(function (check) {
            return runCanDeactivate(check.component, check.route, currRSS, futureRSS, moduleInjector);
        }), operators.first(function (result) { return result !== true; }, true));
    }
    function runCanActivateChecks(futureSnapshot, checks, moduleInjector, forwardEvent) {
        return rxjs.from(checks).pipe(operators.concatMap(function (check) {
            return rxjs.from([
                fireChildActivationStart(check.route.parent, forwardEvent),
                fireActivationStart(check.route, forwardEvent),
                runCanActivateChild(futureSnapshot, check.path, moduleInjector),
                runCanActivate(futureSnapshot, check.route, moduleInjector)
            ])
                .pipe(operators.concatAll(), operators.first(function (result) {
                return result !== true;
            }, true));
        }), operators.first(function (result) { return result !== true; }, true));
    }
    /**
       * This should fire off `ActivationStart` events for each route being activated at this
       * level.
       * In other words, if you're activating `a` and `b` below, `path` will contain the
       * `ActivatedRouteSnapshot`s for both and we will fire `ActivationStart` for both. Always
       * return
       * `true` so checks continue to run.
       */
    function fireActivationStart(snapshot, forwardEvent) {
        if (snapshot !== null && forwardEvent) {
            forwardEvent(new ActivationStart(snapshot));
        }
        return rxjs.of(true);
    }
    /**
       * This should fire off `ChildActivationStart` events for each route being activated at this
       * level.
       * In other words, if you're activating `a` and `b` below, `path` will contain the
       * `ActivatedRouteSnapshot`s for both and we will fire `ChildActivationStart` for both. Always
       * return
       * `true` so checks continue to run.
       */
    function fireChildActivationStart(snapshot, forwardEvent) {
        if (snapshot !== null && forwardEvent) {
            forwardEvent(new ChildActivationStart(snapshot));
        }
        return rxjs.of(true);
    }
    function runCanActivate(futureRSS, futureARS, moduleInjector) {
        var canActivate = futureARS.routeConfig ? futureARS.routeConfig.canActivate : null;
        if (!canActivate || canActivate.length === 0)
            return rxjs.of(true);
        var canActivateObservables = canActivate.map(function (c) {
            return rxjs.defer(function () {
                var guard = getToken(c, futureARS, moduleInjector);
                var observable;
                if (isCanActivate(guard)) {
                    observable = wrapIntoObservable(guard.canActivate(futureARS, futureRSS));
                }
                else if (isFunction(guard)) {
                    observable = wrapIntoObservable(guard(futureARS, futureRSS));
                }
                else {
                    throw new Error('Invalid CanActivate guard');
                }
                return observable.pipe(operators.first());
            });
        });
        return rxjs.of(canActivateObservables).pipe(prioritizedGuardValue());
    }
    function runCanActivateChild(futureRSS, path, moduleInjector) {
        var futureARS = path[path.length - 1];
        var canActivateChildGuards = path.slice(0, path.length - 1)
            .reverse()
            .map(function (p) { return getCanActivateChild(p); })
            .filter(function (_) { return _ !== null; });
        var canActivateChildGuardsMapped = canActivateChildGuards.map(function (d) {
            return rxjs.defer(function () {
                var guardsMapped = d.guards.map(function (c) {
                    var guard = getToken(c, d.node, moduleInjector);
                    var observable;
                    if (isCanActivateChild(guard)) {
                        observable = wrapIntoObservable(guard.canActivateChild(futureARS, futureRSS));
                    }
                    else if (isFunction(guard)) {
                        observable = wrapIntoObservable(guard(futureARS, futureRSS));
                    }
                    else {
                        throw new Error('Invalid CanActivateChild guard');
                    }
                    return observable.pipe(operators.first());
                });
                return rxjs.of(guardsMapped).pipe(prioritizedGuardValue());
            });
        });
        return rxjs.of(canActivateChildGuardsMapped).pipe(prioritizedGuardValue());
    }
    function runCanDeactivate(component, currARS, currRSS, futureRSS, moduleInjector) {
        var canDeactivate = currARS && currARS.routeConfig ? currARS.routeConfig.canDeactivate : null;
        if (!canDeactivate || canDeactivate.length === 0)
            return rxjs.of(true);
        var canDeactivateObservables = canDeactivate.map(function (c) {
            var guard = getToken(c, currARS, moduleInjector);
            var observable;
            if (isCanDeactivate(guard)) {
                observable =
                    wrapIntoObservable(guard.canDeactivate(component, currARS, currRSS, futureRSS));
            }
            else if (isFunction(guard)) {
                observable = wrapIntoObservable(guard(component, currARS, currRSS, futureRSS));
            }
            else {
                throw new Error('Invalid CanDeactivate guard');
            }
            return observable.pipe(operators.first());
        });
        return rxjs.of(canDeactivateObservables).pipe(prioritizedGuardValue());
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var NoMatch$1 = /** @class */ (function () {
        function NoMatch() {
        }
        return NoMatch;
    }());
    function recognize(rootComponentType, config, urlTree, url, paramsInheritanceStrategy, relativeLinkResolution) {
        if (paramsInheritanceStrategy === void 0) { paramsInheritanceStrategy = 'emptyOnly'; }
        if (relativeLinkResolution === void 0) { relativeLinkResolution = 'legacy'; }
        return new Recognizer(rootComponentType, config, urlTree, url, paramsInheritanceStrategy, relativeLinkResolution)
            .recognize();
    }
    var Recognizer = /** @class */ (function () {
        function Recognizer(rootComponentType, config, urlTree, url, paramsInheritanceStrategy, relativeLinkResolution) {
            this.rootComponentType = rootComponentType;
            this.config = config;
            this.urlTree = urlTree;
            this.url = url;
            this.paramsInheritanceStrategy = paramsInheritanceStrategy;
            this.relativeLinkResolution = relativeLinkResolution;
        }
        Recognizer.prototype.recognize = function () {
            try {
                var rootSegmentGroup = split$1(this.urlTree.root, [], [], this.config, this.relativeLinkResolution).segmentGroup;
                var children = this.processSegmentGroup(this.config, rootSegmentGroup, PRIMARY_OUTLET);
                var root = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze(__assign$1({}, this.urlTree.queryParams)), this.urlTree.fragment, {}, PRIMARY_OUTLET, this.rootComponentType, null, this.urlTree.root, -1, {});
                var rootNode = new TreeNode(root, children);
                var routeState = new RouterStateSnapshot(this.url, rootNode);
                this.inheritParamsAndData(routeState._root);
                return rxjs.of(routeState);
            }
            catch (e) {
                return new rxjs.Observable(function (obs) { return obs.error(e); });
            }
        };
        Recognizer.prototype.inheritParamsAndData = function (routeNode) {
            var _this = this;
            var route = routeNode.value;
            var i = inheritedParamsDataResolve(route, this.paramsInheritanceStrategy);
            route.params = Object.freeze(i.params);
            route.data = Object.freeze(i.data);
            routeNode.children.forEach(function (n) { return _this.inheritParamsAndData(n); });
        };
        Recognizer.prototype.processSegmentGroup = function (config, segmentGroup, outlet) {
            if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
                return this.processChildren(config, segmentGroup);
            }
            return this.processSegment(config, segmentGroup, segmentGroup.segments, outlet);
        };
        Recognizer.prototype.processChildren = function (config, segmentGroup) {
            var _this = this;
            var children = mapChildrenIntoArray(segmentGroup, function (child, childOutlet) { return _this.processSegmentGroup(config, child, childOutlet); });
            checkOutletNameUniqueness(children);
            sortActivatedRouteSnapshots(children);
            return children;
        };
        Recognizer.prototype.processSegment = function (config, segmentGroup, segments, outlet) {
            var e_1, _a;
            try {
                for (var config_1 = __values(config), config_1_1 = config_1.next(); !config_1_1.done; config_1_1 = config_1.next()) {
                    var r = config_1_1.value;
                    try {
                        return this.processSegmentAgainstRoute(r, segmentGroup, segments, outlet);
                    }
                    catch (e) {
                        if (!(e instanceof NoMatch$1))
                            throw e;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (config_1_1 && !config_1_1.done && (_a = config_1.return)) _a.call(config_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (this.noLeftoversInUrl(segmentGroup, segments, outlet)) {
                return [];
            }
            throw new NoMatch$1();
        };
        Recognizer.prototype.noLeftoversInUrl = function (segmentGroup, segments, outlet) {
            return segments.length === 0 && !segmentGroup.children[outlet];
        };
        Recognizer.prototype.processSegmentAgainstRoute = function (route, rawSegment, segments, outlet) {
            if (route.redirectTo)
                throw new NoMatch$1();
            if ((route.outlet || PRIMARY_OUTLET) !== outlet)
                throw new NoMatch$1();
            var snapshot;
            var consumedSegments = [];
            var rawSlicedSegments = [];
            if (route.path === '**') {
                var params = segments.length > 0 ? last(segments).parameters : {};
                snapshot = new ActivatedRouteSnapshot(segments, params, Object.freeze(__assign$1({}, this.urlTree.queryParams)), this.urlTree.fragment, getData(route), outlet, route.component, route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + segments.length, getResolve(route));
            }
            else {
                var result = match$1(rawSegment, route, segments);
                consumedSegments = result.consumedSegments;
                rawSlicedSegments = segments.slice(result.lastChild);
                snapshot = new ActivatedRouteSnapshot(consumedSegments, result.parameters, Object.freeze(__assign$1({}, this.urlTree.queryParams)), this.urlTree.fragment, getData(route), outlet, route.component, route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + consumedSegments.length, getResolve(route));
            }
            var childConfig = getChildConfig(route);
            var _a = split$1(rawSegment, consumedSegments, rawSlicedSegments, childConfig, this.relativeLinkResolution), segmentGroup = _a.segmentGroup, slicedSegments = _a.slicedSegments;
            if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {
                var children_1 = this.processChildren(childConfig, segmentGroup);
                return [new TreeNode(snapshot, children_1)];
            }
            if (childConfig.length === 0 && slicedSegments.length === 0) {
                return [new TreeNode(snapshot, [])];
            }
            var children = this.processSegment(childConfig, segmentGroup, slicedSegments, PRIMARY_OUTLET);
            return [new TreeNode(snapshot, children)];
        };
        return Recognizer;
    }());
    function sortActivatedRouteSnapshots(nodes) {
        nodes.sort(function (a, b) {
            if (a.value.outlet === PRIMARY_OUTLET)
                return -1;
            if (b.value.outlet === PRIMARY_OUTLET)
                return 1;
            return a.value.outlet.localeCompare(b.value.outlet);
        });
    }
    function getChildConfig(route) {
        if (route.children) {
            return route.children;
        }
        if (route.loadChildren) {
            return route._loadedConfig.routes;
        }
        return [];
    }
    function match$1(segmentGroup, route, segments) {
        if (route.path === '') {
            if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {
                throw new NoMatch$1();
            }
            return { consumedSegments: [], lastChild: 0, parameters: {} };
        }
        var matcher = route.matcher || defaultUrlMatcher;
        var res = matcher(segments, segmentGroup, route);
        if (!res)
            throw new NoMatch$1();
        var posParams = {};
        forEach(res.posParams, function (v, k) { posParams[k] = v.path; });
        var parameters = res.consumed.length > 0 ? __assign$1({}, posParams, res.consumed[res.consumed.length - 1].parameters) :
            posParams;
        return { consumedSegments: res.consumed, lastChild: res.consumed.length, parameters: parameters };
    }
    function checkOutletNameUniqueness(nodes) {
        var names = {};
        nodes.forEach(function (n) {
            var routeWithSameOutletName = names[n.value.outlet];
            if (routeWithSameOutletName) {
                var p = routeWithSameOutletName.url.map(function (s) { return s.toString(); }).join('/');
                var c = n.value.url.map(function (s) { return s.toString(); }).join('/');
                throw new Error("Two segments cannot have the same outlet name: '" + p + "' and '" + c + "'.");
            }
            names[n.value.outlet] = n.value;
        });
    }
    function getSourceSegmentGroup(segmentGroup) {
        var s = segmentGroup;
        while (s._sourceSegment) {
            s = s._sourceSegment;
        }
        return s;
    }
    function getPathIndexShift(segmentGroup) {
        var s = segmentGroup;
        var res = (s._segmentIndexShift ? s._segmentIndexShift : 0);
        while (s._sourceSegment) {
            s = s._sourceSegment;
            res += (s._segmentIndexShift ? s._segmentIndexShift : 0);
        }
        return res - 1;
    }
    function split$1(segmentGroup, consumedSegments, slicedSegments, config, relativeLinkResolution) {
        if (slicedSegments.length > 0 &&
            containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {
            var s_1 = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(segmentGroup, consumedSegments, config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));
            s_1._sourceSegment = segmentGroup;
            s_1._segmentIndexShift = consumedSegments.length;
            return { segmentGroup: s_1, slicedSegments: [] };
        }
        if (slicedSegments.length === 0 &&
            containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {
            var s_2 = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, consumedSegments, slicedSegments, config, segmentGroup.children, relativeLinkResolution));
            s_2._sourceSegment = segmentGroup;
            s_2._segmentIndexShift = consumedSegments.length;
            return { segmentGroup: s_2, slicedSegments: slicedSegments };
        }
        var s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);
        s._sourceSegment = segmentGroup;
        s._segmentIndexShift = consumedSegments.length;
        return { segmentGroup: s, slicedSegments: slicedSegments };
    }
    function addEmptyPathsToChildrenIfNeeded(segmentGroup, consumedSegments, slicedSegments, routes, children, relativeLinkResolution) {
        var e_2, _a;
        var res = {};
        try {
            for (var routes_1 = __values(routes), routes_1_1 = routes_1.next(); !routes_1_1.done; routes_1_1 = routes_1.next()) {
                var r = routes_1_1.value;
                if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet$1(r)]) {
                    var s = new UrlSegmentGroup([], {});
                    s._sourceSegment = segmentGroup;
                    if (relativeLinkResolution === 'legacy') {
                        s._segmentIndexShift = segmentGroup.segments.length;
                    }
                    else {
                        s._segmentIndexShift = consumedSegments.length;
                    }
                    res[getOutlet$1(r)] = s;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (routes_1_1 && !routes_1_1.done && (_a = routes_1.return)) _a.call(routes_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return __assign$1({}, children, res);
    }
    function createChildrenForEmptyPaths(segmentGroup, consumedSegments, routes, primarySegment) {
        var e_3, _a;
        var res = {};
        res[PRIMARY_OUTLET] = primarySegment;
        primarySegment._sourceSegment = segmentGroup;
        primarySegment._segmentIndexShift = consumedSegments.length;
        try {
            for (var routes_2 = __values(routes), routes_2_1 = routes_2.next(); !routes_2_1.done; routes_2_1 = routes_2.next()) {
                var r = routes_2_1.value;
                if (r.path === '' && getOutlet$1(r) !== PRIMARY_OUTLET) {
                    var s = new UrlSegmentGroup([], {});
                    s._sourceSegment = segmentGroup;
                    s._segmentIndexShift = consumedSegments.length;
                    res[getOutlet$1(r)] = s;
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (routes_2_1 && !routes_2_1.done && (_a = routes_2.return)) _a.call(routes_2);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return res;
    }
    function containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes) {
        return routes.some(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet$1(r) !== PRIMARY_OUTLET; });
    }
    function containsEmptyPathMatches(segmentGroup, slicedSegments, routes) {
        return routes.some(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r); });
    }
    function emptyPathMatch(segmentGroup, slicedSegments, r) {
        if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full') {
            return false;
        }
        return r.path === '' && r.redirectTo === undefined;
    }
    function getOutlet$1(route) {
        return route.outlet || PRIMARY_OUTLET;
    }
    function getData(route) {
        return route.data || {};
    }
    function getResolve(route) {
        return route.resolve || {};
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function recognize$1(rootComponentType, config, serializer, paramsInheritanceStrategy, relativeLinkResolution) {
        return function (source) {
            return source.pipe(operators.mergeMap(function (t) { return recognize(rootComponentType, config, t.urlAfterRedirects, serializer(t.urlAfterRedirects), paramsInheritanceStrategy, relativeLinkResolution)
                .pipe(operators.map(function (targetSnapshot) { return (__assign$1({}, t, { targetSnapshot: targetSnapshot })); })); }));
        };
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function resolveData(paramsInheritanceStrategy, moduleInjector) {
        return function (source) {
            return source.pipe(operators.mergeMap(function (t) {
                var targetSnapshot = t.targetSnapshot, canActivateChecks = t.guards.canActivateChecks;
                if (!canActivateChecks.length) {
                    return rxjs.of(t);
                }
                return rxjs.from(canActivateChecks)
                    .pipe(operators.concatMap(function (check) { return runResolve(check.route, targetSnapshot, paramsInheritanceStrategy, moduleInjector); }), operators.reduce(function (_, __) { return _; }), operators.map(function (_) { return t; }));
            }));
        };
    }
    function runResolve(futureARS, futureRSS, paramsInheritanceStrategy, moduleInjector) {
        var resolve = futureARS._resolve;
        return resolveNode(resolve, futureARS, futureRSS, moduleInjector)
            .pipe(operators.map(function (resolvedData) {
            futureARS._resolvedData = resolvedData;
            futureARS.data = __assign$1({}, futureARS.data, inheritedParamsDataResolve(futureARS, paramsInheritanceStrategy).resolve);
            return null;
        }));
    }
    function resolveNode(resolve, futureARS, futureRSS, moduleInjector) {
        var keys = Object.keys(resolve);
        if (keys.length === 0) {
            return rxjs.of({});
        }
        if (keys.length === 1) {
            var key_1 = keys[0];
            return getResolver(resolve[key_1], futureARS, futureRSS, moduleInjector)
                .pipe(operators.map(function (value) {
                var _a;
                return _a = {}, _a[key_1] = value, _a;
            }));
        }
        var data = {};
        var runningResolvers$ = rxjs.from(keys).pipe(operators.mergeMap(function (key) {
            return getResolver(resolve[key], futureARS, futureRSS, moduleInjector)
                .pipe(operators.map(function (value) {
                data[key] = value;
                return value;
            }));
        }));
        return runningResolvers$.pipe(operators.last(), operators.map(function () { return data; }));
    }
    function getResolver(injectionToken, futureARS, futureRSS, moduleInjector) {
        var resolver = getToken(injectionToken, futureARS, moduleInjector);
        return resolver.resolve ? wrapIntoObservable(resolver.resolve(futureARS, futureRSS)) :
            wrapIntoObservable(resolver(futureARS, futureRSS));
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Perform a side effect through a switchMap for every emission on the source Observable,
     * but return an Observable that is identical to the source. It's essentially the same as
     * the `tap` operator, but if the side effectful `next` function returns an ObservableInput,
     * it will wait before continuing with the original value.
     */
    function switchTap(next) {
        return function (source) {
            return source.pipe(operators.switchMap(function (v) {
                var nextResult = next(v);
                if (nextResult) {
                    return rxjs.from(nextResult).pipe(operators.map(function () { return v; }));
                }
                return rxjs.from([v]);
            }));
        };
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @description
     *
     * Provides a way to customize when activated routes get reused.
     *
     * @publicApi
     */
    var RouteReuseStrategy = /** @class */ (function () {
        function RouteReuseStrategy() {
        }
        return RouteReuseStrategy;
    }());
    /**
     * Does not detach any subtrees. Reuses routes as long as their route config is the same.
     */
    var DefaultRouteReuseStrategy = /** @class */ (function () {
        function DefaultRouteReuseStrategy() {
        }
        DefaultRouteReuseStrategy.prototype.shouldDetach = function (route) { return false; };
        DefaultRouteReuseStrategy.prototype.store = function (route, detachedTree) { };
        DefaultRouteReuseStrategy.prototype.shouldAttach = function (route) { return false; };
        DefaultRouteReuseStrategy.prototype.retrieve = function (route) { return null; };
        DefaultRouteReuseStrategy.prototype.shouldReuseRoute = function (future, curr) {
            return future.routeConfig === curr.routeConfig;
        };
        return DefaultRouteReuseStrategy;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @docsNotRequired
     * @publicApi
     */
    var ROUTES = new core.InjectionToken('ROUTES');
    var RouterConfigLoader = /** @class */ (function () {
        function RouterConfigLoader(loader, compiler, onLoadStartListener, onLoadEndListener) {
            this.loader = loader;
            this.compiler = compiler;
            this.onLoadStartListener = onLoadStartListener;
            this.onLoadEndListener = onLoadEndListener;
        }
        RouterConfigLoader.prototype.load = function (parentInjector, route) {
            var _this = this;
            if (this.onLoadStartListener) {
                this.onLoadStartListener(route);
            }
            var moduleFactory$ = this.loadModuleFactory(route.loadChildren);
            return moduleFactory$.pipe(operators.map(function (factory) {
                if (_this.onLoadEndListener) {
                    _this.onLoadEndListener(route);
                }
                var module = factory.create(parentInjector);
                return new LoadedRouterConfig(flatten(module.injector.get(ROUTES)).map(standardizeConfig), module);
            }));
        };
        RouterConfigLoader.prototype.loadModuleFactory = function (loadChildren) {
            var _this = this;
            if (typeof loadChildren === 'string') {
                return rxjs.from(this.loader.load(loadChildren));
            }
            else {
                return wrapIntoObservable(loadChildren()).pipe(operators.mergeMap(function (t) {
                    if (t instanceof core.NgModuleFactory) {
                        return rxjs.of(t);
                    }
                    else {
                        return rxjs.from(_this.compiler.compileModuleAsync(t));
                    }
                }));
            }
        };
        return RouterConfigLoader;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @description
     *
     * Provides a way to migrate AngularJS applications to Angular.
     *
     * @publicApi
     */
    var UrlHandlingStrategy = /** @class */ (function () {
        function UrlHandlingStrategy() {
        }
        return UrlHandlingStrategy;
    }());
    /**
     * @publicApi
     */
    var DefaultUrlHandlingStrategy = /** @class */ (function () {
        function DefaultUrlHandlingStrategy() {
        }
        DefaultUrlHandlingStrategy.prototype.shouldProcessUrl = function (url) { return true; };
        DefaultUrlHandlingStrategy.prototype.extract = function (url) { return url; };
        DefaultUrlHandlingStrategy.prototype.merge = function (newUrlPart, wholeUrl) { return newUrlPart; };
        return DefaultUrlHandlingStrategy;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function defaultErrorHandler(error) {
        throw error;
    }
    function defaultMalformedUriErrorHandler(error, urlSerializer, url) {
        return urlSerializer.parse('/');
    }
    /**
     * @internal
     */
    function defaultRouterHook(snapshot, runExtras) {
        return rxjs.of(null);
    }
    /**
     * @description
     *
     * An NgModule that provides navigation and URL manipulation capabilities.
     *
     * @see `Route`.
     * @see [Routing and Navigation Guide](guide/router).
     *
     * @ngModule RouterModule
     *
     * @publicApi
     */
    var Router = /** @class */ (function () {
        /**
         * Creates the router service.
         */
        // TODO: vsavkin make internal after the final is out.
        function Router(rootComponentType, urlSerializer, rootContexts, location, injector, loader, compiler, config) {
            var _this = this;
            this.rootComponentType = rootComponentType;
            this.urlSerializer = urlSerializer;
            this.rootContexts = rootContexts;
            this.location = location;
            this.config = config;
            this.lastSuccessfulNavigation = null;
            this.currentNavigation = null;
            this.navigationId = 0;
            this.isNgZoneEnabled = false;
            /**
             * An event stream for routing events in this NgModule.
             */
            this.events = new rxjs.Subject();
            /**
             * A handler for navigation errors in this NgModule.
             */
            this.errorHandler = defaultErrorHandler;
            /**
             * Malformed uri error handler is invoked when `Router.parseUrl(url)` throws an
             * error due to containing an invalid character. The most common case would be a `%` sign
             * that's not encoded and is not part of a percent encoded sequence.
             */
            this.malformedUriErrorHandler = defaultMalformedUriErrorHandler;
            /**
             * True if at least one navigation event has occurred,
             * false otherwise.
             */
            this.navigated = false;
            this.lastSuccessfulId = -1;
            /**
             * Hooks that enable you to pause navigation,
             * either before or after the preactivation phase.
             * Used by `RouterModule`.
             *
             * @internal
             */
            this.hooks = {
                beforePreactivation: defaultRouterHook,
                afterPreactivation: defaultRouterHook
            };
            /**
             * Extracts and merges URLs. Used for AngularJS to Angular migrations.
             */
            this.urlHandlingStrategy = new DefaultUrlHandlingStrategy();
            /**
             * The strategy for re-using routes.
             */
            this.routeReuseStrategy = new DefaultRouteReuseStrategy();
            /**
             * How to handle a navigation request to the current URL. One of:
             * - `'ignore'` :  The router ignores the request.
             * - `'reload'` : The router reloads the URL. Use to implement a "refresh" feature.
             */
            this.onSameUrlNavigation = 'ignore';
            /**
             * How to merge parameters, data, and resolved data from parent to child
             * routes. One of:
             *
             * - `'emptyOnly'` : Inherit parent parameters, data, and resolved data
             * for path-less or component-less routes.
             * - `'always'` : Inherit parent parameters, data, and resolved data
             * for all child routes.
             */
            this.paramsInheritanceStrategy = 'emptyOnly';
            /**
             * Defines when the router updates the browser URL. The default behavior is to update after
             * successful navigation. However, some applications may prefer a mode where the URL gets
             * updated at the beginning of navigation. The most common use case would be updating the
             * URL early so if navigation fails, you can show an error message with the URL that failed.
             * Available options are:
             *
             * - `'deferred'`, the default, updates the browser URL after navigation has finished.
             * - `'eager'`, updates browser URL at the beginning of navigation.
             */
            this.urlUpdateStrategy = 'deferred';
            /**
             * See {@link RouterModule} for more information.
             */
            this.relativeLinkResolution = 'legacy';
            var onLoadStart = function (r) { return _this.triggerEvent(new RouteConfigLoadStart(r)); };
            var onLoadEnd = function (r) { return _this.triggerEvent(new RouteConfigLoadEnd(r)); };
            this.ngModule = injector.get(core.NgModuleRef);
            this.console = injector.get(core.ɵConsole);
            var ngZone = injector.get(core.NgZone);
            this.isNgZoneEnabled = ngZone instanceof core.NgZone;
            this.resetConfig(config);
            this.currentUrlTree = createEmptyUrlTree();
            this.rawUrlTree = this.currentUrlTree;
            this.browserUrlTree = this.currentUrlTree;
            this.configLoader = new RouterConfigLoader(loader, compiler, onLoadStart, onLoadEnd);
            this.routerState = createEmptyState(this.currentUrlTree, this.rootComponentType);
            this.transitions = new rxjs.BehaviorSubject({
                id: 0,
                currentUrlTree: this.currentUrlTree,
                currentRawUrl: this.currentUrlTree,
                extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree),
                urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree),
                rawUrl: this.currentUrlTree,
                extras: {},
                resolve: null,
                reject: null,
                promise: Promise.resolve(true),
                source: 'imperative',
                restoredState: null,
                currentSnapshot: this.routerState.snapshot,
                targetSnapshot: null,
                currentRouterState: this.routerState,
                targetRouterState: null,
                guards: { canActivateChecks: [], canDeactivateChecks: [] },
                guardsResult: null,
            });
            this.navigations = this.setupNavigations(this.transitions);
            this.processNavigations();
        }
        Router.prototype.setupNavigations = function (transitions) {
            var _this = this;
            var eventsSubject = this.events;
            return transitions.pipe(operators.filter(function (t) { return t.id !== 0; }), 
            // Extract URL
            operators.map(function (t) { return (__assign$1({}, t, { extractedUrl: _this.urlHandlingStrategy.extract(t.rawUrl) })); }), 
            // Using switchMap so we cancel executing navigations when a new one comes in
            operators.switchMap(function (t) {
                var completed = false;
                var errored = false;
                return rxjs.of(t).pipe(
                // Store the Navigation object
                operators.tap(function (t) {
                    _this.currentNavigation = {
                        id: t.id,
                        initialUrl: t.currentRawUrl,
                        extractedUrl: t.extractedUrl,
                        trigger: t.source,
                        extras: t.extras,
                        previousNavigation: _this.lastSuccessfulNavigation ? __assign$1({}, _this.lastSuccessfulNavigation, { previousNavigation: null }) :
                            null
                    };
                }), operators.switchMap(function (t) {
                    var urlTransition = !_this.navigated || t.extractedUrl.toString() !== _this.browserUrlTree.toString();
                    var processCurrentUrl = (_this.onSameUrlNavigation === 'reload' ? true : urlTransition) &&
                        _this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl);
                    if (processCurrentUrl) {
                        return rxjs.of(t).pipe(
                        // Fire NavigationStart event
                        operators.switchMap(function (t) {
                            var transition = _this.transitions.getValue();
                            eventsSubject.next(new NavigationStart(t.id, _this.serializeUrl(t.extractedUrl), t.source, t.restoredState));
                            if (transition !== _this.transitions.getValue()) {
                                return rxjs.EMPTY;
                            }
                            return [t];
                        }), 
                        // This delay is required to match old behavior that forced navigation to
                        // always be async
                        operators.switchMap(function (t) { return Promise.resolve(t); }), 
                        // ApplyRedirects
                        applyRedirects$1(_this.ngModule.injector, _this.configLoader, _this.urlSerializer, _this.config), 
                        // Update the currentNavigation
                        operators.tap(function (t) {
                            _this.currentNavigation = __assign$1({}, _this.currentNavigation, { finalUrl: t.urlAfterRedirects });
                        }), 
                        // Recognize
                        recognize$1(_this.rootComponentType, _this.config, function (url) { return _this.serializeUrl(url); }, _this.paramsInheritanceStrategy, _this.relativeLinkResolution), 
                        // Update URL if in `eager` update mode
                        operators.tap(function (t) {
                            if (_this.urlUpdateStrategy === 'eager') {
                                if (!t.extras.skipLocationChange) {
                                    _this.setBrowserUrl(t.urlAfterRedirects, !!t.extras.replaceUrl, t.id, t.extras.state);
                                }
                                _this.browserUrlTree = t.urlAfterRedirects;
                            }
                        }), 
                        // Fire RoutesRecognized
                        operators.tap(function (t) {
                            var routesRecognized = new RoutesRecognized(t.id, _this.serializeUrl(t.extractedUrl), _this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot);
                            eventsSubject.next(routesRecognized);
                        }));
                    }
                    else {
                        var processPreviousUrl = urlTransition && _this.rawUrlTree &&
                            _this.urlHandlingStrategy.shouldProcessUrl(_this.rawUrlTree);
                        /* When the current URL shouldn't be processed, but the previous one was, we
                         * handle this "error condition" by navigating to the previously successful URL,
                         * but leaving the URL intact.*/
                        if (processPreviousUrl) {
                            var id = t.id, extractedUrl = t.extractedUrl, source = t.source, restoredState = t.restoredState, extras = t.extras;
                            var navStart = new NavigationStart(id, _this.serializeUrl(extractedUrl), source, restoredState);
                            eventsSubject.next(navStart);
                            var targetSnapshot = createEmptyState(extractedUrl, _this.rootComponentType).snapshot;
                            return rxjs.of(__assign$1({}, t, { targetSnapshot: targetSnapshot, urlAfterRedirects: extractedUrl, extras: __assign$1({}, extras, { skipLocationChange: false, replaceUrl: false }) }));
                        }
                        else {
                            /* When neither the current or previous URL can be processed, do nothing other
                             * than update router's internal reference to the current "settled" URL. This
                             * way the next navigation will be coming from the current URL in the browser.
                             */
                            _this.rawUrlTree = t.rawUrl;
                            _this.browserUrlTree = t.urlAfterRedirects;
                            t.resolve(null);
                            return rxjs.EMPTY;
                        }
                    }
                }), 
                // Before Preactivation
                switchTap(function (t) {
                    var targetSnapshot = t.targetSnapshot, navigationId = t.id, appliedUrlTree = t.extractedUrl, rawUrlTree = t.rawUrl, _a = t.extras, skipLocationChange = _a.skipLocationChange, replaceUrl = _a.replaceUrl;
                    return _this.hooks.beforePreactivation(targetSnapshot, {
                        navigationId: navigationId,
                        appliedUrlTree: appliedUrlTree,
                        rawUrlTree: rawUrlTree,
                        skipLocationChange: !!skipLocationChange,
                        replaceUrl: !!replaceUrl,
                    });
                }), 
                // --- GUARDS ---
                operators.tap(function (t) {
                    var guardsStart = new GuardsCheckStart(t.id, _this.serializeUrl(t.extractedUrl), _this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot);
                    _this.triggerEvent(guardsStart);
                }), operators.map(function (t) { return (__assign$1({}, t, { guards: getAllRouteGuards(t.targetSnapshot, t.currentSnapshot, _this.rootContexts) })); }), checkGuards(_this.ngModule.injector, function (evt) { return _this.triggerEvent(evt); }), operators.tap(function (t) {
                    if (isUrlTree(t.guardsResult)) {
                        var error = navigationCancelingError("Redirecting to \"" + _this.serializeUrl(t.guardsResult) + "\"");
                        error.url = t.guardsResult;
                        throw error;
                    }
                }), operators.tap(function (t) {
                    var guardsEnd = new GuardsCheckEnd(t.id, _this.serializeUrl(t.extractedUrl), _this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot, !!t.guardsResult);
                    _this.triggerEvent(guardsEnd);
                }), operators.filter(function (t) {
                    if (!t.guardsResult) {
                        _this.resetUrlToCurrentUrlTree();
                        var navCancel = new NavigationCancel(t.id, _this.serializeUrl(t.extractedUrl), '');
                        eventsSubject.next(navCancel);
                        t.resolve(false);
                        return false;
                    }
                    return true;
                }), 
                // --- RESOLVE ---
                switchTap(function (t) {
                    if (t.guards.canActivateChecks.length) {
                        return rxjs.of(t).pipe(operators.tap(function (t) {
                            var resolveStart = new ResolveStart(t.id, _this.serializeUrl(t.extractedUrl), _this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot);
                            _this.triggerEvent(resolveStart);
                        }), resolveData(_this.paramsInheritanceStrategy, _this.ngModule.injector), //
                        operators.tap(function (t) {
                            var resolveEnd = new ResolveEnd(t.id, _this.serializeUrl(t.extractedUrl), _this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot);
                            _this.triggerEvent(resolveEnd);
                        }));
                    }
                    return undefined;
                }), 
                // --- AFTER PREACTIVATION ---
                switchTap(function (t) {
                    var targetSnapshot = t.targetSnapshot, navigationId = t.id, appliedUrlTree = t.extractedUrl, rawUrlTree = t.rawUrl, _a = t.extras, skipLocationChange = _a.skipLocationChange, replaceUrl = _a.replaceUrl;
                    return _this.hooks.afterPreactivation(targetSnapshot, {
                        navigationId: navigationId,
                        appliedUrlTree: appliedUrlTree,
                        rawUrlTree: rawUrlTree,
                        skipLocationChange: !!skipLocationChange,
                        replaceUrl: !!replaceUrl,
                    });
                }), operators.map(function (t) {
                    var targetRouterState = createRouterState(_this.routeReuseStrategy, t.targetSnapshot, t.currentRouterState);
                    return (__assign$1({}, t, { targetRouterState: targetRouterState }));
                }), 
                /* Once here, we are about to activate syncronously. The assumption is this will
                   succeed, and user code may read from the Router service. Therefore before
                   activation, we need to update router properties storing the current URL and the
                   RouterState, as well as updated the browser URL. All this should happen *before*
                   activating. */
                operators.tap(function (t) {
                    _this.currentUrlTree = t.urlAfterRedirects;
                    _this.rawUrlTree = _this.urlHandlingStrategy.merge(_this.currentUrlTree, t.rawUrl);
                    _this.routerState = t.targetRouterState;
                    if (_this.urlUpdateStrategy === 'deferred') {
                        if (!t.extras.skipLocationChange) {
                            _this.setBrowserUrl(_this.rawUrlTree, !!t.extras.replaceUrl, t.id, t.extras.state);
                        }
                        _this.browserUrlTree = t.urlAfterRedirects;
                    }
                }), activateRoutes(_this.rootContexts, _this.routeReuseStrategy, function (evt) { return _this.triggerEvent(evt); }), operators.tap({ next: function () { completed = true; }, complete: function () { completed = true; } }), operators.finalize(function () {
                    /* When the navigation stream finishes either through error or success, we set the
                     * `completed` or `errored` flag. However, there are some situations where we could
                     * get here without either of those being set. For instance, a redirect during
                     * NavigationStart. Therefore, this is a catch-all to make sure the NavigationCancel
                     * event is fired when a navigation gets cancelled but not caught by other means. */
                    if (!completed && !errored) {
                        // Must reset to current URL tree here to ensure history.state is set. On a fresh
                        // page load, if a new navigation comes in before a successful navigation
                        // completes, there will be nothing in history.state.navigationId. This can cause
                        // sync problems with AngularJS sync code which looks for a value here in order
                        // to determine whether or not to handle a given popstate event or to leave it
                        // to the Angualr router.
                        _this.resetUrlToCurrentUrlTree();
                        var navCancel = new NavigationCancel(t.id, _this.serializeUrl(t.extractedUrl), "Navigation ID " + t.id + " is not equal to the current navigation id " + _this.navigationId);
                        eventsSubject.next(navCancel);
                        t.resolve(false);
                    }
                    // currentNavigation should always be reset to null here. If navigation was
                    // successful, lastSuccessfulTransition will have already been set. Therefore we
                    // can safely set currentNavigation to null here.
                    _this.currentNavigation = null;
                }), operators.catchError(function (e) {
                    errored = true;
                    /* This error type is issued during Redirect, and is handled as a cancellation
                     * rather than an error. */
                    if (isNavigationCancelingError(e)) {
                        var redirecting = isUrlTree(e.url);
                        if (!redirecting) {
                            // Set property only if we're not redirecting. If we landed on a page and
                            // redirect to `/` route, the new navigation is going to see the `/` isn't
                            // a change from the default currentUrlTree and won't navigate. This is
                            // only applicable with initial navigation, so setting `navigated` only when
                            // not redirecting resolves this scenario.
                            _this.navigated = true;
                            _this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl);
                        }
                        var navCancel = new NavigationCancel(t.id, _this.serializeUrl(t.extractedUrl), e.message);
                        eventsSubject.next(navCancel);
                        t.resolve(false);
                        if (redirecting) {
                            _this.navigateByUrl(e.url);
                        }
                        /* All other errors should reset to the router's internal URL reference to the
                         * pre-error state. */
                    }
                    else {
                        _this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl);
                        var navError = new NavigationError(t.id, _this.serializeUrl(t.extractedUrl), e);
                        eventsSubject.next(navError);
                        try {
                            t.resolve(_this.errorHandler(e));
                        }
                        catch (ee) {
                            t.reject(ee);
                        }
                    }
                    return rxjs.EMPTY;
                }));
                // TODO(jasonaden): remove cast once g3 is on updated TypeScript
            }));
        };
        /**
         * @internal
         * TODO: this should be removed once the constructor of the router made internal
         */
        Router.prototype.resetRootComponentType = function (rootComponentType) {
            this.rootComponentType = rootComponentType;
            // TODO: vsavkin router 4.0 should make the root component set to null
            // this will simplify the lifecycle of the router.
            this.routerState.root.component = this.rootComponentType;
        };
        Router.prototype.getTransition = function () {
            var transition = this.transitions.value;
            // This value needs to be set. Other values such as extractedUrl are set on initial navigation
            // but the urlAfterRedirects may not get set if we aren't processing the new URL *and* not
            // processing the previous URL.
            transition.urlAfterRedirects = this.browserUrlTree;
            return transition;
        };
        Router.prototype.setTransition = function (t) {
            this.transitions.next(__assign$1({}, this.getTransition(), t));
        };
        /**
         * Sets up the location change listener and performs the initial navigation.
         */
        Router.prototype.initialNavigation = function () {
            this.setUpLocationChangeListener();
            if (this.navigationId === 0) {
                this.navigateByUrl(this.location.path(true), { replaceUrl: true });
            }
        };
        /**
         * Sets up the location change listener.
         */
        Router.prototype.setUpLocationChangeListener = function () {
            var _this = this;
            // Don't need to use Zone.wrap any more, because zone.js
            // already patch onPopState, so location change callback will
            // run into ngZone
            if (!this.locationSubscription) {
                this.locationSubscription = this.location.subscribe(function (change) {
                    var rawUrlTree = _this.parseUrl(change['url']);
                    var source = change['type'] === 'popstate' ? 'popstate' : 'hashchange';
                    // Navigations coming from Angular router have a navigationId state property. When this
                    // exists, restore the state.
                    var state = change.state && change.state.navigationId ? change.state : null;
                    setTimeout(function () { _this.scheduleNavigation(rawUrlTree, source, state, { replaceUrl: true }); }, 0);
                });
            }
        };
        Object.defineProperty(Router.prototype, "url", {
            /** The current URL. */
            get: function () { return this.serializeUrl(this.currentUrlTree); },
            enumerable: true,
            configurable: true
        });
        /** The current Navigation object if one exists */
        Router.prototype.getCurrentNavigation = function () { return this.currentNavigation; };
        /** @internal */
        Router.prototype.triggerEvent = function (event) { this.events.next(event); };
        /**
         * Resets the configuration used for navigation and generating links.
         *
         * @param config The route array for the new configuration.
         *
         * @usageNotes
         *
         * ```
         * router.resetConfig([
         *  { path: 'team/:id', component: TeamCmp, children: [
         *    { path: 'simple', component: SimpleCmp },
         *    { path: 'user/:name', component: UserCmp }
         *  ]}
         * ]);
         * ```
         */
        Router.prototype.resetConfig = function (config) {
            validateConfig(config);
            this.config = config.map(standardizeConfig);
            this.navigated = false;
            this.lastSuccessfulId = -1;
        };
        /** @docsNotRequired */
        Router.prototype.ngOnDestroy = function () { this.dispose(); };
        /** Disposes of the router. */
        Router.prototype.dispose = function () {
            if (this.locationSubscription) {
                this.locationSubscription.unsubscribe();
                this.locationSubscription = null;
            }
        };
        /**
         * Applies an array of commands to the current URL tree and creates a new URL tree.
         *
         * When given an activate route, applies the given commands starting from the route.
         * When not given a route, applies the given command starting from the root.
         *
         * @param commands An array of commands to apply.
         * @param navigationExtras
         * @returns The new URL tree.
         *
         * @usageNotes
         *
         * ```
         * // create /team/33/user/11
         * router.createUrlTree(['/team', 33, 'user', 11]);
         *
         * // create /team/33;expand=true/user/11
         * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);
         *
         * // you can collapse static segments like this (this works only with the first passed-in value):
         * router.createUrlTree(['/team/33/user', userId]);
         *
         * // If the first segment can contain slashes, and you do not want the router to split it, you
         * // can do the following:
         *
         * router.createUrlTree([{segmentPath: '/one/two'}]);
         *
         * // create /team/33/(user/11//right:chat)
         * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);
         *
         * // remove the right secondary node
         * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);
         *
         * // assuming the current url is `/team/33/user/11` and the route points to `user/11`
         *
         * // navigate to /team/33/user/11/details
         * router.createUrlTree(['details'], {relativeTo: route});
         *
         * // navigate to /team/33/user/22
         * router.createUrlTree(['../22'], {relativeTo: route});
         *
         * // navigate to /team/44/user/22
         * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});
         * ```
         */
        Router.prototype.createUrlTree = function (commands, navigationExtras) {
            if (navigationExtras === void 0) { navigationExtras = {}; }
            var relativeTo = navigationExtras.relativeTo, queryParams = navigationExtras.queryParams, fragment = navigationExtras.fragment, preserveQueryParams = navigationExtras.preserveQueryParams, queryParamsHandling = navigationExtras.queryParamsHandling, preserveFragment = navigationExtras.preserveFragment;
            if (core.isDevMode() && preserveQueryParams && console && console.warn) {
                console.warn('preserveQueryParams is deprecated, use queryParamsHandling instead.');
            }
            var a = relativeTo || this.routerState.root;
            var f = preserveFragment ? this.currentUrlTree.fragment : fragment;
            var q = null;
            if (queryParamsHandling) {
                switch (queryParamsHandling) {
                    case 'merge':
                        q = __assign$1({}, this.currentUrlTree.queryParams, queryParams);
                        break;
                    case 'preserve':
                        q = this.currentUrlTree.queryParams;
                        break;
                    default:
                        q = queryParams || null;
                }
            }
            else {
                q = preserveQueryParams ? this.currentUrlTree.queryParams : queryParams || null;
            }
            if (q !== null) {
                q = this.removeEmptyProps(q);
            }
            return createUrlTree(a, this.currentUrlTree, commands, q, f);
        };
        /**
         * Navigate based on the provided URL, which must be absolute.
         *
         * @param url An absolute URL. The function does not apply any delta to the current URL.
         * @param extras An object containing properties that modify the navigation strategy.
         * The function ignores any properties in the `NavigationExtras` that would change the
         * provided URL.
         *
         * @returns A Promise that resolves to 'true' when navigation succeeds,
         * to 'false' when navigation fails, or is rejected on error.
         *
         * @usageNotes
         *
         * ### Example
         *
         * ```
         * router.navigateByUrl("/team/33/user/11");
         *
         * // Navigate without updating the URL
         * router.navigateByUrl("/team/33/user/11", { skipLocationChange: true });
         * ```
         *
         */
        Router.prototype.navigateByUrl = function (url, extras) {
            if (extras === void 0) { extras = { skipLocationChange: false }; }
            if (core.isDevMode() && this.isNgZoneEnabled && !core.NgZone.isInAngularZone()) {
                this.console.warn("Navigation triggered outside Angular zone, did you forget to call 'ngZone.run()'?");
            }
            var urlTree = isUrlTree(url) ? url : this.parseUrl(url);
            var mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);
            return this.scheduleNavigation(mergedTree, 'imperative', null, extras);
        };
        /**
         * Navigate based on the provided array of commands and a starting point.
         * If no starting route is provided, the navigation is absolute.
         *
         * Returns a promise that:
         * - resolves to 'true' when navigation succeeds,
         * - resolves to 'false' when navigation fails,
         * - is rejected when an error happens.
         *
         * @usageNotes
         *
         * ### Example
         *
         * ```
         * router.navigate(['team', 33, 'user', 11], {relativeTo: route});
         *
         * // Navigate without updating the URL
         * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});
         * ```
         *
         * The first parameter of `navigate()` is a delta to be applied to the current URL
         * or the one provided in the `relativeTo` property of the second parameter (the
         * `NavigationExtras`).
         *
         * In order to affect this browser's `history.state` entry, the `state`
         * parameter can be passed. This must be an object because the router
         * will add the `navigationId` property to this object before creating
         * the new history item.
         */
        Router.prototype.navigate = function (commands, extras) {
            if (extras === void 0) { extras = { skipLocationChange: false }; }
            validateCommands(commands);
            return this.navigateByUrl(this.createUrlTree(commands, extras), extras);
        };
        /** Serializes a `UrlTree` into a string */
        Router.prototype.serializeUrl = function (url) { return this.urlSerializer.serialize(url); };
        /** Parses a string into a `UrlTree` */
        Router.prototype.parseUrl = function (url) {
            var urlTree;
            try {
                urlTree = this.urlSerializer.parse(url);
            }
            catch (e) {
                urlTree = this.malformedUriErrorHandler(e, this.urlSerializer, url);
            }
            return urlTree;
        };
        /** Returns whether the url is activated */
        Router.prototype.isActive = function (url, exact) {
            if (isUrlTree(url)) {
                return containsTree(this.currentUrlTree, url, exact);
            }
            var urlTree = this.parseUrl(url);
            return containsTree(this.currentUrlTree, urlTree, exact);
        };
        Router.prototype.removeEmptyProps = function (params) {
            return Object.keys(params).reduce(function (result, key) {
                var value = params[key];
                if (value !== null && value !== undefined) {
                    result[key] = value;
                }
                return result;
            }, {});
        };
        Router.prototype.processNavigations = function () {
            var _this = this;
            this.navigations.subscribe(function (t) {
                _this.navigated = true;
                _this.lastSuccessfulId = t.id;
                _this.events
                    .next(new NavigationEnd(t.id, _this.serializeUrl(t.extractedUrl), _this.serializeUrl(_this.currentUrlTree)));
                _this.lastSuccessfulNavigation = _this.currentNavigation;
                _this.currentNavigation = null;
                t.resolve(true);
            }, function (e) { _this.console.warn("Unhandled Navigation Error: "); });
        };
        Router.prototype.scheduleNavigation = function (rawUrl, source, restoredState, extras) {
            var lastNavigation = this.getTransition();
            // If the user triggers a navigation imperatively (e.g., by using navigateByUrl),
            // and that navigation results in 'replaceState' that leads to the same URL,
            // we should skip those.
            if (lastNavigation && source !== 'imperative' && lastNavigation.source === 'imperative' &&
                lastNavigation.rawUrl.toString() === rawUrl.toString()) {
                return Promise.resolve(true); // return value is not used
            }
            // Because of a bug in IE and Edge, the location class fires two events (popstate and
            // hashchange) every single time. The second one should be ignored. Otherwise, the URL will
            // flicker. Handles the case when a popstate was emitted first.
            if (lastNavigation && source == 'hashchange' && lastNavigation.source === 'popstate' &&
                lastNavigation.rawUrl.toString() === rawUrl.toString()) {
                return Promise.resolve(true); // return value is not used
            }
            // Because of a bug in IE and Edge, the location class fires two events (popstate and
            // hashchange) every single time. The second one should be ignored. Otherwise, the URL will
            // flicker. Handles the case when a hashchange was emitted first.
            if (lastNavigation && source == 'popstate' && lastNavigation.source === 'hashchange' &&
                lastNavigation.rawUrl.toString() === rawUrl.toString()) {
                return Promise.resolve(true); // return value is not used
            }
            var resolve = null;
            var reject = null;
            var promise = new Promise(function (res, rej) {
                resolve = res;
                reject = rej;
            });
            var id = ++this.navigationId;
            this.setTransition({
                id: id,
                source: source,
                restoredState: restoredState,
                currentUrlTree: this.currentUrlTree,
                currentRawUrl: this.rawUrlTree, rawUrl: rawUrl, extras: extras, resolve: resolve, reject: reject, promise: promise,
                currentSnapshot: this.routerState.snapshot,
                currentRouterState: this.routerState
            });
            // Make sure that the error is propagated even though `processNavigations` catch
            // handler does not rethrow
            return promise.catch(function (e) { return Promise.reject(e); });
        };
        Router.prototype.setBrowserUrl = function (url, replaceUrl, id, state) {
            var path = this.urlSerializer.serialize(url);
            state = state || {};
            if (this.location.isCurrentPathEqualTo(path) || replaceUrl) {
                // TODO(jasonaden): Remove first `navigationId` and rely on `ng` namespace.
                this.location.replaceState(path, '', __assign$1({}, state, { navigationId: id }));
            }
            else {
                this.location.go(path, '', __assign$1({}, state, { navigationId: id }));
            }
        };
        Router.prototype.resetStateAndUrl = function (storedState, storedUrl, rawUrl) {
            this.routerState = storedState;
            this.currentUrlTree = storedUrl;
            this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, rawUrl);
            this.resetUrlToCurrentUrlTree();
        };
        Router.prototype.resetUrlToCurrentUrlTree = function () {
            this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), '', { navigationId: this.lastSuccessfulId });
        };
Router.ɵfac = function Router_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
Router.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: Router });

        return Router;
    }());
    function validateCommands(commands) {
        for (var i = 0; i < commands.length; i++) {
            var cmd = commands[i];
            if (cmd == null) {
                throw new Error("The requested path contains " + cmd + " segment at index " + i);
            }
        }
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @description
     *
     * Lets you link to specific routes in your app.
     *
     * Consider the following route configuration:
     * `[{ path: 'user/:name', component: UserCmp }]`.
     * When linking to this `user/:name` route, you use the `RouterLink` directive.
     *
     * If the link is static, you can use the directive as follows:
     * `<a routerLink="/user/bob">link to user component</a>`
     *
     * If you use dynamic values to generate the link, you can pass an array of path
     * segments, followed by the params for each segment.
     *
     * For instance `['/team', teamId, 'user', userName, {details: true}]`
     * means that we want to generate a link to `/team/11/user/bob;details=true`.
     *
     * Multiple static segments can be merged into one
     * (e.g., `['/team/11/user', userName, {details: true}]`).
     *
     * The first segment name can be prepended with `/`, `./`, or `../`:
     * * If the first segment begins with `/`, the router will look up the route from the root of the
     *   app.
     * * If the first segment begins with `./`, or doesn't begin with a slash, the router will
     *   instead look in the children of the current activated route.
     * * And if the first segment begins with `../`, the router will go up one level.
     *
     * You can set query params and fragment as follows:
     *
     * ```
     * <a [routerLink]="['/user/bob']" [queryParams]="{debug: true}" fragment="education">
     *   link to user component
     * </a>
     * ```
     * RouterLink will use these to generate this link: `/user/bob#education?debug=true`.
     *
     * (Deprecated in v4.0.0 use `queryParamsHandling` instead) You can also tell the
     * directive to preserve the current query params and fragment:
     *
     * ```
     * <a [routerLink]="['/user/bob']" preserveQueryParams preserveFragment>
     *   link to user component
     * </a>
     * ```
     *
     * You can tell the directive how to handle queryParams. Available options are:
     *  - `'merge'`: merge the queryParams into the current queryParams
     *  - `'preserve'`: preserve the current queryParams
     *  - default/`''`: use the queryParams only
     *
     * Same options for {@link NavigationExtras#queryParamsHandling
     * NavigationExtras#queryParamsHandling}.
     *
     * ```
     * <a [routerLink]="['/user/bob']" [queryParams]="{debug: true}" queryParamsHandling="merge">
     *   link to user component
     * </a>
     * ```
     *
     * You can provide a `state` value to be persisted to the browser's History.state
     * property (See https://developer.mozilla.org/en-US/docs/Web/API/History#Properties). It's
     * used as follows:
     *
     * ```
     * <a [routerLink]="['/user/bob']" [state]="{tracingId: 123}">
     *   link to user component
     * </a>
     * ```
     *
     * And later the value can be read from the router through `router.getCurrentNavigation`.
     * For example, to capture the `tracingId` above during the `NavigationStart` event:
     *
     * ```
     * // Get NavigationStart events
     * router.events.pipe(filter(e => e instanceof NavigationStart)).subscribe(e => {
     *   const navigation = router.getCurrentNavigation();
     *   tracingService.trace({id: navigation.extras.state.tracingId});
     * });
     * ```
     *
     * The router link directive always treats the provided input as a delta to the current url.
     *
     * For instance, if the current url is `/user/(box//aux:team)`.
     *
     * Then the following link `<a [routerLink]="['/user/jim']">Jim</a>` will generate the link
     * `/user/(jim//aux:team)`.
     *
     * See {@link Router#createUrlTree createUrlTree} for more information.
     *
     * @ngModule RouterModule
     *
     * @publicApi
     */
    var RouterLink = /** @class */ (function () {
        function RouterLink(router, route, tabIndex, renderer, el) {
            this.router = router;
            this.route = route;
            this.commands = [];
            if (tabIndex == null) {
                renderer.setAttribute(el.nativeElement, 'tabindex', '0');
            }
        }
        Object.defineProperty(RouterLink.prototype, "routerLink", {
            set: function (commands) {
                if (commands != null) {
                    this.commands = Array.isArray(commands) ? commands : [commands];
                }
                else {
                    this.commands = [];
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RouterLink.prototype, "preserveQueryParams", {
            /**
             * @deprecated 4.0.0 use `queryParamsHandling` instead.
             */
            set: function (value) {
                if (core.isDevMode() && console && console.warn) {
                    console.warn('preserveQueryParams is deprecated!, use queryParamsHandling instead.');
                }
                this.preserve = value;
            },
            enumerable: true,
            configurable: true
        });
        RouterLink.prototype.onClick = function () {
            var extras = {
                skipLocationChange: attrBoolValue(this.skipLocationChange),
                replaceUrl: attrBoolValue(this.replaceUrl),
            };
            this.router.navigateByUrl(this.urlTree, extras);
            return true;
        };
        Object.defineProperty(RouterLink.prototype, "urlTree", {
            get: function () {
                return this.router.createUrlTree(this.commands, {
                    relativeTo: this.route,
                    queryParams: this.queryParams,
                    fragment: this.fragment,
                    preserveQueryParams: attrBoolValue(this.preserve),
                    queryParamsHandling: this.queryParamsHandling,
                    preserveFragment: attrBoolValue(this.preserveFragment),
                });
            },
            enumerable: true,
            configurable: true
        });
        __decorate$1([
            core.Input(),
            __metadata$1("design:type", Object)
        ], RouterLink.prototype, "queryParams", void 0);
        __decorate$1([
            core.Input(),
            __metadata$1("design:type", String)
        ], RouterLink.prototype, "fragment", void 0);
        __decorate$1([
            core.Input(),
            __metadata$1("design:type", String)
        ], RouterLink.prototype, "queryParamsHandling", void 0);
        __decorate$1([
            core.Input(),
            __metadata$1("design:type", Boolean)
        ], RouterLink.prototype, "preserveFragment", void 0);
        __decorate$1([
            core.Input(),
            __metadata$1("design:type", Boolean)
        ], RouterLink.prototype, "skipLocationChange", void 0);
        __decorate$1([
            core.Input(),
            __metadata$1("design:type", Boolean)
        ], RouterLink.prototype, "replaceUrl", void 0);
        __decorate$1([
            core.Input(),
            __metadata$1("design:type", Object)
        ], RouterLink.prototype, "state", void 0);
        __decorate$1([
            core.Input(),
            __metadata$1("design:type", Object),
            __metadata$1("design:paramtypes", [Object])
        ], RouterLink.prototype, "routerLink", null);
        __decorate$1([
            core.Input(),
            __metadata$1("design:type", Boolean),
            __metadata$1("design:paramtypes", [Boolean])
        ], RouterLink.prototype, "preserveQueryParams", null);
        __decorate$1([
            core.HostListener('click'),
            __metadata$1("design:type", Function),
            __metadata$1("design:paramtypes", []),
            __metadata$1("design:returntype", Boolean)
        ], RouterLink.prototype, "onClick", null);
        RouterLink = __decorate$1([ __param$1(2, core.Attribute('tabindex')),
            __metadata$1("design:paramtypes", [Router, ActivatedRoute, String, core.Renderer2, core.ElementRef])
        ], RouterLink);
RouterLink.ɵfac = function RouterLink_Factory(t) { return new (t || RouterLink)(ɵngcc0.ɵɵdirectiveInject(Router), ɵngcc0.ɵɵdirectiveInject(ActivatedRoute), ɵngcc0.ɵɵinjectAttribute('tabindex'), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
RouterLink.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: RouterLink, selectors: [["", "routerLink", "", 5, "a", 5, "area"]], hostBindings: function RouterLink_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function RouterLink_click_HostBindingHandler() { return ctx.onClick(); });
    } }, inputs: { routerLink: "routerLink", preserveQueryParams: "preserveQueryParams", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl", state: "state" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RouterLink, [{
        type: core.Directive,
        args: [{ selector: ':not(a):not(area)[routerLink]' }]
    }], function () { return [{ type: Router }, { type: ActivatedRoute }, { type: String, decorators: [{
                type: core.Attribute,
                args: ['tabindex']
            }] }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { routerLink: [{
            type: core.Input
        }], preserveQueryParams: [{
            type: core.Input
        }], onClick: [{
            type: core.HostListener,
            args: ['click']
        }], queryParams: [{
            type: core.Input
        }], fragment: [{
            type: core.Input
        }], queryParamsHandling: [{
            type: core.Input
        }], preserveFragment: [{
            type: core.Input
        }], skipLocationChange: [{
            type: core.Input
        }], replaceUrl: [{
            type: core.Input
        }], state: [{
            type: core.Input
        }] }); })();
        return RouterLink;
    }());
    /**
     * @description
     *
     * Lets you link to specific routes in your app.
     *
     * See `RouterLink` for more information.
     *
     * @ngModule RouterModule
     *
     * @publicApi
     */
    var RouterLinkWithHref = /** @class */ (function () {
        function RouterLinkWithHref(router, route, locationStrategy) {
            var _this = this;
            this.router = router;
            this.route = route;
            this.locationStrategy = locationStrategy;
            this.commands = [];
            this.subscription = router.events.subscribe(function (s) {
                if (s instanceof NavigationEnd) {
                    _this.updateTargetUrlAndHref();
                }
            });
        }
        Object.defineProperty(RouterLinkWithHref.prototype, "routerLink", {
            set: function (commands) {
                if (commands != null) {
                    this.commands = Array.isArray(commands) ? commands : [commands];
                }
                else {
                    this.commands = [];
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RouterLinkWithHref.prototype, "preserveQueryParams", {
            set: function (value) {
                if (core.isDevMode() && console && console.warn) {
                    console.warn('preserveQueryParams is deprecated, use queryParamsHandling instead.');
                }
                this.preserve = value;
            },
            enumerable: true,
            configurable: true
        });
        RouterLinkWithHref.prototype.ngOnChanges = function (changes) { this.updateTargetUrlAndHref(); };
        RouterLinkWithHref.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };
        RouterLinkWithHref.prototype.onClick = function (button, ctrlKey, metaKey, shiftKey) {
            if (button !== 0 || ctrlKey || metaKey || shiftKey) {
                return true;
            }
            if (typeof this.target === 'string' && this.target != '_self') {
                return true;
            }
            var extras = {
                skipLocationChange: attrBoolValue(this.skipLocationChange),
                replaceUrl: attrBoolValue(this.replaceUrl),
                state: this.state
            };
            this.router.navigateByUrl(this.urlTree, extras);
            return false;
        };
        RouterLinkWithHref.prototype.updateTargetUrlAndHref = function () {
            this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree));
        };
        Object.defineProperty(RouterLinkWithHref.prototype, "urlTree", {
            get: function () {
                return this.router.createUrlTree(this.commands, {
                    relativeTo: this.route,
                    queryParams: this.queryParams,
                    fragment: this.fragment,
                    preserveQueryParams: attrBoolValue(this.preserve),
                    queryParamsHandling: this.queryParamsHandling,
                    preserveFragment: attrBoolValue(this.preserveFragment),
                });
            },
            enumerable: true,
            configurable: true
        });
        __decorate$1([
            core.HostBinding('attr.target'), core.Input(),
            __metadata$1("design:type", String)
        ], RouterLinkWithHref.prototype, "target", void 0);
        __decorate$1([
            core.Input(),
            __metadata$1("design:type", Object)
        ], RouterLinkWithHref.prototype, "queryParams", void 0);
        __decorate$1([
            core.Input(),
            __metadata$1("design:type", String)
        ], RouterLinkWithHref.prototype, "fragment", void 0);
        __decorate$1([
            core.Input(),
            __metadata$1("design:type", String)
        ], RouterLinkWithHref.prototype, "queryParamsHandling", void 0);
        __decorate$1([
            core.Input(),
            __metadata$1("design:type", Boolean)
        ], RouterLinkWithHref.prototype, "preserveFragment", void 0);
        __decorate$1([
            core.Input(),
            __metadata$1("design:type", Boolean)
        ], RouterLinkWithHref.prototype, "skipLocationChange", void 0);
        __decorate$1([
            core.Input(),
            __metadata$1("design:type", Boolean)
        ], RouterLinkWithHref.prototype, "replaceUrl", void 0);
        __decorate$1([
            core.Input(),
            __metadata$1("design:type", Object)
        ], RouterLinkWithHref.prototype, "state", void 0);
        __decorate$1([
            core.HostBinding(),
            __metadata$1("design:type", String)
        ], RouterLinkWithHref.prototype, "href", void 0);
        __decorate$1([
            core.Input(),
            __metadata$1("design:type", Object),
            __metadata$1("design:paramtypes", [Object])
        ], RouterLinkWithHref.prototype, "routerLink", null);
        __decorate$1([
            core.Input(),
            __metadata$1("design:type", Boolean),
            __metadata$1("design:paramtypes", [Boolean])
        ], RouterLinkWithHref.prototype, "preserveQueryParams", null);
        __decorate$1([
            core.HostListener('click', ['$event.button', '$event.ctrlKey', '$event.metaKey', '$event.shiftKey']),
            __metadata$1("design:type", Function),
            __metadata$1("design:paramtypes", [Number, Boolean, Boolean, Boolean]),
            __metadata$1("design:returntype", Boolean)
        ], RouterLinkWithHref.prototype, "onClick", null);
        RouterLinkWithHref = __decorate$1([ __metadata$1("design:paramtypes", [Router, ActivatedRoute,
                common.LocationStrategy])
        ], RouterLinkWithHref);
RouterLinkWithHref.ɵfac = function RouterLinkWithHref_Factory(t) { return new (t || RouterLinkWithHref)(ɵngcc0.ɵɵdirectiveInject(Router), ɵngcc0.ɵɵdirectiveInject(ActivatedRoute), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocationStrategy)); };
RouterLinkWithHref.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: RouterLinkWithHref, selectors: [["a", "routerLink", ""], ["area", "routerLink", ""]], hostVars: 2, hostBindings: function RouterLinkWithHref_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function RouterLinkWithHref_click_HostBindingHandler($event) { return ctx.onClick($event.button, $event.ctrlKey, $event.metaKey, $event.shiftKey); });
    } if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("href", ctx.href, ɵngcc0.ɵɵsanitizeUrl);
        ɵngcc0.ɵɵattribute("target", ctx.target);
    } }, inputs: { routerLink: "routerLink", preserveQueryParams: "preserveQueryParams", target: "target", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl", state: "state" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RouterLinkWithHref, [{
        type: core.Directive,
        args: [{ selector: 'a[routerLink],area[routerLink]' }]
    }], function () { return [{ type: Router }, { type: ActivatedRoute }, { type: ɵngcc1.LocationStrategy }]; }, { routerLink: [{
            type: core.Input
        }], preserveQueryParams: [{
            type: core.Input
        }], onClick: [{
            type: core.HostListener,
            args: ['click', ['$event.button', '$event.ctrlKey', '$event.metaKey', '$event.shiftKey']]
        }], href: [{
            type: core.HostBinding
        }], target: [{
            type: core.HostBinding,
            args: ['attr.target']
        }, {
            type: core.Input
        }], queryParams: [{
            type: core.Input
        }], fragment: [{
            type: core.Input
        }], queryParamsHandling: [{
            type: core.Input
        }], preserveFragment: [{
            type: core.Input
        }], skipLocationChange: [{
            type: core.Input
        }], replaceUrl: [{
            type: core.Input
        }], state: [{
            type: core.Input
        }] }); })();
        return RouterLinkWithHref;
    }());
    function attrBoolValue(s) {
        return s === '' || !!s;
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     *
     * @description
     *
     * Lets you add a CSS class to an element when the link's route becomes active.
     *
     * This directive lets you add a CSS class to an element when the link's route
     * becomes active.
     *
     * Consider the following example:
     *
     * ```
     * <a routerLink="/user/bob" routerLinkActive="active-link">Bob</a>
     * ```
     *
     * When the url is either '/user' or '/user/bob', the active-link class will
     * be added to the `a` tag. If the url changes, the class will be removed.
     *
     * You can set more than one class, as follows:
     *
     * ```
     * <a routerLink="/user/bob" routerLinkActive="class1 class2">Bob</a>
     * <a routerLink="/user/bob" [routerLinkActive]="['class1', 'class2']">Bob</a>
     * ```
     *
     * You can configure RouterLinkActive by passing `exact: true`. This will add the classes
     * only when the url matches the link exactly.
     *
     * ```
     * <a routerLink="/user/bob" routerLinkActive="active-link" [routerLinkActiveOptions]="{exact:
     * true}">Bob</a>
     * ```
     *
     * You can assign the RouterLinkActive instance to a template variable and directly check
     * the `isActive` status.
     * ```
     * <a routerLink="/user/bob" routerLinkActive #rla="routerLinkActive">
     *   Bob {{ rla.isActive ? '(already open)' : ''}}
     * </a>
     * ```
     *
     * Finally, you can apply the RouterLinkActive directive to an ancestor of a RouterLink.
     *
     * ```
     * <div routerLinkActive="active-link" [routerLinkActiveOptions]="{exact: true}">
     *   <a routerLink="/user/jim">Jim</a>
     *   <a routerLink="/user/bob">Bob</a>
     * </div>
     * ```
     *
     * This will set the active-link class on the div tag if the url is either '/user/jim' or
     * '/user/bob'.
     *
     * @ngModule RouterModule
     *
     * @publicApi
     */
    var RouterLinkActive = /** @class */ (function () {
        function RouterLinkActive(router, element, renderer, link, linkWithHref) {
            var _this = this;
            this.router = router;
            this.element = element;
            this.renderer = renderer;
            this.link = link;
            this.linkWithHref = linkWithHref;
            this.classes = [];
            this.isActive = false;
            this.routerLinkActiveOptions = { exact: false };
            this.subscription = router.events.subscribe(function (s) {
                if (s instanceof NavigationEnd) {
                    _this.update();
                }
            });
        }
        RouterLinkActive.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.links.changes.subscribe(function (_) { return _this.update(); });
            this.linksWithHrefs.changes.subscribe(function (_) { return _this.update(); });
            this.update();
        };
        Object.defineProperty(RouterLinkActive.prototype, "routerLinkActive", {
            set: function (data) {
                var classes = Array.isArray(data) ? data : data.split(' ');
                this.classes = classes.filter(function (c) { return !!c; });
            },
            enumerable: true,
            configurable: true
        });
        RouterLinkActive.prototype.ngOnChanges = function (changes) { this.update(); };
        RouterLinkActive.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };
        RouterLinkActive.prototype.update = function () {
            var _this = this;
            if (!this.links || !this.linksWithHrefs || !this.router.navigated)
                return;
            Promise.resolve().then(function () {
                var hasActiveLinks = _this.hasActiveLinks();
                if (_this.isActive !== hasActiveLinks) {
                    _this.isActive = hasActiveLinks;
                    _this.classes.forEach(function (c) {
                        if (hasActiveLinks) {
                            _this.renderer.addClass(_this.element.nativeElement, c);
                        }
                        else {
                            _this.renderer.removeClass(_this.element.nativeElement, c);
                        }
                    });
                }
            });
        };
        RouterLinkActive.prototype.isLinkActive = function (router) {
            var _this = this;
            return function (link) {
                return router.isActive(link.urlTree, _this.routerLinkActiveOptions.exact);
            };
        };
        RouterLinkActive.prototype.hasActiveLinks = function () {
            var isActiveCheckFn = this.isLinkActive(this.router);
            return this.link && isActiveCheckFn(this.link) ||
                this.linkWithHref && isActiveCheckFn(this.linkWithHref) ||
                this.links.some(isActiveCheckFn) || this.linksWithHrefs.some(isActiveCheckFn);
        };
        __decorate$1([
            core.ContentChildren(RouterLink, { descendants: true }),
            __metadata$1("design:type", core.QueryList)
        ], RouterLinkActive.prototype, "links", void 0);
        __decorate$1([
            core.ContentChildren(RouterLinkWithHref, { descendants: true }),
            __metadata$1("design:type", core.QueryList)
        ], RouterLinkActive.prototype, "linksWithHrefs", void 0);
        __decorate$1([
            core.Input(),
            __metadata$1("design:type", Object)
        ], RouterLinkActive.prototype, "routerLinkActiveOptions", void 0);
        __decorate$1([
            core.Input(),
            __metadata$1("design:type", Object),
            __metadata$1("design:paramtypes", [Object])
        ], RouterLinkActive.prototype, "routerLinkActive", null);
        RouterLinkActive = __decorate$1([ __param$1(3, core.Optional()),
            __param$1(4, core.Optional()),
            __metadata$1("design:paramtypes", [Router, core.ElementRef, core.Renderer2,
                RouterLink,
                RouterLinkWithHref])
        ], RouterLinkActive);
RouterLinkActive.ɵfac = function RouterLinkActive_Factory(t) { return new (t || RouterLinkActive)(ɵngcc0.ɵɵdirectiveInject(Router), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(RouterLink, 8), ɵngcc0.ɵɵdirectiveInject(RouterLinkWithHref, 8)); };
RouterLinkActive.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: RouterLinkActive, selectors: [["", "routerLinkActive", ""]], contentQueries: function RouterLinkActive_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, RouterLink, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, RouterLinkWithHref, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.links = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.linksWithHrefs = _t);
    } }, inputs: { routerLinkActiveOptions: "routerLinkActiveOptions", routerLinkActive: "routerLinkActive" }, exportAs: ["routerLinkActive"], features: [ɵngcc0.ɵɵNgOnChangesFeature()] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RouterLinkActive, [{
        type: core.Directive,
        args: [{
                selector: '[routerLinkActive]',
                exportAs: 'routerLinkActive'
            }]
    }], function () { return [{ type: Router }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: RouterLink, decorators: [{
                type: core.Optional
            }] }, { type: RouterLinkWithHref, decorators: [{
                type: core.Optional
            }] }]; }, { routerLinkActiveOptions: [{
            type: core.Input
        }], routerLinkActive: [{
            type: core.Input
        }], links: [{
            type: core.ContentChildren,
            args: [RouterLink, { descendants: true }]
        }], linksWithHrefs: [{
            type: core.ContentChildren,
            args: [RouterLinkWithHref, { descendants: true }]
        }] }); })();
        return RouterLinkActive;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Store contextual information about a `RouterOutlet`
     *
     * @publicApi
     */
    var OutletContext = /** @class */ (function () {
        function OutletContext() {
            this.outlet = null;
            this.route = null;
            this.resolver = null;
            this.children = new ChildrenOutletContexts();
            this.attachRef = null;
        }
        return OutletContext;
    }());
    /**
     * Store contextual information about the children (= nested) `RouterOutlet`
     *
     * @publicApi
     */
    var ChildrenOutletContexts = /** @class */ (function () {
        function ChildrenOutletContexts() {
            // contexts for child outlets, by name.
            this.contexts = new Map();
        }
        /** Called when a `RouterOutlet` directive is instantiated */
        ChildrenOutletContexts.prototype.onChildOutletCreated = function (childName, outlet) {
            var context = this.getOrCreateContext(childName);
            context.outlet = outlet;
            this.contexts.set(childName, context);
        };
        /**
         * Called when a `RouterOutlet` directive is destroyed.
         * We need to keep the context as the outlet could be destroyed inside a NgIf and might be
         * re-created later.
         */
        ChildrenOutletContexts.prototype.onChildOutletDestroyed = function (childName) {
            var context = this.getContext(childName);
            if (context) {
                context.outlet = null;
            }
        };
        /**
         * Called when the corresponding route is deactivated during navigation.
         * Because the component get destroyed, all children outlet are destroyed.
         */
        ChildrenOutletContexts.prototype.onOutletDeactivated = function () {
            var contexts = this.contexts;
            this.contexts = new Map();
            return contexts;
        };
        ChildrenOutletContexts.prototype.onOutletReAttached = function (contexts) { this.contexts = contexts; };
        ChildrenOutletContexts.prototype.getOrCreateContext = function (childName) {
            var context = this.getContext(childName);
            if (!context) {
                context = new OutletContext();
                this.contexts.set(childName, context);
            }
            return context;
        };
        ChildrenOutletContexts.prototype.getContext = function (childName) { return this.contexts.get(childName) || null; };
        return ChildrenOutletContexts;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @description
     *
     * Acts as a placeholder that Angular dynamically fills based on the current router state.
     *
     * ```
     * <router-outlet></router-outlet>
     * <router-outlet name='left'></router-outlet>
     * <router-outlet name='right'></router-outlet>
     * ```
     *
     * A router outlet will emit an activate event any time a new component is being instantiated,
     * and a deactivate event when it is being destroyed.
     *
     * ```
     * <router-outlet
     *   (activate)='onActivate($event)'
     *   (deactivate)='onDeactivate($event)'></router-outlet>
     * ```
     * @ngModule RouterModule
     *
     * @publicApi
     */
    var RouterOutlet = /** @class */ (function () {
        function RouterOutlet(parentContexts, location, resolver, name, changeDetector) {
            this.parentContexts = parentContexts;
            this.location = location;
            this.resolver = resolver;
            this.changeDetector = changeDetector;
            this.activated = null;
            this._activatedRoute = null;
            this.activateEvents = new core.EventEmitter();
            this.deactivateEvents = new core.EventEmitter();
            this.name = name || PRIMARY_OUTLET;
            parentContexts.onChildOutletCreated(this.name, this);
        }
        RouterOutlet.prototype.ngOnDestroy = function () { this.parentContexts.onChildOutletDestroyed(this.name); };
        RouterOutlet.prototype.ngOnInit = function () {
            if (!this.activated) {
                // If the outlet was not instantiated at the time the route got activated we need to populate
                // the outlet when it is initialized (ie inside a NgIf)
                var context = this.parentContexts.getContext(this.name);
                if (context && context.route) {
                    if (context.attachRef) {
                        // `attachRef` is populated when there is an existing component to mount
                        this.attach(context.attachRef, context.route);
                    }
                    else {
                        // otherwise the component defined in the configuration is created
                        this.activateWith(context.route, context.resolver || null);
                    }
                }
            }
        };
        Object.defineProperty(RouterOutlet.prototype, "isActivated", {
            get: function () { return !!this.activated; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RouterOutlet.prototype, "component", {
            get: function () {
                if (!this.activated)
                    throw new Error('Outlet is not activated');
                return this.activated.instance;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RouterOutlet.prototype, "activatedRoute", {
            get: function () {
                if (!this.activated)
                    throw new Error('Outlet is not activated');
                return this._activatedRoute;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RouterOutlet.prototype, "activatedRouteData", {
            get: function () {
                if (this._activatedRoute) {
                    return this._activatedRoute.snapshot.data;
                }
                return {};
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Called when the `RouteReuseStrategy` instructs to detach the subtree
         */
        RouterOutlet.prototype.detach = function () {
            if (!this.activated)
                throw new Error('Outlet is not activated');
            this.location.detach();
            var cmp = this.activated;
            this.activated = null;
            this._activatedRoute = null;
            return cmp;
        };
        /**
         * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree
         */
        RouterOutlet.prototype.attach = function (ref, activatedRoute) {
            this.activated = ref;
            this._activatedRoute = activatedRoute;
            this.location.insert(ref.hostView);
        };
        RouterOutlet.prototype.deactivate = function () {
            if (this.activated) {
                var c = this.component;
                this.activated.destroy();
                this.activated = null;
                this._activatedRoute = null;
                this.deactivateEvents.emit(c);
            }
        };
        RouterOutlet.prototype.activateWith = function (activatedRoute, resolver) {
            if (this.isActivated) {
                throw new Error('Cannot activate an already activated outlet');
            }
            this._activatedRoute = activatedRoute;
            var snapshot = activatedRoute._futureSnapshot;
            var component = snapshot.routeConfig.component;
            resolver = resolver || this.resolver;
            var factory = resolver.resolveComponentFactory(component);
            var childContexts = this.parentContexts.getOrCreateContext(this.name).children;
            var injector = new OutletInjector(activatedRoute, childContexts, this.location.injector);
            this.activated = this.location.createComponent(factory, this.location.length, injector);
            // Calling `markForCheck` to make sure we will run the change detection when the
            // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.
            this.changeDetector.markForCheck();
            this.activateEvents.emit(this.activated.instance);
        };
        __decorate$1([
            core.Output('activate'),
            __metadata$1("design:type", Object)
        ], RouterOutlet.prototype, "activateEvents", void 0);
        __decorate$1([
            core.Output('deactivate'),
            __metadata$1("design:type", Object)
        ], RouterOutlet.prototype, "deactivateEvents", void 0);
        RouterOutlet = __decorate$1([ __param$1(3, core.Attribute('name')),
            __metadata$1("design:paramtypes", [ChildrenOutletContexts, core.ViewContainerRef,
                core.ComponentFactoryResolver, String, core.ChangeDetectorRef])
        ], RouterOutlet);
RouterOutlet.ɵfac = function RouterOutlet_Factory(t) { return new (t || RouterOutlet)(ɵngcc0.ɵɵdirectiveInject(ChildrenOutletContexts), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinjectAttribute('name'), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
RouterOutlet.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: RouterOutlet, selectors: [["router-outlet"]], outputs: { activateEvents: "activate", deactivateEvents: "deactivate" }, exportAs: ["outlet"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RouterOutlet, [{
        type: core.Directive,
        args: [{ selector: 'router-outlet', exportAs: 'outlet' }]
    }], function () { return [{ type: ChildrenOutletContexts }, { type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.ComponentFactoryResolver }, { type: String, decorators: [{
                type: core.Attribute,
                args: ['name']
            }] }, { type: ɵngcc0.ChangeDetectorRef }]; }, { activateEvents: [{
            type: core.Output,
            args: ['activate']
        }], deactivateEvents: [{
            type: core.Output,
            args: ['deactivate']
        }] }); })();
        return RouterOutlet;
    }());
    var OutletInjector = /** @class */ (function () {
        function OutletInjector(route, childContexts, parent) {
            this.route = route;
            this.childContexts = childContexts;
            this.parent = parent;
        }
        OutletInjector.prototype.get = function (token, notFoundValue) {
            if (token === ActivatedRoute) {
                return this.route;
            }
            if (token === ChildrenOutletContexts) {
                return this.childContexts;
            }
            return this.parent.get(token, notFoundValue);
        };
        return OutletInjector;
    }());

    /**
    *@license
    *Copyright Google Inc. All Rights Reserved.
    *
    *Use of this source code is governed by an MIT-style license that can be
    *found in the LICENSE file at https://angular.io/license
    */
    /**
     * @description
     *
     * Provides a preloading strategy.
     *
     * @publicApi
     */
    var PreloadingStrategy = /** @class */ (function () {
        function PreloadingStrategy() {
        }
        return PreloadingStrategy;
    }());
    /**
     * @description
     *
     * Provides a preloading strategy that preloads all modules as quickly as possible.
     *
     * ```
     * RouteModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})
     * ```
     *
     * @publicApi
     */
    var PreloadAllModules = /** @class */ (function () {
        function PreloadAllModules() {
        }
        PreloadAllModules.prototype.preload = function (route, fn) {
            return fn().pipe(operators.catchError(function () { return rxjs.of(null); }));
        };
        return PreloadAllModules;
    }());
    /**
     * @description
     *
     * Provides a preloading strategy that does not preload any modules.
     *
     * This strategy is enabled by default.
     *
     * @publicApi
     */
    var NoPreloading = /** @class */ (function () {
        function NoPreloading() {
        }
        NoPreloading.prototype.preload = function (route, fn) { return rxjs.of(null); };
        return NoPreloading;
    }());
    /**
     * The preloader optimistically loads all router configurations to
     * make navigations into lazily-loaded sections of the application faster.
     *
     * The preloader runs in the background. When the router bootstraps, the preloader
     * starts listening to all navigation events. After every such event, the preloader
     * will check if any configurations can be loaded lazily.
     *
     * If a route is protected by `canLoad` guards, the preloaded will not load it.
     *
     * @publicApi
     */
    var RouterPreloader = /** @class */ (function () {
        function RouterPreloader(router, moduleLoader, compiler, injector, preloadingStrategy) {
            this.router = router;
            this.injector = injector;
            this.preloadingStrategy = preloadingStrategy;
            var onStartLoad = function (r) { return router.triggerEvent(new RouteConfigLoadStart(r)); };
            var onEndLoad = function (r) { return router.triggerEvent(new RouteConfigLoadEnd(r)); };
            this.loader = new RouterConfigLoader(moduleLoader, compiler, onStartLoad, onEndLoad);
        }
        RouterPreloader.prototype.setUpPreloading = function () {
            var _this = this;
            this.subscription =
                this.router.events
                    .pipe(operators.filter(function (e) { return e instanceof NavigationEnd; }), operators.concatMap(function () { return _this.preload(); }))
                    .subscribe(function () { });
        };
        RouterPreloader.prototype.preload = function () {
            var ngModule = this.injector.get(core.NgModuleRef);
            return this.processRoutes(ngModule, this.router.config);
        };
        // TODO(jasonaden): This class relies on code external to the class to call setUpPreloading. If
        // this hasn't been done, ngOnDestroy will fail as this.subscription will be undefined. This
        // should be refactored.
        RouterPreloader.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };
        RouterPreloader.prototype.processRoutes = function (ngModule, routes) {
            var e_1, _a;
            var res = [];
            try {
                for (var routes_1 = __values(routes), routes_1_1 = routes_1.next(); !routes_1_1.done; routes_1_1 = routes_1.next()) {
                    var route = routes_1_1.value;
                    // we already have the config loaded, just recurse
                    if (route.loadChildren && !route.canLoad && route._loadedConfig) {
                        var childConfig = route._loadedConfig;
                        res.push(this.processRoutes(childConfig.module, childConfig.routes));
                        // no config loaded, fetch the config
                    }
                    else if (route.loadChildren && !route.canLoad) {
                        res.push(this.preloadConfig(ngModule, route));
                        // recurse into children
                    }
                    else if (route.children) {
                        res.push(this.processRoutes(ngModule, route.children));
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (routes_1_1 && !routes_1_1.done && (_a = routes_1.return)) _a.call(routes_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return rxjs.from(res).pipe(operators.mergeAll(), operators.map(function (_) { return void 0; }));
        };
        RouterPreloader.prototype.preloadConfig = function (ngModule, route) {
            var _this = this;
            return this.preloadingStrategy.preload(route, function () {
                var loaded$ = _this.loader.load(ngModule.injector, route);
                return loaded$.pipe(operators.mergeMap(function (config) {
                    route._loadedConfig = config;
                    return _this.processRoutes(config.module, config.routes);
                }));
            });
        };
        RouterPreloader = __decorate$1([ __metadata$1("design:paramtypes", [Router, core.NgModuleFactoryLoader, core.Compiler,
                core.Injector, PreloadingStrategy])
        ], RouterPreloader);
RouterPreloader.ɵfac = function RouterPreloader_Factory(t) { return new (t || RouterPreloader)(ɵngcc0.ɵɵinject(Router), ɵngcc0.ɵɵinject(ɵngcc0.NgModuleFactoryLoader), ɵngcc0.ɵɵinject(ɵngcc0.Compiler), ɵngcc0.ɵɵinject(ɵngcc0.Injector), ɵngcc0.ɵɵinject(PreloadingStrategy)); };
RouterPreloader.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: RouterPreloader, factory: function (t) { return RouterPreloader.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RouterPreloader, [{
        type: core.Injectable
    }], function () { return [{ type: Router }, { type: ɵngcc0.NgModuleFactoryLoader }, { type: ɵngcc0.Compiler }, { type: ɵngcc0.Injector }, { type: PreloadingStrategy }]; }, null); })();
        return RouterPreloader;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var RouterScroller = /** @class */ (function () {
        function RouterScroller(router, 
        /** @docsNotRequired */ viewportScroller, options) {
            if (options === void 0) { options = {}; }
            this.router = router;
            this.viewportScroller = viewportScroller;
            this.options = options;
            this.lastId = 0;
            this.lastSource = 'imperative';
            this.restoredId = 0;
            this.store = {};
            // Default both options to 'disabled'
            options.scrollPositionRestoration = options.scrollPositionRestoration || 'disabled';
            options.anchorScrolling = options.anchorScrolling || 'disabled';
        }
        RouterScroller.prototype.init = function () {
            // we want to disable the automatic scrolling because having two places
            // responsible for scrolling results race conditions, especially given
            // that browser don't implement this behavior consistently
            if (this.options.scrollPositionRestoration !== 'disabled') {
                this.viewportScroller.setHistoryScrollRestoration('manual');
            }
            this.routerEventsSubscription = this.createScrollEvents();
            this.scrollEventsSubscription = this.consumeScrollEvents();
        };
        RouterScroller.prototype.createScrollEvents = function () {
            var _this = this;
            return this.router.events.subscribe(function (e) {
                if (e instanceof NavigationStart) {
                    // store the scroll position of the current stable navigations.
                    _this.store[_this.lastId] = _this.viewportScroller.getScrollPosition();
                    _this.lastSource = e.navigationTrigger;
                    _this.restoredId = e.restoredState ? e.restoredState.navigationId : 0;
                }
                else if (e instanceof NavigationEnd) {
                    _this.lastId = e.id;
                    _this.scheduleScrollEvent(e, _this.router.parseUrl(e.urlAfterRedirects).fragment);
                }
            });
        };
        RouterScroller.prototype.consumeScrollEvents = function () {
            var _this = this;
            return this.router.events.subscribe(function (e) {
                if (!(e instanceof Scroll))
                    return;
                // a popstate event. The pop state event will always ignore anchor scrolling.
                if (e.position) {
                    if (_this.options.scrollPositionRestoration === 'top') {
                        _this.viewportScroller.scrollToPosition([0, 0]);
                    }
                    else if (_this.options.scrollPositionRestoration === 'enabled') {
                        _this.viewportScroller.scrollToPosition(e.position);
                    }
                    // imperative navigation "forward"
                }
                else {
                    if (e.anchor && _this.options.anchorScrolling === 'enabled') {
                        _this.viewportScroller.scrollToAnchor(e.anchor);
                    }
                    else if (_this.options.scrollPositionRestoration !== 'disabled') {
                        _this.viewportScroller.scrollToPosition([0, 0]);
                    }
                }
            });
        };
        RouterScroller.prototype.scheduleScrollEvent = function (routerEvent, anchor) {
            this.router.triggerEvent(new Scroll(routerEvent, this.lastSource === 'popstate' ? this.store[this.restoredId] : null, anchor));
        };
        RouterScroller.prototype.ngOnDestroy = function () {
            if (this.routerEventsSubscription) {
                this.routerEventsSubscription.unsubscribe();
            }
            if (this.scrollEventsSubscription) {
                this.scrollEventsSubscription.unsubscribe();
            }
        };
RouterScroller.ɵfac = function RouterScroller_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
RouterScroller.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: RouterScroller });

        return RouterScroller;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @description
     *
     * Contains a list of directives
     *
     *
     */
    var ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive, ɵEmptyOutletComponent];
    /**
     * @description
     *
     * Is used in DI to configure the router.
     *
     * @publicApi
     */
    var ROUTER_CONFIGURATION = new core.InjectionToken('ROUTER_CONFIGURATION');
    /**
     * @docsNotRequired
     */
    var ROUTER_FORROOT_GUARD = new core.InjectionToken('ROUTER_FORROOT_GUARD');
    var ɵ0 = { enableTracing: false };
    var ROUTER_PROVIDERS = [
        common.Location,
        { provide: UrlSerializer, useClass: DefaultUrlSerializer },
        {
            provide: Router,
            useFactory: setupRouter,
            deps: [
                core.ApplicationRef, UrlSerializer, ChildrenOutletContexts, common.Location, core.Injector,
                core.NgModuleFactoryLoader, core.Compiler, ROUTES, ROUTER_CONFIGURATION,
                [UrlHandlingStrategy, new core.Optional()], [RouteReuseStrategy, new core.Optional()]
            ]
        },
        ChildrenOutletContexts,
        { provide: ActivatedRoute, useFactory: rootRoute, deps: [Router] },
        { provide: core.NgModuleFactoryLoader, useClass: core.SystemJsNgModuleLoader },
        RouterPreloader,
        NoPreloading,
        PreloadAllModules,
        { provide: ROUTER_CONFIGURATION, useValue: ɵ0 },
    ];
    function routerNgProbeToken() {
        return new core.NgProbeToken('Router', Router);
    }
    /**
     * @usageNotes
     *
     * RouterModule can be imported multiple times: once per lazily-loaded bundle.
     * Since the router deals with a global shared resource--location, we cannot have
     * more than one router service active.
     *
     * That is why there are two ways to create the module: `RouterModule.forRoot` and
     * `RouterModule.forChild`.
     *
     * * `forRoot` creates a module that contains all the directives, the given routes, and the router
     *   service itself.
     * * `forChild` creates a module that contains all the directives and the given routes, but does not
     *   include the router service.
     *
     * When registered at the root, the module should be used as follows
     *
     * ```
     * @NgModule({
     *   imports: [RouterModule.forRoot(ROUTES)]
     * })
     * class MyNgModule {}
     * ```
     *
     * For submodules and lazy loaded submodules the module should be used as follows:
     *
     * ```
     * @NgModule({
     *   imports: [RouterModule.forChild(ROUTES)]
     * })
     * class MyNgModule {}
     * ```
     *
     * @description
     *
     * Adds router directives and providers.
     *
     * Managing state transitions is one of the hardest parts of building applications. This is
     * especially true on the web, where you also need to ensure that the state is reflected in the URL.
     * In addition, we often want to split applications into multiple bundles and load them on demand.
     * Doing this transparently is not trivial.
     *
     * The Angular router solves these problems. Using the router, you can declaratively specify
     * application states, manage state transitions while taking care of the URL, and load bundles on
     * demand.
     *
     * [Read this developer guide](https://angular.io/docs/ts/latest/guide/router.html) to get an
     * overview of how the router should be used.
     *
     * @publicApi
     */
    var RouterModule = /** @class */ (function () {
        // Note: We are injecting the Router so it gets created eagerly...
        function RouterModule(guard, router) {
        }
        RouterModule_1 = RouterModule;
        /**
         * Creates a module with all the router providers and directives. It also optionally sets up an
         * application listener to perform an initial navigation.
         *
         * Configuration Options:
         *
         * * `enableTracing` Toggles whether the router should log all navigation events to the console.
         * * `useHash` Enables the location strategy that uses the URL fragment instead of the history
         * API.
         * * `initialNavigation` Disables the initial navigation.
         * * `errorHandler` Defines a custom error handler for failed navigations.
         * * `preloadingStrategy` Configures a preloading strategy. See `PreloadAllModules`.
         * * `onSameUrlNavigation` Define what the router should do if it receives a navigation request to
         * the current URL.
         * * `scrollPositionRestoration` Configures if the scroll position needs to be restored when
         * navigating back.
         * * `anchorScrolling` Configures if the router should scroll to the element when the url has a
         * fragment.
         * * `scrollOffset` Configures the scroll offset the router will use when scrolling to an element.
         * * `paramsInheritanceStrategy` Defines how the router merges params, data and resolved data from
         * parent to child routes.
         * * `malformedUriErrorHandler` Defines a custom malformed uri error handler function. This
         * handler is invoked when encodedURI contains invalid character sequences.
         * * `urlUpdateStrategy` Defines when the router updates the browser URL. The default behavior is
         * to update after successful navigation.
         * * `relativeLinkResolution` Enables the correct relative link resolution in components with
         * empty paths.
         *
         * See `ExtraOptions` for more details about the above options.
        */
        RouterModule.forRoot = function (routes, config) {
            return {
                ngModule: RouterModule_1,
                providers: [
                    ROUTER_PROVIDERS,
                    provideRoutes(routes),
                    {
                        provide: ROUTER_FORROOT_GUARD,
                        useFactory: provideForRootGuard,
                        deps: [[Router, new core.Optional(), new core.SkipSelf()]]
                    },
                    { provide: ROUTER_CONFIGURATION, useValue: config ? config : {} },
                    {
                        provide: common.LocationStrategy,
                        useFactory: provideLocationStrategy,
                        deps: [
                            common.PlatformLocation, [new core.Inject(common.APP_BASE_HREF), new core.Optional()], ROUTER_CONFIGURATION
                        ]
                    },
                    {
                        provide: RouterScroller,
                        useFactory: createRouterScroller,
                        deps: [Router, common.ViewportScroller, ROUTER_CONFIGURATION]
                    },
                    {
                        provide: PreloadingStrategy,
                        useExisting: config && config.preloadingStrategy ? config.preloadingStrategy :
                            NoPreloading
                    },
                    { provide: core.NgProbeToken, multi: true, useFactory: routerNgProbeToken },
                    provideRouterInitializer(),
                ],
            };
        };
        /**
         * Creates a module with all the router directives and a provider registering routes.
         */
        RouterModule.forChild = function (routes) {
            return { ngModule: RouterModule_1, providers: [provideRoutes(routes)] };
        };
        var RouterModule_1;
        RouterModule = RouterModule_1 = __decorate$1([ __param$1(0, core.Optional()), __param$1(0, core.Inject(ROUTER_FORROOT_GUARD)), __param$1(1, core.Optional()),
            __metadata$1("design:paramtypes", [Object, Router])
        ], RouterModule);
RouterModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: RouterModule });
RouterModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function RouterModule_Factory(t) { return new (t || RouterModule)(ɵngcc0.ɵɵinject(ROUTER_FORROOT_GUARD, 8), ɵngcc0.ɵɵinject(Router, 8)); } });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(RouterModule, { declarations: [RouterOutlet,
        RouterLink,
        RouterLinkWithHref,
        RouterLinkActive,
        ɵEmptyOutletComponent], exports: [RouterOutlet,
        RouterLink,
        RouterLinkWithHref,
        RouterLinkActive,
        ɵEmptyOutletComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RouterModule, [{
        type: core.NgModule,
        args: [{
                declarations: ROUTER_DIRECTIVES,
                exports: ROUTER_DIRECTIVES,
                entryComponents: [ɵEmptyOutletComponent]
            }]
    }], function () { return [{ type: Object, decorators: [{
                type: core.Optional
            }, {
                type: core.Inject,
                args: [ROUTER_FORROOT_GUARD]
            }] }, { type: Router, decorators: [{
                type: core.Optional
            }] }]; }, null); })();
        return RouterModule;
    }());
    function createRouterScroller(router, viewportScroller, config) {
        if (config.scrollOffset) {
            viewportScroller.setOffset(config.scrollOffset);
        }
        return new RouterScroller(router, viewportScroller, config);
    }
    function provideLocationStrategy(platformLocationStrategy, baseHref, options) {
        if (options === void 0) { options = {}; }
        return options.useHash ? new common.HashLocationStrategy(platformLocationStrategy, baseHref) :
            new common.PathLocationStrategy(platformLocationStrategy, baseHref);
    }
    function provideForRootGuard(router) {
        if (router) {
            throw new Error("RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.");
        }
        return 'guarded';
    }
    /**
     * @description
     *
     * Registers routes.
     *
     * @usageNotes
     * ### Example
     *
     * ```
     * @NgModule({
     *   imports: [RouterModule.forChild(ROUTES)],
     *   providers: [provideRoutes(EXTRA_ROUTES)]
     * })
     * class MyNgModule {}
     * ```
     *
     * @publicApi
     */
    function provideRoutes(routes) {
        return [
            { provide: core.ANALYZE_FOR_ENTRY_COMPONENTS, multi: true, useValue: routes },
            { provide: ROUTES, multi: true, useValue: routes },
        ];
    }
    function setupRouter(ref, urlSerializer, contexts, location, injector, loader, compiler, config, opts, urlHandlingStrategy, routeReuseStrategy) {
        if (opts === void 0) { opts = {}; }
        var router = new Router(null, urlSerializer, contexts, location, injector, loader, compiler, flatten(config));
        if (urlHandlingStrategy) {
            router.urlHandlingStrategy = urlHandlingStrategy;
        }
        if (routeReuseStrategy) {
            router.routeReuseStrategy = routeReuseStrategy;
        }
        if (opts.errorHandler) {
            router.errorHandler = opts.errorHandler;
        }
        if (opts.malformedUriErrorHandler) {
            router.malformedUriErrorHandler = opts.malformedUriErrorHandler;
        }
        if (opts.enableTracing) {
            var dom_1 = platformBrowser.ɵgetDOM();
            router.events.subscribe(function (e) {
                dom_1.logGroup("Router Event: " + e.constructor.name);
                dom_1.log(e.toString());
                dom_1.log(e);
                dom_1.logGroupEnd();
            });
        }
        if (opts.onSameUrlNavigation) {
            router.onSameUrlNavigation = opts.onSameUrlNavigation;
        }
        if (opts.paramsInheritanceStrategy) {
            router.paramsInheritanceStrategy = opts.paramsInheritanceStrategy;
        }
        if (opts.urlUpdateStrategy) {
            router.urlUpdateStrategy = opts.urlUpdateStrategy;
        }
        if (opts.relativeLinkResolution) {
            router.relativeLinkResolution = opts.relativeLinkResolution;
        }
        return router;
    }
    function rootRoute(router) {
        return router.routerState.root;
    }
    /**
     * To initialize the router properly we need to do in two steps:
     *
     * We need to start the navigation in a APP_INITIALIZER to block the bootstrap if
     * a resolver or a guards executes asynchronously. Second, we need to actually run
     * activation in a BOOTSTRAP_LISTENER. We utilize the afterPreactivation
     * hook provided by the router to do that.
     *
     * The router navigation starts, reaches the point when preactivation is done, and then
     * pauses. It waits for the hook to be resolved. We then resolve it only in a bootstrap listener.
     */
    var RouterInitializer = /** @class */ (function () {
        function RouterInitializer(injector) {
            this.injector = injector;
            this.initNavigation = false;
            this.resultOfPreactivationDone = new rxjs.Subject();
        }
        RouterInitializer.prototype.appInitializer = function () {
            var _this = this;
            var p = this.injector.get(common.LOCATION_INITIALIZED, Promise.resolve(null));
            return p.then(function () {
                var resolve = null;
                var res = new Promise(function (r) { return resolve = r; });
                var router = _this.injector.get(Router);
                var opts = _this.injector.get(ROUTER_CONFIGURATION);
                if (_this.isLegacyDisabled(opts) || _this.isLegacyEnabled(opts)) {
                    resolve(true);
                }
                else if (opts.initialNavigation === 'disabled') {
                    router.setUpLocationChangeListener();
                    resolve(true);
                }
                else if (opts.initialNavigation === 'enabled') {
                    router.hooks.afterPreactivation = function () {
                        // only the initial navigation should be delayed
                        if (!_this.initNavigation) {
                            _this.initNavigation = true;
                            resolve(true);
                            return _this.resultOfPreactivationDone;
                            // subsequent navigations should not be delayed
                        }
                        else {
                            return rxjs.of(null);
                        }
                    };
                    router.initialNavigation();
                }
                else {
                    throw new Error("Invalid initialNavigation options: '" + opts.initialNavigation + "'");
                }
                return res;
            });
        };
        RouterInitializer.prototype.bootstrapListener = function (bootstrappedComponentRef) {
            var opts = this.injector.get(ROUTER_CONFIGURATION);
            var preloader = this.injector.get(RouterPreloader);
            var routerScroller = this.injector.get(RouterScroller);
            var router = this.injector.get(Router);
            var ref = this.injector.get(core.ApplicationRef);
            if (bootstrappedComponentRef !== ref.components[0]) {
                return;
            }
            if (this.isLegacyEnabled(opts)) {
                router.initialNavigation();
            }
            else if (this.isLegacyDisabled(opts)) {
                router.setUpLocationChangeListener();
            }
            preloader.setUpPreloading();
            routerScroller.init();
            router.resetRootComponentType(ref.componentTypes[0]);
            this.resultOfPreactivationDone.next(null);
            this.resultOfPreactivationDone.complete();
        };
        RouterInitializer.prototype.isLegacyEnabled = function (opts) {
            return opts.initialNavigation === 'legacy_enabled' || opts.initialNavigation === true ||
                opts.initialNavigation === undefined;
        };
        RouterInitializer.prototype.isLegacyDisabled = function (opts) {
            return opts.initialNavigation === 'legacy_disabled' || opts.initialNavigation === false;
        };
        RouterInitializer = __decorate$1([ __metadata$1("design:paramtypes", [core.Injector])
        ], RouterInitializer);
RouterInitializer.ɵfac = function RouterInitializer_Factory(t) { return new (t || RouterInitializer)(ɵngcc0.ɵɵinject(ɵngcc0.Injector)); };
RouterInitializer.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: RouterInitializer, factory: function (t) { return RouterInitializer.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RouterInitializer, [{
        type: core.Injectable
    }], function () { return [{ type: ɵngcc0.Injector }]; }, null); })();
        return RouterInitializer;
    }());
    function getAppInitializer(r) {
        return r.appInitializer.bind(r);
    }
    function getBootstrapListener(r) {
        return r.bootstrapListener.bind(r);
    }
    /**
     * A token for the router initializer that will be called after the app is bootstrapped.
     *
     * @publicApi
     */
    var ROUTER_INITIALIZER = new core.InjectionToken('Router Initializer');
    function provideRouterInitializer() {
        return [
            RouterInitializer,
            {
                provide: core.APP_INITIALIZER,
                multi: true,
                useFactory: getAppInitializer,
                deps: [RouterInitializer]
            },
            { provide: ROUTER_INITIALIZER, useFactory: getBootstrapListener, deps: [RouterInitializer] },
            { provide: core.APP_BOOTSTRAP_LISTENER, multi: true, useExisting: ROUTER_INITIALIZER },
        ];
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @publicApi
     */
    var VERSION = new core.Version('8.0.0');

    var __assign$2 = (undefined && undefined.__assign) || function () {
        __assign$2 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$2.apply(this, arguments);
    };
    var __decorate$2 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$2 = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var __param$2 = (undefined && undefined.__param) || function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };
    var FIREBASE_EVENT_ORIGIN_KEY = 'firebase_event_origin';
    var FIREBASE_PREVIOUS_SCREEN_CLASS_KEY = 'firebase_previous_class';
    var FIREBASE_PREVIOUS_SCREEN_INSTANCE_ID_KEY = 'firebase_previous_id';
    var FIREBASE_PREVIOUS_SCREEN_NAME_KEY = 'firebase_previous_screen';
    var FIREBASE_SCREEN_CLASS_KEY = 'firebase_screen_class';
    var FIREBASE_SCREEN_INSTANCE_ID_KEY = 'firebase_screen_id';
    var FIREBASE_SCREEN_NAME_KEY = 'firebase_screen';
    var OUTLET_KEY = 'outlet';
    var PAGE_PATH_KEY = 'page_path';
    var PAGE_TITLE_KEY = 'page_title';
    var SCREEN_CLASS_KEY = 'screen_class';
    var SCREEN_NAME_KEY = 'screen_name';
    var SCREEN_VIEW_EVENT = 'screen_view';
    var EVENT_ORIGIN_AUTO = 'auto';
    var DEFAULT_SCREEN_CLASS = '???';
    var NG_PRIMARY_OUTLET = 'primary';
    var SCREEN_INSTANCE_DELIMITER = '#';
    var ANNOTATIONS = '__annotations__';
    var ScreenTrackingService = (function () {
        function ScreenTrackingService(analytics, router, title, componentFactoryResolver, platformId, debugModeEnabled, zone, injector) {
            var _this = this;
            if (!router || !common.isPlatformBrowser(platformId)) {
                return this;
            }
            zone.runOutsideAngular(function () {
                var activationEndEvents = router.events.pipe(operators.filter(function (e) { return e instanceof ActivationEnd; }));
                var navigationEndEvents = router.events.pipe(operators.filter(function (e) { return e instanceof NavigationEnd; }));
                _this.disposable = navigationEndEvents.pipe(operators.withLatestFrom(activationEndEvents), operators.switchMap(function (_a) {
                    var _b, _c, _d, _e, _f;
                    var navigationEnd = _a[0], activationEnd = _a[1];
                    var page_path = navigationEnd.url;
                    var screen_name = activationEnd.snapshot.routeConfig && activationEnd.snapshot.routeConfig.path || page_path;
                    var params = (_b = {},
                        _b[SCREEN_NAME_KEY] = screen_name,
                        _b[PAGE_PATH_KEY] = page_path,
                        _b[FIREBASE_EVENT_ORIGIN_KEY] = EVENT_ORIGIN_AUTO,
                        _b[FIREBASE_SCREEN_NAME_KEY] = screen_name,
                        _b[OUTLET_KEY] = activationEnd.snapshot.outlet,
                        _b);
                    if (title) {
                        params[PAGE_TITLE_KEY] = title.getTitle();
                    }
                    var component = activationEnd.snapshot.component;
                    var routeConfig = activationEnd.snapshot.routeConfig;
                    var loadChildren = routeConfig && routeConfig.loadChildren;
                    if (typeof loadChildren === "string") {
                        return rxjs.of(__assign$2({}, params, (_c = {}, _c[SCREEN_CLASS_KEY] = loadChildren.split('#')[1], _c)));
                    }
                    else if (typeof component === 'string') {
                        return rxjs.of(__assign$2({}, params, (_d = {}, _d[SCREEN_CLASS_KEY] = component, _d)));
                    }
                    else if (component) {
                        var componentFactory = componentFactoryResolver.resolveComponentFactory(component);
                        return rxjs.of(__assign$2({}, params, (_e = {}, _e[SCREEN_CLASS_KEY] = componentFactory.selector, _e)));
                    }
                    else if (loadChildren) {
                        var loadedChildren = loadChildren();
                        var loadedChildren$ = (loadedChildren instanceof rxjs.Observable) ? loadedChildren : rxjs.from(Promise.resolve(loadedChildren));
                        return loadedChildren$.pipe(operators.map(function (lazyModule) {
                            var _a, _b, _c;
                            if (lazyModule instanceof core.NgModuleFactory) {
                                var moduleRef = lazyModule.create(injector);
                                var routes = moduleRef.injector.get(ROUTES);
                                var component_1 = routes[0][0].component;
                                try {
                                    var componentFactory = moduleRef.componentFactoryResolver.resolveComponentFactory(component_1);
                                    return __assign$2({}, params, (_a = {}, _a[SCREEN_CLASS_KEY] = componentFactory.selector, _a));
                                }
                                catch (_) {
                                    return __assign$2({}, params, (_b = {}, _b[SCREEN_CLASS_KEY] = DEFAULT_SCREEN_CLASS, _b));
                                }
                            }
                            else {
                                var declarations = [].concat.apply([], (lazyModule[ANNOTATIONS] || []).map(function (f) { return f.declarations; }));
                                var selectors = [].concat.apply([], declarations.map(function (c) { return (c[ANNOTATIONS] || []).map(function (f) { return f.selector; }); }));
                                return __assign$2({}, params, (_c = {}, _c[SCREEN_CLASS_KEY] = selectors[0] || DEFAULT_SCREEN_CLASS, _c));
                            }
                        }));
                    }
                    else {
                        return rxjs.of(__assign$2({}, params, (_f = {}, _f[SCREEN_CLASS_KEY] = DEFAULT_SCREEN_CLASS, _f)));
                    }
                }), operators.map(function (params) {
                    var _a;
                    return (__assign$2((_a = {}, _a[FIREBASE_SCREEN_CLASS_KEY] = params[SCREEN_CLASS_KEY], _a[FIREBASE_SCREEN_INSTANCE_ID_KEY] = getScreenInstanceID(params), _a), params));
                }), operators.tap(function (params) {
                    var _a, _b;
                    if (params[OUTLET_KEY] == NG_PRIMARY_OUTLET) {
                        analytics.setCurrentScreen(params[SCREEN_NAME_KEY]);
                        analytics.updateConfig((_a = {},
                            _a[PAGE_PATH_KEY] = params[PAGE_PATH_KEY],
                            _a[SCREEN_CLASS_KEY] = params[SCREEN_CLASS_KEY],
                            _a));
                        if (title) {
                            analytics.updateConfig((_b = {}, _b[PAGE_TITLE_KEY] = params[PAGE_TITLE_KEY], _b));
                        }
                    }
                }), operators.groupBy(function (params) { return params[OUTLET_KEY]; }), operators.mergeMap(function (group) { return group.pipe(operators.startWith(undefined), operators.pairwise()); }), operators.map(function (_a) {
                    var _b;
                    var prior = _a[0], current = _a[1];
                    return prior ? __assign$2((_b = {}, _b[FIREBASE_PREVIOUS_SCREEN_CLASS_KEY] = prior[SCREEN_CLASS_KEY], _b[FIREBASE_PREVIOUS_SCREEN_NAME_KEY] = prior[SCREEN_NAME_KEY], _b[FIREBASE_PREVIOUS_SCREEN_INSTANCE_ID_KEY] = prior[FIREBASE_SCREEN_INSTANCE_ID_KEY], _b), current) : current;
                }), operators.tap(function (params) { return debugModeEnabled && console.info(SCREEN_VIEW_EVENT, params); }), operators.tap(function (params) { return zone.runOutsideAngular(function () { return analytics.logEvent(SCREEN_VIEW_EVENT, params); }); })).subscribe();
            });
        }
        ScreenTrackingService.prototype.ngOnDestroy = function () {
            if (this.disposable) {
                this.disposable.unsubscribe();
            }
        };
        ScreenTrackingService = __decorate$2([ __param$2(1, core.Optional()),
            __param$2(2, core.Optional()),
            __param$2(4, core.Inject(core.PLATFORM_ID)),
            __param$2(5, core.Optional()), __param$2(5, core.Inject(DEBUG_MODE)),
            __metadata$2("design:paramtypes", [AngularFireAnalytics,
                Router,
                platformBrowser.Title,
                core.ComponentFactoryResolver,
                Object, Object, core.NgZone,
                core.Injector])
        ], ScreenTrackingService);
ScreenTrackingService.ɵfac = function ScreenTrackingService_Factory(t) { return new (t || ScreenTrackingService)(ɵngcc0.ɵɵinject(AngularFireAnalytics), ɵngcc0.ɵɵinject(Router, 8), ɵngcc0.ɵɵinject(ɵngcc2.Title, 8), ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinject(core.PLATFORM_ID), ɵngcc0.ɵɵinject(DEBUG_MODE, 8), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(ɵngcc0.Injector)); };
ScreenTrackingService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ScreenTrackingService, factory: function (t) { return ScreenTrackingService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ScreenTrackingService, [{
        type: core.Injectable
    }], function () { return [{ type: AngularFireAnalytics }, { type: Router, decorators: [{
                type: core.Optional
            }] }, { type: ɵngcc2.Title, decorators: [{
                type: core.Optional
            }] }, { type: ɵngcc0.ComponentFactoryResolver }, { type: Object, decorators: [{
                type: core.Inject,
                args: [core.PLATFORM_ID]
            }] }, { type: Object, decorators: [{
                type: core.Optional
            }, {
                type: core.Inject,
                args: [DEBUG_MODE]
            }] }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Injector }]; }, null); })();
        return ScreenTrackingService;
    }());
    var UserTrackingService = (function () {
        function UserTrackingService(analytics, zone, platformId) {
            var _this = this;
            var schedulers = new fire.ɵAngularFireSchedulers(zone);
            if (!common.isPlatformServer(platformId)) {
                zone.runOutsideAngular(function () {
                    _this.disposable = rxjs.from(import('firebase/auth')).pipe(operators.observeOn(schedulers.outsideAngular), operators.switchMap(function () { return analytics.app; }), operators.map(function (app) { return app.auth(); }), operators.switchMap(function (auth) { return new rxjs.Observable(auth.onAuthStateChanged.bind(auth)); }), operators.switchMap(function (user) { return analytics.setUserId(user ? user.uid : null); })).subscribe();
                });
            }
        }
        UserTrackingService.prototype.ngOnDestroy = function () {
            if (this.disposable) {
                this.disposable.unsubscribe();
            }
        };
        UserTrackingService = __decorate$2([ __param$2(2, core.Inject(core.PLATFORM_ID)),
            __metadata$2("design:paramtypes", [AngularFireAnalytics,
                core.NgZone,
                Object])
        ], UserTrackingService);
UserTrackingService.ɵfac = function UserTrackingService_Factory(t) { return new (t || UserTrackingService)(ɵngcc0.ɵɵinject(AngularFireAnalytics), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(core.PLATFORM_ID)); };
UserTrackingService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: UserTrackingService, factory: function (t) { return UserTrackingService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(UserTrackingService, [{
        type: core.Injectable
    }], function () { return [{ type: AngularFireAnalytics }, { type: ɵngcc0.NgZone }, { type: Object, decorators: [{
                type: core.Inject,
                args: [core.PLATFORM_ID]
            }] }]; }, null); })();
        return UserTrackingService;
    }());
    var nextScreenInstanceID = Math.floor(Math.random() * (Math.pow(2, 32) - 1)) - Math.pow(2, 31);
    var knownScreenInstanceIDs = {};
    var getScreenInstanceID = function (params) {
        var screenInstanceKey = [
            params[SCREEN_CLASS_KEY],
            params[OUTLET_KEY]
        ].join(SCREEN_INSTANCE_DELIMITER);
        if (knownScreenInstanceIDs.hasOwnProperty(screenInstanceKey)) {
            return knownScreenInstanceIDs[screenInstanceKey];
        }
        else {
            var ret = nextScreenInstanceID++;
            knownScreenInstanceIDs[screenInstanceKey] = ret;
            return ret;
        }
    };
    var ɵ0$1 = getScreenInstanceID;

    var __decorate$3 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$3 = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var __param$3 = (undefined && undefined.__param) || function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };
    var AngularFireAnalyticsModule = (function () {
        function AngularFireAnalyticsModule(analytics, screenTracking, userTracking) {
            analytics.app;
        }
        AngularFireAnalyticsModule = __decorate$3([ __param$3(1, core.Optional()),
            __param$3(2, core.Optional()),
            __metadata$3("design:paramtypes", [AngularFireAnalytics,
                ScreenTrackingService,
                UserTrackingService])
        ], AngularFireAnalyticsModule);
AngularFireAnalyticsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: AngularFireAnalyticsModule });
AngularFireAnalyticsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function AngularFireAnalyticsModule_Factory(t) { return new (t || AngularFireAnalyticsModule)(ɵngcc0.ɵɵinject(AngularFireAnalytics), ɵngcc0.ɵɵinject(ScreenTrackingService, 8), ɵngcc0.ɵɵinject(UserTrackingService, 8)); }, providers: [AngularFireAnalytics] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AngularFireAnalyticsModule, [{
        type: core.NgModule,
        args: [{
                providers: [AngularFireAnalytics]
            }]
    }], function () { return [{ type: AngularFireAnalytics }, { type: ScreenTrackingService, decorators: [{
                type: core.Optional
            }] }, { type: UserTrackingService, decorators: [{
                type: core.Optional
            }] }]; }, null); })();
        return AngularFireAnalyticsModule;
    }());

    exports.COLLECTION_ENABLED = COLLECTION_ENABLED;
    exports.APP_VERSION = APP_VERSION;
    exports.APP_NAME = APP_NAME;
    exports.DEBUG_MODE = DEBUG_MODE;
    exports.CONFIG = CONFIG;
    exports.AngularFireAnalytics = AngularFireAnalytics;
    exports.AngularFireAnalyticsModule = AngularFireAnalyticsModule;
    exports.ScreenTrackingService = ScreenTrackingService;
    exports.UserTrackingService = UserTrackingService;
    exports.ɵ0 = ɵ0$1;

    Object.defineProperty(exports, '__esModule', { value: true });
exports.RouterOutlet = RouterOutlet;
exports.RouterLink = RouterLink;
exports.RouterLinkWithHref = RouterLinkWithHref;
exports.RouterLinkActive = RouterLinkActive;
exports.ɵEmptyOutletComponent = ɵEmptyOutletComponent;

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5hbHl0aWNzLnVtZC5qcyIsInNvdXJjZXMiOlsiYW5hbHl0aWNzLnVtZC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtvS0FDMkU7dUhBQ2xCO3VFQUM1Qzt3Q0FDTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJDQW9Jd0IsQUFFaEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyREFVc0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1NBb2lCeEI7Ozs7Ozs7O2dEQUd5Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK3pIeEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttQ0FxTnlCLEFBRXhCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUVZOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MkNBdUlvQixBQUVoQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBRW9COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5Q0F3SlUsQUFLOUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUtrQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxQ0ErTlEsQUFFMUI7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFHYzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dDQXNKZSxBQUU3Qjs7Ozs7Ozs0TEFFaUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0ZsQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7c0RBc0w0QyxBQU0zQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrQ0FFYzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQ0FzS2lCLEFBRS9COzs7Ozs7eUVBQ21COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4Q0E2S2dCLEFBRW5DOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7c0ZBVXVCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7NENBa0JVLEFBRWpDOzs7Ozs7Ozs7Ozs7a0NBSXFCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O21EQXFDbUIsQUFJeEM7Ozs7Ozs7Ozs7Ozs7Ozs7O2tDQUs0Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7c0RBZTJCIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKSwgcmVxdWlyZSgncnhqcycpLCByZXF1aXJlKCdAYW5ndWxhci9jb21tb24nKSwgcmVxdWlyZSgncnhqcy9vcGVyYXRvcnMnKSwgcmVxdWlyZSgnQGFuZ3VsYXIvZmlyZScpLCByZXF1aXJlKCdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJykpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ0Bhbmd1bGFyL2NvcmUnLCAncnhqcycsICdAYW5ndWxhci9jb21tb24nLCAncnhqcy9vcGVyYXRvcnMnLCAnQGFuZ3VsYXIvZmlyZScsICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJ10sIGZhY3RvcnkpIDpcbiAgICAoZmFjdG9yeSgoZ2xvYmFsLmFuZ3VsYXJmaXJlMiA9IGdsb2JhbC5hbmd1bGFyZmlyZTIgfHwge30sIGdsb2JhbC5hbmd1bGFyZmlyZTIuYW5hbHl0aWNzID0ge30pLGdsb2JhbC5uZy5jb3JlLGdsb2JhbC5yeGpzLGdsb2JhbC5uZy5jb21tb24sZ2xvYmFsLnJ4anMub3BlcmF0b3JzLGdsb2JhbC5hbmd1bGFyZmlyZTIsZ2xvYmFsLm5nLnBsYXRmb3JtQnJvd3NlcikpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsY29yZSxyeGpzLGNvbW1vbixvcGVyYXRvcnMsZmlyZSxwbGF0Zm9ybUJyb3dzZXIpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIF9fYXNzaWduID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIHZhciBfX2RlY29yYXRlID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gICAgfTtcbiAgICB2YXIgX19tZXRhZGF0YSA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbiAgICB9O1xuICAgIHZhciBfX3BhcmFtID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbiAgICB9O1xuICAgIHZhciBfX2F3YWl0ZXIgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdmFyIF9fZ2VuZXJhdG9yID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIENPTExFQ1RJT05fRU5BQkxFRCA9IG5ldyBjb3JlLkluamVjdGlvblRva2VuKCdhbmd1bGFyZmlyZTIuYW5hbHl0aWNzLmFuYWx5dGljc0NvbGxlY3Rpb25FbmFibGVkJyk7XG4gICAgdmFyIEFQUF9WRVJTSU9OID0gbmV3IGNvcmUuSW5qZWN0aW9uVG9rZW4oJ2FuZ3VsYXJmaXJlMi5hbmFseXRpY3MuYXBwVmVyc2lvbicpO1xuICAgIHZhciBBUFBfTkFNRSA9IG5ldyBjb3JlLkluamVjdGlvblRva2VuKCdhbmd1bGFyZmlyZTIuYW5hbHl0aWNzLmFwcE5hbWUnKTtcbiAgICB2YXIgREVCVUdfTU9ERSA9IG5ldyBjb3JlLkluamVjdGlvblRva2VuKCdhbmd1bGFyZmlyZTIuYW5hbHl0aWNzLmRlYnVnTW9kZScpO1xuICAgIHZhciBDT05GSUcgPSBuZXcgY29yZS5JbmplY3Rpb25Ub2tlbignYW5ndWxhcmZpcmUyLmFuYWx5dGljcy5jb25maWcnKTtcbiAgICB2YXIgQVBQX05BTUVfS0VZID0gJ2FwcF9uYW1lJztcbiAgICB2YXIgQVBQX1ZFUlNJT05fS0VZID0gJ2FwcF92ZXJzaW9uJztcbiAgICB2YXIgREVCVUdfTU9ERV9LRVkgPSAnZGVidWdfbW9kZSc7XG4gICAgdmFyIEFOQUxZVElDU19JRF9GSUVMRCA9ICdtZWFzdXJlbWVudElkJztcbiAgICB2YXIgR1RBR19DT05GSUdfQ09NTUFORCA9ICdjb25maWcnO1xuICAgIHZhciBHVEFHX0ZVTkNUSU9OX05BTUUgPSAnZ3RhZyc7XG4gICAgdmFyIERBVEFfTEFZRVJfTkFNRSA9ICdkYXRhTGF5ZXInO1xuICAgIHZhciBBbmd1bGFyRmlyZUFuYWx5dGljcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuZ3VsYXJGaXJlQW5hbHl0aWNzKG9wdGlvbnMsIG5hbWVPckNvbmZpZywgYW5hbHl0aWNzQ29sbGVjdGlvbkVuYWJsZWQsIHByb3ZpZGVkQXBwVmVyc2lvbiwgcHJvdmlkZWRBcHBOYW1lLCBkZWJ1Z01vZGVFbmFibGVkLCBwcm92aWRlZENvbmZpZywgcGxhdGZvcm1JZCwgem9uZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgIHZhciBzY2hlZHVsZXJzID0gbmV3IGZpcmUuybVBbmd1bGFyRmlyZVNjaGVkdWxlcnMoem9uZSk7XG4gICAgICAgICAgICBpZiAoY29tbW9uLmlzUGxhdGZvcm1Ccm93c2VyKHBsYXRmb3JtSWQpKSB7XG4gICAgICAgICAgICAgICAgd2luZG93W0RBVEFfTEFZRVJfTkFNRV0gPSB3aW5kb3dbREFUQV9MQVlFUl9OQU1FXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmd0YWcgPSB3aW5kb3dbR1RBR19GVU5DVElPTl9OQU1FXSB8fCBmdW5jdGlvbiAoKSB7IHdpbmRvd1tEQVRBX0xBWUVSX05BTUVdLnB1c2goYXJndW1lbnRzKTsgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmFuYWx5dGljc0luaXRpYWxpemVkID0gem9uZS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93W0dUQUdfRlVOQ1RJT05fTkFNRV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdzWzBdID09ICdqcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5ndGFnLmFwcGx5KF90aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmFseXRpY3NJbml0aWFsaXplZCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3RhZyA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm92aWRlZENvbmZpZykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ29uZmlnKHByb3ZpZGVkQ29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm92aWRlZEFwcE5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbmZpZygoX2EgPSB7fSwgX2FbQVBQX05BTUVfS0VZXSA9IHByb3ZpZGVkQXBwTmFtZSwgX2EpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm92aWRlZEFwcFZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbmZpZygoX2IgPSB7fSwgX2JbQVBQX1ZFUlNJT05fS0VZXSA9IHByb3ZpZGVkQXBwVmVyc2lvbiwgX2IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWJ1Z01vZGVFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDb25maWcoKF9jID0ge30sIF9jW0RFQlVHX01PREVfS0VZXSA9IDEsIF9jKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYW5hbHl0aWNzID0gcnhqcy5vZih1bmRlZmluZWQpLnBpcGUob3BlcmF0b3JzLm9ic2VydmVPbihzY2hlZHVsZXJzLm91dHNpZGVBbmd1bGFyKSwgb3BlcmF0b3JzLnN3aXRjaE1hcChmdW5jdGlvbiAoKSB7IHJldHVybiByeGpzLmVtcHR5KCk7IH0pLCBvcGVyYXRvcnMubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZpcmUuX2ZpcmViYXNlQXBwRmFjdG9yeShvcHRpb25zLCB6b25lLCBuYW1lT3JDb25maWcpOyB9KSwgb3BlcmF0b3JzLm1hcChmdW5jdGlvbiAoYXBwKSB7IHJldHVybiBhcHAuYW5hbHl0aWNzKCk7IH0pLCBvcGVyYXRvcnMudGFwKGZ1bmN0aW9uIChhbmFseXRpY3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoYW5hbHl0aWNzQ29sbGVjdGlvbkVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuYWx5dGljcy5zZXRBbmFseXRpY3NDb2xsZWN0aW9uRW5hYmxlZChmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksIG9wZXJhdG9ycy5zaGFyZVJlcGxheSh7IGJ1ZmZlclNpemU6IDEsIHJlZkNvdW50OiBmYWxzZSB9KSk7XG4gICAgICAgICAgICByZXR1cm4gZmlyZS7JtWxhenlTREtQcm94eSh0aGlzLCBhbmFseXRpY3MsIHpvbmUpO1xuICAgICAgICB9XG4gICAgICAgIEFuZ3VsYXJGaXJlQW5hbHl0aWNzLnByb3RvdHlwZS51cGRhdGVDb25maWcgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgdGhpcy5hbmFseXRpY3NJbml0aWFsaXplZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3RhZyhHVEFHX0NPTkZJR19DT01NQU5ELCB0aGlzLm9wdGlvbnNbQU5BTFlUSUNTX0lEX0ZJRUxEXSwgX19hc3NpZ24oe30sIGNvbmZpZywgeyB1cGRhdGU6IHRydWUgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBBbmd1bGFyRmlyZUFuYWx5dGljcyA9IF9fZGVjb3JhdGUoW1xuICAgICAgICAgICAgY29yZS5JbmplY3RhYmxlKCksXG4gICAgICAgICAgICBfX3BhcmFtKDAsIGNvcmUuSW5qZWN0KGZpcmUuRklSRUJBU0VfT1BUSU9OUykpLFxuICAgICAgICAgICAgX19wYXJhbSgxLCBjb3JlLk9wdGlvbmFsKCkpLCBfX3BhcmFtKDEsIGNvcmUuSW5qZWN0KGZpcmUuRklSRUJBU0VfQVBQX05BTUUpKSxcbiAgICAgICAgICAgIF9fcGFyYW0oMiwgY29yZS5PcHRpb25hbCgpKSwgX19wYXJhbSgyLCBjb3JlLkluamVjdChDT0xMRUNUSU9OX0VOQUJMRUQpKSxcbiAgICAgICAgICAgIF9fcGFyYW0oMywgY29yZS5PcHRpb25hbCgpKSwgX19wYXJhbSgzLCBjb3JlLkluamVjdChBUFBfVkVSU0lPTikpLFxuICAgICAgICAgICAgX19wYXJhbSg0LCBjb3JlLk9wdGlvbmFsKCkpLCBfX3BhcmFtKDQsIGNvcmUuSW5qZWN0KEFQUF9OQU1FKSksXG4gICAgICAgICAgICBfX3BhcmFtKDUsIGNvcmUuT3B0aW9uYWwoKSksIF9fcGFyYW0oNSwgY29yZS5JbmplY3QoREVCVUdfTU9ERSkpLFxuICAgICAgICAgICAgX19wYXJhbSg2LCBjb3JlLk9wdGlvbmFsKCkpLCBfX3BhcmFtKDYsIGNvcmUuSW5qZWN0KENPTkZJRykpLFxuICAgICAgICAgICAgX19wYXJhbSg3LCBjb3JlLkluamVjdChjb3JlLlBMQVRGT1JNX0lEKSksXG4gICAgICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdCwgT2JqZWN0LCBPYmplY3QsIE9iamVjdCwgT2JqZWN0LCBPYmplY3QsIE9iamVjdCwgT2JqZWN0LFxuICAgICAgICAgICAgICAgIGNvcmUuTmdab25lXSlcbiAgICAgICAgXSwgQW5ndWxhckZpcmVBbmFseXRpY3MpO1xuICAgICAgICByZXR1cm4gQW5ndWxhckZpcmVBbmFseXRpY3M7XG4gICAgfSgpKTtcblxuICAgIC8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gICAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAgICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxuICAgIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbiAgICBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuICAgIFRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICAgIEtJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuICAgIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbiAgICBNRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuICAgIFNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG4gICAgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuICAgIC8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBfX2Fzc2lnbiQxID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgX19hc3NpZ24kMSA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduJDEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gX19kZWNvcmF0ZSQxKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICAgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICAgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfX3BhcmFtJDEocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX19tZXRhZGF0YSQxKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICAgICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcclxuICAgICAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgICAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgICAgICByZXR1cm4gYXI7XHJcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZSBBbmd1bGFyIHY4LjAuMFxuICAgICAqIChjKSAyMDEwLTIwMTkgR29vZ2xlIExMQy4gaHR0cHM6Ly9hbmd1bGFyLmlvL1xuICAgICAqIExpY2Vuc2U6IE1JVFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogQmFzZSBmb3IgZXZlbnRzIHRoZSBSb3V0ZXIgZ29lcyB0aHJvdWdoLCBhcyBvcHBvc2VkIHRvIGV2ZW50cyB0aWVkIHRvIGEgc3BlY2lmaWNcbiAgICAgKiBSb3V0ZS4gYFJvdXRlckV2ZW50YHMgd2lsbCBvbmx5IGJlIGZpcmVkIG9uZSB0aW1lIGZvciBhbnkgZ2l2ZW4gbmF2aWdhdGlvbi5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBjbGFzcyBNeVNlcnZpY2Uge1xuICAgICAqICAgY29uc3RydWN0b3IocHVibGljIHJvdXRlcjogUm91dGVyLCBsb2dnZXI6IExvZ2dlcikge1xuICAgICAqICAgICByb3V0ZXIuZXZlbnRzLnBpcGUoXG4gICAgICogICAgICAgZmlsdGVyKGUgPT4gZSBpbnN0YW5jZW9mIFJvdXRlckV2ZW50KVxuICAgICAqICAgICApLnN1YnNjcmliZShlID0+IHtcbiAgICAgKiAgICAgICBsb2dnZXIubG9nKGUuaWQsIGUudXJsKTtcbiAgICAgKiAgICAgfSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBSb3V0ZXJFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUm91dGVyRXZlbnQoXG4gICAgICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgICAgIGlkLCBcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgdXJsKSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUm91dGVyRXZlbnQ7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZXZlbnQgdHJpZ2dlcmVkIHdoZW4gYSBuYXZpZ2F0aW9uIHN0YXJ0cy5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgTmF2aWdhdGlvblN0YXJ0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoTmF2aWdhdGlvblN0YXJ0LCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBOYXZpZ2F0aW9uU3RhcnQoXG4gICAgICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgICAgIGlkLCBcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgdXJsLCBcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgbmF2aWdhdGlvblRyaWdnZXIsIFxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICByZXN0b3JlZFN0YXRlKSB7XG4gICAgICAgICAgICBpZiAobmF2aWdhdGlvblRyaWdnZXIgPT09IHZvaWQgMCkgeyBuYXZpZ2F0aW9uVHJpZ2dlciA9ICdpbXBlcmF0aXZlJzsgfVxuICAgICAgICAgICAgaWYgKHJlc3RvcmVkU3RhdGUgPT09IHZvaWQgMCkgeyByZXN0b3JlZFN0YXRlID0gbnVsbDsgfVxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaWQsIHVybCkgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLm5hdmlnYXRpb25UcmlnZ2VyID0gbmF2aWdhdGlvblRyaWdnZXI7XG4gICAgICAgICAgICBfdGhpcy5yZXN0b3JlZFN0YXRlID0gcmVzdG9yZWRTdGF0ZTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICBOYXZpZ2F0aW9uU3RhcnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJOYXZpZ2F0aW9uU3RhcnQoaWQ6IFwiICsgdGhpcy5pZCArIFwiLCB1cmw6ICdcIiArIHRoaXMudXJsICsgXCInKVwiOyB9O1xuICAgICAgICByZXR1cm4gTmF2aWdhdGlvblN0YXJ0O1xuICAgIH0oUm91dGVyRXZlbnQpKTtcbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZXZlbnQgdHJpZ2dlcmVkIHdoZW4gYSBuYXZpZ2F0aW9uIGVuZHMgc3VjY2Vzc2Z1bGx5LlxuICAgICAqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBOYXZpZ2F0aW9uRW5kID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoTmF2aWdhdGlvbkVuZCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTmF2aWdhdGlvbkVuZChcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgaWQsIFxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICB1cmwsIFxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICB1cmxBZnRlclJlZGlyZWN0cykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaWQsIHVybCkgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLnVybEFmdGVyUmVkaXJlY3RzID0gdXJsQWZ0ZXJSZWRpcmVjdHM7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgTmF2aWdhdGlvbkVuZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJOYXZpZ2F0aW9uRW5kKGlkOiBcIiArIHRoaXMuaWQgKyBcIiwgdXJsOiAnXCIgKyB0aGlzLnVybCArIFwiJywgdXJsQWZ0ZXJSZWRpcmVjdHM6ICdcIiArIHRoaXMudXJsQWZ0ZXJSZWRpcmVjdHMgKyBcIicpXCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBOYXZpZ2F0aW9uRW5kO1xuICAgIH0oUm91dGVyRXZlbnQpKTtcbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZXZlbnQgdHJpZ2dlcmVkIHdoZW4gYSBuYXZpZ2F0aW9uIGlzIGNhbmNlbGVkLlxuICAgICAqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBOYXZpZ2F0aW9uQ2FuY2VsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoTmF2aWdhdGlvbkNhbmNlbCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTmF2aWdhdGlvbkNhbmNlbChcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgaWQsIFxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICB1cmwsIFxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICByZWFzb24pIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGlkLCB1cmwpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgTmF2aWdhdGlvbkNhbmNlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBcIk5hdmlnYXRpb25DYW5jZWwoaWQ6IFwiICsgdGhpcy5pZCArIFwiLCB1cmw6ICdcIiArIHRoaXMudXJsICsgXCInKVwiOyB9O1xuICAgICAgICByZXR1cm4gTmF2aWdhdGlvbkNhbmNlbDtcbiAgICB9KFJvdXRlckV2ZW50KSk7XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBSZXByZXNlbnRzIGFuIGV2ZW50IHRyaWdnZXJlZCB3aGVuIGEgbmF2aWdhdGlvbiBmYWlscyBkdWUgdG8gYW4gdW5leHBlY3RlZCBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgTmF2aWdhdGlvbkVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoTmF2aWdhdGlvbkVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBOYXZpZ2F0aW9uRXJyb3IoXG4gICAgICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgICAgIGlkLCBcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgdXJsLCBcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGlkLCB1cmwpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgICAgIE5hdmlnYXRpb25FcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJOYXZpZ2F0aW9uRXJyb3IoaWQ6IFwiICsgdGhpcy5pZCArIFwiLCB1cmw6ICdcIiArIHRoaXMudXJsICsgXCInLCBlcnJvcjogXCIgKyB0aGlzLmVycm9yICsgXCIpXCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBOYXZpZ2F0aW9uRXJyb3I7XG4gICAgfShSb3V0ZXJFdmVudCkpO1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogUmVwcmVzZW50cyBhbiBldmVudCB0cmlnZ2VyZWQgd2hlbiByb3V0ZXMgYXJlIHJlY29nbml6ZWQuXG4gICAgICpcbiAgICAgKiBAcHVibGljQXBpXG4gICAgICovXG4gICAgdmFyIFJvdXRlc1JlY29nbml6ZWQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhSb3V0ZXNSZWNvZ25pemVkLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBSb3V0ZXNSZWNvZ25pemVkKFxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICBpZCwgXG4gICAgICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgICAgIHVybCwgXG4gICAgICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgICAgIHVybEFmdGVyUmVkaXJlY3RzLCBcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgc3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGlkLCB1cmwpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy51cmxBZnRlclJlZGlyZWN0cyA9IHVybEFmdGVyUmVkaXJlY3RzO1xuICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICBSb3V0ZXNSZWNvZ25pemVkLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlJvdXRlc1JlY29nbml6ZWQoaWQ6IFwiICsgdGhpcy5pZCArIFwiLCB1cmw6ICdcIiArIHRoaXMudXJsICsgXCInLCB1cmxBZnRlclJlZGlyZWN0czogJ1wiICsgdGhpcy51cmxBZnRlclJlZGlyZWN0cyArIFwiJywgc3RhdGU6IFwiICsgdGhpcy5zdGF0ZSArIFwiKVwiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUm91dGVzUmVjb2duaXplZDtcbiAgICB9KFJvdXRlckV2ZW50KSk7XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBSZXByZXNlbnRzIHRoZSBzdGFydCBvZiB0aGUgR3VhcmQgcGhhc2Ugb2Ygcm91dGluZy5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgR3VhcmRzQ2hlY2tTdGFydCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEd1YXJkc0NoZWNrU3RhcnQsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEd1YXJkc0NoZWNrU3RhcnQoXG4gICAgICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgICAgIGlkLCBcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgdXJsLCBcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgdXJsQWZ0ZXJSZWRpcmVjdHMsIFxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICBzdGF0ZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaWQsIHVybCkgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLnVybEFmdGVyUmVkaXJlY3RzID0gdXJsQWZ0ZXJSZWRpcmVjdHM7XG4gICAgICAgICAgICBfdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIEd1YXJkc0NoZWNrU3RhcnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiR3VhcmRzQ2hlY2tTdGFydChpZDogXCIgKyB0aGlzLmlkICsgXCIsIHVybDogJ1wiICsgdGhpcy51cmwgKyBcIicsIHVybEFmdGVyUmVkaXJlY3RzOiAnXCIgKyB0aGlzLnVybEFmdGVyUmVkaXJlY3RzICsgXCInLCBzdGF0ZTogXCIgKyB0aGlzLnN0YXRlICsgXCIpXCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBHdWFyZHNDaGVja1N0YXJ0O1xuICAgIH0oUm91dGVyRXZlbnQpKTtcbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFJlcHJlc2VudHMgdGhlIGVuZCBvZiB0aGUgR3VhcmQgcGhhc2Ugb2Ygcm91dGluZy5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgR3VhcmRzQ2hlY2tFbmQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhHdWFyZHNDaGVja0VuZCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gR3VhcmRzQ2hlY2tFbmQoXG4gICAgICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgICAgIGlkLCBcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgdXJsLCBcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgdXJsQWZ0ZXJSZWRpcmVjdHMsIFxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICBzdGF0ZSwgXG4gICAgICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgICAgIHNob3VsZEFjdGl2YXRlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpZCwgdXJsKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMudXJsQWZ0ZXJSZWRpcmVjdHMgPSB1cmxBZnRlclJlZGlyZWN0cztcbiAgICAgICAgICAgIF90aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICBfdGhpcy5zaG91bGRBY3RpdmF0ZSA9IHNob3VsZEFjdGl2YXRlO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIEd1YXJkc0NoZWNrRW5kLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBcIkd1YXJkc0NoZWNrRW5kKGlkOiBcIiArIHRoaXMuaWQgKyBcIiwgdXJsOiAnXCIgKyB0aGlzLnVybCArIFwiJywgdXJsQWZ0ZXJSZWRpcmVjdHM6ICdcIiArIHRoaXMudXJsQWZ0ZXJSZWRpcmVjdHMgKyBcIicsIHN0YXRlOiBcIiArIHRoaXMuc3RhdGUgKyBcIiwgc2hvdWxkQWN0aXZhdGU6IFwiICsgdGhpcy5zaG91bGRBY3RpdmF0ZSArIFwiKVwiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gR3VhcmRzQ2hlY2tFbmQ7XG4gICAgfShSb3V0ZXJFdmVudCkpO1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogUmVwcmVzZW50cyB0aGUgc3RhcnQgb2YgdGhlIFJlc29sdmUgcGhhc2Ugb2Ygcm91dGluZy4gVGhlIHRpbWluZyBvZiB0aGlzXG4gICAgICogZXZlbnQgbWF5IGNoYW5nZSwgdGh1cyBpdCdzIGV4cGVyaW1lbnRhbC4gSW4gdGhlIGN1cnJlbnQgaXRlcmF0aW9uIGl0IHdpbGwgcnVuXG4gICAgICogaW4gdGhlIFwicmVzb2x2ZVwiIHBoYXNlIHdoZXRoZXIgdGhlcmUncyB0aGluZ3MgdG8gcmVzb2x2ZSBvciBub3QuIEluIHRoZSBmdXR1cmUgdGhpc1xuICAgICAqIGJlaGF2aW9yIG1heSBjaGFuZ2UgdG8gb25seSBydW4gd2hlbiB0aGVyZSBhcmUgdGhpbmdzIHRvIGJlIHJlc29sdmVkLlxuICAgICAqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBSZXNvbHZlU3RhcnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhSZXNvbHZlU3RhcnQsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFJlc29sdmVTdGFydChcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgaWQsIFxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICB1cmwsIFxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICB1cmxBZnRlclJlZGlyZWN0cywgXG4gICAgICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgICAgIHN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpZCwgdXJsKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMudXJsQWZ0ZXJSZWRpcmVjdHMgPSB1cmxBZnRlclJlZGlyZWN0cztcbiAgICAgICAgICAgIF90aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgUmVzb2x2ZVN0YXJ0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlJlc29sdmVTdGFydChpZDogXCIgKyB0aGlzLmlkICsgXCIsIHVybDogJ1wiICsgdGhpcy51cmwgKyBcIicsIHVybEFmdGVyUmVkaXJlY3RzOiAnXCIgKyB0aGlzLnVybEFmdGVyUmVkaXJlY3RzICsgXCInLCBzdGF0ZTogXCIgKyB0aGlzLnN0YXRlICsgXCIpXCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSZXNvbHZlU3RhcnQ7XG4gICAgfShSb3V0ZXJFdmVudCkpO1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogUmVwcmVzZW50cyB0aGUgZW5kIG9mIHRoZSBSZXNvbHZlIHBoYXNlIG9mIHJvdXRpbmcuIFNlZSBub3RlIG9uXG4gICAgICogYFJlc29sdmVTdGFydGAgZm9yIHVzZSBvZiB0aGlzIGV4cGVyaW1lbnRhbCBBUEkuXG4gICAgICpcbiAgICAgKiBAcHVibGljQXBpXG4gICAgICovXG4gICAgdmFyIFJlc29sdmVFbmQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhSZXNvbHZlRW5kLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBSZXNvbHZlRW5kKFxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICBpZCwgXG4gICAgICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgICAgIHVybCwgXG4gICAgICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgICAgIHVybEFmdGVyUmVkaXJlY3RzLCBcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgc3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGlkLCB1cmwpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy51cmxBZnRlclJlZGlyZWN0cyA9IHVybEFmdGVyUmVkaXJlY3RzO1xuICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBSZXNvbHZlRW5kLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlJlc29sdmVFbmQoaWQ6IFwiICsgdGhpcy5pZCArIFwiLCB1cmw6ICdcIiArIHRoaXMudXJsICsgXCInLCB1cmxBZnRlclJlZGlyZWN0czogJ1wiICsgdGhpcy51cmxBZnRlclJlZGlyZWN0cyArIFwiJywgc3RhdGU6IFwiICsgdGhpcy5zdGF0ZSArIFwiKVwiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmVzb2x2ZUVuZDtcbiAgICB9KFJvdXRlckV2ZW50KSk7XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBSZXByZXNlbnRzIGFuIGV2ZW50IHRyaWdnZXJlZCBiZWZvcmUgbGF6eSBsb2FkaW5nIGEgcm91dGUgY29uZmlnLlxuICAgICAqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBSb3V0ZUNvbmZpZ0xvYWRTdGFydCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUm91dGVDb25maWdMb2FkU3RhcnQoXG4gICAgICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgICAgIHJvdXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJvdXRlID0gcm91dGU7XG4gICAgICAgIH1cbiAgICAgICAgUm91dGVDb25maWdMb2FkU3RhcnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJSb3V0ZUNvbmZpZ0xvYWRTdGFydChwYXRoOiBcIiArIHRoaXMucm91dGUucGF0aCArIFwiKVwiOyB9O1xuICAgICAgICByZXR1cm4gUm91dGVDb25maWdMb2FkU3RhcnQ7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZXZlbnQgdHJpZ2dlcmVkIHdoZW4gYSByb3V0ZSBoYXMgYmVlbiBsYXp5IGxvYWRlZC5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgUm91dGVDb25maWdMb2FkRW5kID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSb3V0ZUNvbmZpZ0xvYWRFbmQoXG4gICAgICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgICAgIHJvdXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJvdXRlID0gcm91dGU7XG4gICAgICAgIH1cbiAgICAgICAgUm91dGVDb25maWdMb2FkRW5kLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiUm91dGVDb25maWdMb2FkRW5kKHBhdGg6IFwiICsgdGhpcy5yb3V0ZS5wYXRoICsgXCIpXCI7IH07XG4gICAgICAgIHJldHVybiBSb3V0ZUNvbmZpZ0xvYWRFbmQ7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFJlcHJlc2VudHMgdGhlIHN0YXJ0IG9mIGVuZCBvZiB0aGUgUmVzb2x2ZSBwaGFzZSBvZiByb3V0aW5nLiBTZWUgbm90ZSBvblxuICAgICAqIGBDaGlsZEFjdGl2YXRpb25FbmRgIGZvciB1c2Ugb2YgdGhpcyBleHBlcmltZW50YWwgQVBJLlxuICAgICAqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBDaGlsZEFjdGl2YXRpb25TdGFydCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ2hpbGRBY3RpdmF0aW9uU3RhcnQoXG4gICAgICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgICAgIHNuYXBzaG90KSB7XG4gICAgICAgICAgICB0aGlzLnNuYXBzaG90ID0gc25hcHNob3Q7XG4gICAgICAgIH1cbiAgICAgICAgQ2hpbGRBY3RpdmF0aW9uU3RhcnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhdGggPSB0aGlzLnNuYXBzaG90LnJvdXRlQ29uZmlnICYmIHRoaXMuc25hcHNob3Qucm91dGVDb25maWcucGF0aCB8fCAnJztcbiAgICAgICAgICAgIHJldHVybiBcIkNoaWxkQWN0aXZhdGlvblN0YXJ0KHBhdGg6ICdcIiArIHBhdGggKyBcIicpXCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBDaGlsZEFjdGl2YXRpb25TdGFydDtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogUmVwcmVzZW50cyB0aGUgc3RhcnQgb2YgZW5kIG9mIHRoZSBSZXNvbHZlIHBoYXNlIG9mIHJvdXRpbmcuIFNlZSBub3RlIG9uXG4gICAgICogYENoaWxkQWN0aXZhdGlvblN0YXJ0YCBmb3IgdXNlIG9mIHRoaXMgZXhwZXJpbWVudGFsIEFQSS5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgQ2hpbGRBY3RpdmF0aW9uRW5kID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDaGlsZEFjdGl2YXRpb25FbmQoXG4gICAgICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgICAgIHNuYXBzaG90KSB7XG4gICAgICAgICAgICB0aGlzLnNuYXBzaG90ID0gc25hcHNob3Q7XG4gICAgICAgIH1cbiAgICAgICAgQ2hpbGRBY3RpdmF0aW9uRW5kLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gdGhpcy5zbmFwc2hvdC5yb3V0ZUNvbmZpZyAmJiB0aGlzLnNuYXBzaG90LnJvdXRlQ29uZmlnLnBhdGggfHwgJyc7XG4gICAgICAgICAgICByZXR1cm4gXCJDaGlsZEFjdGl2YXRpb25FbmQocGF0aDogJ1wiICsgcGF0aCArIFwiJylcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENoaWxkQWN0aXZhdGlvbkVuZDtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogUmVwcmVzZW50cyB0aGUgc3RhcnQgb2YgZW5kIG9mIHRoZSBSZXNvbHZlIHBoYXNlIG9mIHJvdXRpbmcuIFNlZSBub3RlIG9uXG4gICAgICogYEFjdGl2YXRpb25FbmRgIGZvciB1c2Ugb2YgdGhpcyBleHBlcmltZW50YWwgQVBJLlxuICAgICAqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBBY3RpdmF0aW9uU3RhcnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFjdGl2YXRpb25TdGFydChcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgc25hcHNob3QpIHtcbiAgICAgICAgICAgIHRoaXMuc25hcHNob3QgPSBzbmFwc2hvdDtcbiAgICAgICAgfVxuICAgICAgICBBY3RpdmF0aW9uU3RhcnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhdGggPSB0aGlzLnNuYXBzaG90LnJvdXRlQ29uZmlnICYmIHRoaXMuc25hcHNob3Qucm91dGVDb25maWcucGF0aCB8fCAnJztcbiAgICAgICAgICAgIHJldHVybiBcIkFjdGl2YXRpb25TdGFydChwYXRoOiAnXCIgKyBwYXRoICsgXCInKVwiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQWN0aXZhdGlvblN0YXJ0O1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBSZXByZXNlbnRzIHRoZSBzdGFydCBvZiBlbmQgb2YgdGhlIFJlc29sdmUgcGhhc2Ugb2Ygcm91dGluZy4gU2VlIG5vdGUgb25cbiAgICAgKiBgQWN0aXZhdGlvblN0YXJ0YCBmb3IgdXNlIG9mIHRoaXMgZXhwZXJpbWVudGFsIEFQSS5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgQWN0aXZhdGlvbkVuZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQWN0aXZhdGlvbkVuZChcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgc25hcHNob3QpIHtcbiAgICAgICAgICAgIHRoaXMuc25hcHNob3QgPSBzbmFwc2hvdDtcbiAgICAgICAgfVxuICAgICAgICBBY3RpdmF0aW9uRW5kLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gdGhpcy5zbmFwc2hvdC5yb3V0ZUNvbmZpZyAmJiB0aGlzLnNuYXBzaG90LnJvdXRlQ29uZmlnLnBhdGggfHwgJyc7XG4gICAgICAgICAgICByZXR1cm4gXCJBY3RpdmF0aW9uRW5kKHBhdGg6ICdcIiArIHBhdGggKyBcIicpXCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBBY3RpdmF0aW9uRW5kO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBSZXByZXNlbnRzIGEgc2Nyb2xsaW5nIGV2ZW50LlxuICAgICAqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBTY3JvbGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFNjcm9sbChcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgcm91dGVyRXZlbnQsIFxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICBwb3NpdGlvbiwgXG4gICAgICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgICAgIGFuY2hvcikge1xuICAgICAgICAgICAgdGhpcy5yb3V0ZXJFdmVudCA9IHJvdXRlckV2ZW50O1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgdGhpcy5hbmNob3IgPSBhbmNob3I7XG4gICAgICAgIH1cbiAgICAgICAgU2Nyb2xsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uID8gdGhpcy5wb3NpdGlvblswXSArIFwiLCBcIiArIHRoaXMucG9zaXRpb25bMV0gOiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIFwiU2Nyb2xsKGFuY2hvcjogJ1wiICsgdGhpcy5hbmNob3IgKyBcIicsIHBvc2l0aW9uOiAnXCIgKyBwb3MgKyBcIicpXCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTY3JvbGw7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBUaGlzIGNvbXBvbmVudCBpcyB1c2VkIGludGVybmFsbHkgd2l0aGluIHRoZSByb3V0ZXIgdG8gYmUgYSBwbGFjZWhvbGRlciB3aGVuIGFuIGVtcHR5XG4gICAgICogcm91dGVyLW91dGxldCBpcyBuZWVkZWQuIEZvciBleGFtcGxlLCB3aXRoIGEgY29uZmlnIHN1Y2ggYXM6XG4gICAgICpcbiAgICAgKiBge3BhdGg6ICdwYXJlbnQnLCBvdXRsZXQ6ICduYXYnLCBjaGlsZHJlbjogWy4uLl19YFxuICAgICAqXG4gICAgICogSW4gb3JkZXIgdG8gcmVuZGVyLCB0aGVyZSBuZWVkcyB0byBiZSBhIGNvbXBvbmVudCBvbiB0aGlzIGNvbmZpZywgd2hpY2ggd2lsbCBkZWZhdWx0XG4gICAgICogdG8gdGhpcyBgRW1wdHlPdXRsZXRDb21wb25lbnRgLlxuICAgICAqL1xuICAgIHZhciDJtUVtcHR5T3V0bGV0Q29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiDJtUVtcHR5T3V0bGV0Q29tcG9uZW50KCkge1xuICAgICAgICB9XG4gICAgICAgIMm1RW1wdHlPdXRsZXRDb21wb25lbnQgPSBfX2RlY29yYXRlJDEoW1xuICAgICAgICAgICAgY29yZS5Db21wb25lbnQoeyB0ZW1wbGF0ZTogXCI8cm91dGVyLW91dGxldD48L3JvdXRlci1vdXRsZXQ+XCIgfSlcbiAgICAgICAgXSwgybVFbXB0eU91dGxldENvbXBvbmVudCk7XG4gICAgICAgIHJldHVybiDJtUVtcHR5T3V0bGV0Q29tcG9uZW50O1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBOYW1lIG9mIHRoZSBwcmltYXJ5IG91dGxldC5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgUFJJTUFSWV9PVVRMRVQgPSAncHJpbWFyeSc7XG4gICAgdmFyIFBhcmFtc0FzTWFwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBQYXJhbXNBc01hcChwYXJhbXMpIHtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICB9XG4gICAgICAgIFBhcmFtc0FzTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gdGhpcy5wYXJhbXMuaGFzT3duUHJvcGVydHkobmFtZSk7IH07XG4gICAgICAgIFBhcmFtc0FzTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSB0aGlzLnBhcmFtc1tuYW1lXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2KSA/IHZbMF0gOiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIFBhcmFtc0FzTWFwLnByb3RvdHlwZS5nZXRBbGwgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSB0aGlzLnBhcmFtc1tuYW1lXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2KSA/IHYgOiBbdl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYXJhbXNBc01hcC5wcm90b3R5cGUsIFwia2V5c1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMucGFyYW1zKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQYXJhbXNBc01hcDtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBgUGFyYW1zYCBpbnN0YW5jZSB0byBhIGBQYXJhbU1hcGAuXG4gICAgICpcbiAgICAgKiBAcHVibGljQXBpXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udmVydFRvUGFyYW1NYXAocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFyYW1zQXNNYXAocGFyYW1zKTtcbiAgICB9XG4gICAgdmFyIE5BVklHQVRJT05fQ0FOQ0VMSU5HX0VSUk9SID0gJ25nTmF2aWdhdGlvbkNhbmNlbGluZ0Vycm9yJztcbiAgICBmdW5jdGlvbiBuYXZpZ2F0aW9uQ2FuY2VsaW5nRXJyb3IobWVzc2FnZSkge1xuICAgICAgICB2YXIgZXJyb3IgPSBFcnJvcignTmF2aWdhdGlvbkNhbmNlbGluZ0Vycm9yOiAnICsgbWVzc2FnZSk7XG4gICAgICAgIGVycm9yW05BVklHQVRJT05fQ0FOQ0VMSU5HX0VSUk9SXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNOYXZpZ2F0aW9uQ2FuY2VsaW5nRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yICYmIGVycm9yW05BVklHQVRJT05fQ0FOQ0VMSU5HX0VSUk9SXTtcbiAgICB9XG4gICAgLy8gTWF0Y2hlcyB0aGUgcm91dGUgY29uZmlndXJhdGlvbiAoYHJvdXRlYCkgYWdhaW5zdCB0aGUgYWN0dWFsIFVSTCAoYHNlZ21lbnRzYCkuXG4gICAgZnVuY3Rpb24gZGVmYXVsdFVybE1hdGNoZXIoc2VnbWVudHMsIHNlZ21lbnRHcm91cCwgcm91dGUpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gcm91dGUucGF0aC5zcGxpdCgnLycpO1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBUaGUgYWN0dWFsIFVSTCBpcyBzaG9ydGVyIHRoYW4gdGhlIGNvbmZpZywgbm8gbWF0Y2hcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3V0ZS5wYXRoTWF0Y2ggPT09ICdmdWxsJyAmJlxuICAgICAgICAgICAgKHNlZ21lbnRHcm91cC5oYXNDaGlsZHJlbigpIHx8IHBhcnRzLmxlbmd0aCA8IHNlZ21lbnRzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIC8vIFRoZSBjb25maWcgaXMgbG9uZ2VyIHRoYW4gdGhlIGFjdHVhbCBVUkwgYnV0IHdlIGFyZSBsb29raW5nIGZvciBhIGZ1bGwgbWF0Y2gsIHJldHVybiBudWxsXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9zUGFyYW1zID0ge307XG4gICAgICAgIC8vIENoZWNrIGVhY2ggY29uZmlnIHBhcnQgYWdhaW5zdCB0aGUgYWN0dWFsIFVSTFxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgcGFydHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2luZGV4XTtcbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaW5kZXhdO1xuICAgICAgICAgICAgdmFyIGlzUGFyYW1ldGVyID0gcGFydC5zdGFydHNXaXRoKCc6Jyk7XG4gICAgICAgICAgICBpZiAoaXNQYXJhbWV0ZXIpIHtcbiAgICAgICAgICAgICAgICBwb3NQYXJhbXNbcGFydC5zdWJzdHJpbmcoMSldID0gc2VnbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcnQgIT09IHNlZ21lbnQucGF0aCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBhY3R1YWwgVVJMIHBhcnQgZG9lcyBub3QgbWF0Y2ggdGhlIGNvbmZpZywgbm8gbWF0Y2hcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjb25zdW1lZDogc2VnbWVudHMuc2xpY2UoMCwgcGFydHMubGVuZ3RoKSwgcG9zUGFyYW1zOiBwb3NQYXJhbXMgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIExvYWRlZFJvdXRlckNvbmZpZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTG9hZGVkUm91dGVyQ29uZmlnKHJvdXRlcywgbW9kdWxlKSB7XG4gICAgICAgICAgICB0aGlzLnJvdXRlcyA9IHJvdXRlcztcbiAgICAgICAgICAgIHRoaXMubW9kdWxlID0gbW9kdWxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBMb2FkZWRSb3V0ZXJDb25maWc7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUNvbmZpZyhjb25maWcsIHBhcmVudFBhdGgpIHtcbiAgICAgICAgaWYgKHBhcmVudFBhdGggPT09IHZvaWQgMCkgeyBwYXJlbnRQYXRoID0gJyc7IH1cbiAgICAgICAgLy8gZm9yRWFjaCBkb2Vzbid0IGl0ZXJhdGUgdW5kZWZpbmVkIHZhbHVlc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbmZpZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJvdXRlID0gY29uZmlnW2ldO1xuICAgICAgICAgICAgdmFyIGZ1bGxQYXRoID0gZ2V0RnVsbFBhdGgocGFyZW50UGF0aCwgcm91dGUpO1xuICAgICAgICAgICAgdmFsaWRhdGVOb2RlKHJvdXRlLCBmdWxsUGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVOb2RlKHJvdXRlLCBmdWxsUGF0aCkge1xuICAgICAgICBpZiAoIXJvdXRlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXG4gICAgICBJbnZhbGlkIGNvbmZpZ3VyYXRpb24gb2Ygcm91dGUgJ1wiICsgZnVsbFBhdGggKyBcIic6IEVuY291bnRlcmVkIHVuZGVmaW5lZCByb3V0ZS5cXG4gICAgICBUaGUgcmVhc29uIG1pZ2h0IGJlIGFuIGV4dHJhIGNvbW1hLlxcblxcbiAgICAgIEV4YW1wbGU6XFxuICAgICAgY29uc3Qgcm91dGVzOiBSb3V0ZXMgPSBbXFxuICAgICAgICB7IHBhdGg6ICcnLCByZWRpcmVjdFRvOiAnL2Rhc2hib2FyZCcsIHBhdGhNYXRjaDogJ2Z1bGwnIH0sXFxuICAgICAgICB7IHBhdGg6ICdkYXNoYm9hcmQnLCAgY29tcG9uZW50OiBEYXNoYm9hcmRDb21wb25lbnQgfSwsIDw8IHR3byBjb21tYXNcXG4gICAgICAgIHsgcGF0aDogJ2RldGFpbC86aWQnLCBjb21wb25lbnQ6IEhlcm9EZXRhaWxDb21wb25lbnQgfVxcbiAgICAgIF07XFxuICAgIFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyb3V0ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29uZmlndXJhdGlvbiBvZiByb3V0ZSAnXCIgKyBmdWxsUGF0aCArIFwiJzogQXJyYXkgY2Fubm90IGJlIHNwZWNpZmllZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJvdXRlLmNvbXBvbmVudCAmJiAhcm91dGUuY2hpbGRyZW4gJiYgIXJvdXRlLmxvYWRDaGlsZHJlbiAmJlxuICAgICAgICAgICAgKHJvdXRlLm91dGxldCAmJiByb3V0ZS5vdXRsZXQgIT09IFBSSU1BUllfT1VUTEVUKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb25maWd1cmF0aW9uIG9mIHJvdXRlICdcIiArIGZ1bGxQYXRoICsgXCInOiBhIGNvbXBvbmVudGxlc3Mgcm91dGUgd2l0aG91dCBjaGlsZHJlbiBvciBsb2FkQ2hpbGRyZW4gY2Fubm90IGhhdmUgYSBuYW1lZCBvdXRsZXQgc2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3V0ZS5yZWRpcmVjdFRvICYmIHJvdXRlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvbmZpZ3VyYXRpb24gb2Ygcm91dGUgJ1wiICsgZnVsbFBhdGggKyBcIic6IHJlZGlyZWN0VG8gYW5kIGNoaWxkcmVuIGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3V0ZS5yZWRpcmVjdFRvICYmIHJvdXRlLmxvYWRDaGlsZHJlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb25maWd1cmF0aW9uIG9mIHJvdXRlICdcIiArIGZ1bGxQYXRoICsgXCInOiByZWRpcmVjdFRvIGFuZCBsb2FkQ2hpbGRyZW4gY2Fubm90IGJlIHVzZWQgdG9nZXRoZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvdXRlLmNoaWxkcmVuICYmIHJvdXRlLmxvYWRDaGlsZHJlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb25maWd1cmF0aW9uIG9mIHJvdXRlICdcIiArIGZ1bGxQYXRoICsgXCInOiBjaGlsZHJlbiBhbmQgbG9hZENoaWxkcmVuIGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3V0ZS5yZWRpcmVjdFRvICYmIHJvdXRlLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb25maWd1cmF0aW9uIG9mIHJvdXRlICdcIiArIGZ1bGxQYXRoICsgXCInOiByZWRpcmVjdFRvIGFuZCBjb21wb25lbnQgY2Fubm90IGJlIHVzZWQgdG9nZXRoZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvdXRlLnBhdGggJiYgcm91dGUubWF0Y2hlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb25maWd1cmF0aW9uIG9mIHJvdXRlICdcIiArIGZ1bGxQYXRoICsgXCInOiBwYXRoIGFuZCBtYXRjaGVyIGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3V0ZS5yZWRpcmVjdFRvID09PSB2b2lkIDAgJiYgIXJvdXRlLmNvbXBvbmVudCAmJiAhcm91dGUuY2hpbGRyZW4gJiYgIXJvdXRlLmxvYWRDaGlsZHJlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb25maWd1cmF0aW9uIG9mIHJvdXRlICdcIiArIGZ1bGxQYXRoICsgXCInLiBPbmUgb2YgdGhlIGZvbGxvd2luZyBtdXN0IGJlIHByb3ZpZGVkOiBjb21wb25lbnQsIHJlZGlyZWN0VG8sIGNoaWxkcmVuIG9yIGxvYWRDaGlsZHJlblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm91dGUucGF0aCA9PT0gdm9pZCAwICYmIHJvdXRlLm1hdGNoZXIgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb25maWd1cmF0aW9uIG9mIHJvdXRlICdcIiArIGZ1bGxQYXRoICsgXCInOiByb3V0ZXMgbXVzdCBoYXZlIGVpdGhlciBhIHBhdGggb3IgYSBtYXRjaGVyIHNwZWNpZmllZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJvdXRlLnBhdGggPT09ICdzdHJpbmcnICYmIHJvdXRlLnBhdGguY2hhckF0KDApID09PSAnLycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29uZmlndXJhdGlvbiBvZiByb3V0ZSAnXCIgKyBmdWxsUGF0aCArIFwiJzogcGF0aCBjYW5ub3Qgc3RhcnQgd2l0aCBhIHNsYXNoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3V0ZS5wYXRoID09PSAnJyAmJiByb3V0ZS5yZWRpcmVjdFRvICE9PSB2b2lkIDAgJiYgcm91dGUucGF0aE1hdGNoID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHZhciBleHAgPSBcIlRoZSBkZWZhdWx0IHZhbHVlIG9mICdwYXRoTWF0Y2gnIGlzICdwcmVmaXgnLCBidXQgb2Z0ZW4gdGhlIGludGVudCBpcyB0byB1c2UgJ2Z1bGwnLlwiO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb25maWd1cmF0aW9uIG9mIHJvdXRlICd7cGF0aDogXFxcIlwiICsgZnVsbFBhdGggKyBcIlxcXCIsIHJlZGlyZWN0VG86IFxcXCJcIiArIHJvdXRlLnJlZGlyZWN0VG8gKyBcIlxcXCJ9JzogcGxlYXNlIHByb3ZpZGUgJ3BhdGhNYXRjaCcuIFwiICsgZXhwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm91dGUucGF0aE1hdGNoICE9PSB2b2lkIDAgJiYgcm91dGUucGF0aE1hdGNoICE9PSAnZnVsbCcgJiYgcm91dGUucGF0aE1hdGNoICE9PSAncHJlZml4Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb25maWd1cmF0aW9uIG9mIHJvdXRlICdcIiArIGZ1bGxQYXRoICsgXCInOiBwYXRoTWF0Y2ggY2FuIG9ubHkgYmUgc2V0IHRvICdwcmVmaXgnIG9yICdmdWxsJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm91dGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHZhbGlkYXRlQ29uZmlnKHJvdXRlLmNoaWxkcmVuLCBmdWxsUGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0RnVsbFBhdGgocGFyZW50UGF0aCwgY3VycmVudFJvdXRlKSB7XG4gICAgICAgIGlmICghY3VycmVudFJvdXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50UGF0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmVudFBhdGggJiYgIWN1cnJlbnRSb3V0ZS5wYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyZW50UGF0aCAmJiAhY3VycmVudFJvdXRlLnBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRQYXRoICsgXCIvXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXBhcmVudFBhdGggJiYgY3VycmVudFJvdXRlLnBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50Um91dGUucGF0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRQYXRoICsgXCIvXCIgKyBjdXJyZW50Um91dGUucGF0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyBhIGNvcHkgb2YgdGhlIGNvbmZpZyBhbmQgYWRkcyBhbnkgZGVmYXVsdCByZXF1aXJlZCBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YW5kYXJkaXplQ29uZmlnKHIpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gci5jaGlsZHJlbiAmJiByLmNoaWxkcmVuLm1hcChzdGFuZGFyZGl6ZUNvbmZpZyk7XG4gICAgICAgIHZhciBjID0gY2hpbGRyZW4gPyBfX2Fzc2lnbiQxKHt9LCByLCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KSA6IF9fYXNzaWduJDEoe30sIHIpO1xuICAgICAgICBpZiAoIWMuY29tcG9uZW50ICYmIChjaGlsZHJlbiB8fCBjLmxvYWRDaGlsZHJlbikgJiYgKGMub3V0bGV0ICYmIGMub3V0bGV0ICE9PSBQUklNQVJZX09VVExFVCkpIHtcbiAgICAgICAgICAgIGMuY29tcG9uZW50ID0gybVFbXB0eU91dGxldENvbXBvbmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hhbGxvd0VxdWFsQXJyYXlzKGEsIGIpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIXNoYWxsb3dFcXVhbChhW2ldLCBiW2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNoYWxsb3dFcXVhbChhLCBiKSB7XG4gICAgICAgIC8vIENhc3RpbmcgT2JqZWN0LmtleXMgcmV0dXJuIHZhbHVlcyB0byBpbmNsdWRlIGB1bmRlZmluZWRgIGFzIHRoZXJlIGFyZSBzb21lIGNhc2VzXG4gICAgICAgIC8vIGluIElFIDExIHdoZXJlIHRoaXMgY2FuIGhhcHBlbi4gQ2Fubm90IHByb3ZpZGUgYSB0ZXN0IGJlY2F1c2UgdGhlIGJlaGF2aW9yIG9ubHlcbiAgICAgICAgLy8gZXhpc3RzIGluIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcyBpbiBJRSAxMSwgdGhlcmVmb3JlIGRvaW5nIHRoaXMgY2FzdCBlbnN1cmVzIHRoZVxuICAgICAgICAvLyBsb2dpYyBpcyBjb3JyZWN0IGZvciB3aGVuIHRoaXMgZWRnZSBjYXNlIGlzIGhpdC5cbiAgICAgICAgdmFyIGsxID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgIHZhciBrMiA9IE9iamVjdC5rZXlzKGIpO1xuICAgICAgICBpZiAoIWsxIHx8ICFrMiB8fCBrMS5sZW5ndGggIT0gazIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrMS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAga2V5ID0gazFbaV07XG4gICAgICAgICAgICBpZiAoYVtrZXldICE9PSBiW2tleV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZsYXR0ZW5zIHNpbmdsZS1sZXZlbCBuZXN0ZWQgYXJyYXlzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW4oYXJyKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcnIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0KGEpIHtcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID4gMCA/IGFbYS5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvckVhY2gobWFwLCBjYWxsYmFjaykge1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIG1hcCkge1xuICAgICAgICAgICAgaWYgKG1hcC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG1hcFtwcm9wXSwgcHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gd2FpdEZvck1hcChvYmosIGZuKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJ4anMub2Yoe30pO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3YWl0SGVhZCA9IFtdO1xuICAgICAgICB2YXIgd2FpdFRhaWwgPSBbXTtcbiAgICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgICBmb3JFYWNoKG9iaiwgZnVuY3Rpb24gKGEsIGspIHtcbiAgICAgICAgICAgIHZhciBtYXBwZWQgPSBmbihrLCBhKS5waXBlKG9wZXJhdG9ycy5tYXAoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHJlc1trXSA9IHI7IH0pKTtcbiAgICAgICAgICAgIGlmIChrID09PSBQUklNQVJZX09VVExFVCkge1xuICAgICAgICAgICAgICAgIHdhaXRIZWFkLnB1c2gobWFwcGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdhaXRUYWlsLnB1c2gobWFwcGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENsb3N1cmUgY29tcGlsZXIgaGFzIHByb2JsZW0gd2l0aCB1c2luZyBzcHJlYWQgb3BlcmF0b3IgaGVyZS4gU28ganVzdCB1c2luZyBBcnJheS5jb25jYXQuXG4gICAgICAgIHJldHVybiByeGpzLm9mLmFwcGx5KG51bGwsIHdhaXRIZWFkLmNvbmNhdCh3YWl0VGFpbCkpLnBpcGUob3BlcmF0b3JzLmNvbmNhdEFsbCgpLCBvcGVyYXRvcnMubGFzdCgpLCBvcGVyYXRvcnMubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlczsgfSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cmFwSW50b09ic2VydmFibGUodmFsdWUpIHtcbiAgICAgICAgaWYgKGNvcmUuybVpc09ic2VydmFibGUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvcmUuybVpc1Byb21pc2UodmFsdWUpKSB7XG4gICAgICAgICAgICAvLyBVc2UgYFByb21pc2UucmVzb2x2ZSgpYCB0byB3cmFwIHByb21pc2UtbGlrZSBpbnN0YW5jZXMuXG4gICAgICAgICAgICAvLyBSZXF1aXJlZCBpZSB3aGVuIGEgUmVzb2x2ZXIgcmV0dXJucyBhIEFuZ3VsYXJKUyBgJHFgIHByb21pc2UgdG8gY29ycmVjdGx5IHRyaWdnZXIgdGhlXG4gICAgICAgICAgICAvLyBjaGFuZ2UgZGV0ZWN0aW9uLlxuICAgICAgICAgICAgcmV0dXJuIHJ4anMuZnJvbShQcm9taXNlLnJlc29sdmUodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnhqcy5vZih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUVtcHR5VXJsVHJlZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVcmxUcmVlKG5ldyBVcmxTZWdtZW50R3JvdXAoW10sIHt9KSwge30sIG51bGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb250YWluc1RyZWUoY29udGFpbmVyLCBjb250YWluZWUsIGV4YWN0KSB7XG4gICAgICAgIGlmIChleGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGVxdWFsUXVlcnlQYXJhbXMoY29udGFpbmVyLnF1ZXJ5UGFyYW1zLCBjb250YWluZWUucXVlcnlQYXJhbXMpICYmXG4gICAgICAgICAgICAgICAgZXF1YWxTZWdtZW50R3JvdXBzKGNvbnRhaW5lci5yb290LCBjb250YWluZWUucm9vdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5zUXVlcnlQYXJhbXMoY29udGFpbmVyLnF1ZXJ5UGFyYW1zLCBjb250YWluZWUucXVlcnlQYXJhbXMpICYmXG4gICAgICAgICAgICBjb250YWluc1NlZ21lbnRHcm91cChjb250YWluZXIucm9vdCwgY29udGFpbmVlLnJvb3QpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlcXVhbFF1ZXJ5UGFyYW1zKGNvbnRhaW5lciwgY29udGFpbmVlKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgZG9lcyBub3QgaGFuZGxlIGFycmF5IHBhcmFtcyBjb3JyZWN0bHkuXG4gICAgICAgIHJldHVybiBzaGFsbG93RXF1YWwoY29udGFpbmVyLCBjb250YWluZWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlcXVhbFNlZ21lbnRHcm91cHMoY29udGFpbmVyLCBjb250YWluZWUpIHtcbiAgICAgICAgaWYgKCFlcXVhbFBhdGgoY29udGFpbmVyLnNlZ21lbnRzLCBjb250YWluZWUuc2VnbWVudHMpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoY29udGFpbmVyLm51bWJlck9mQ2hpbGRyZW4gIT09IGNvbnRhaW5lZS5udW1iZXJPZkNoaWxkcmVuKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBjIGluIGNvbnRhaW5lZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKCFjb250YWluZXIuY2hpbGRyZW5bY10pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFlcXVhbFNlZ21lbnRHcm91cHMoY29udGFpbmVyLmNoaWxkcmVuW2NdLCBjb250YWluZWUuY2hpbGRyZW5bY10pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udGFpbnNRdWVyeVBhcmFtcyhjb250YWluZXIsIGNvbnRhaW5lZSkge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGRvZXMgbm90IGhhbmRsZSBhcnJheSBwYXJhbXMgY29ycmVjdGx5LlxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoY29udGFpbmVlKS5sZW5ndGggPD0gT2JqZWN0LmtleXMoY29udGFpbmVyKS5sZW5ndGggJiZcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNvbnRhaW5lZSkuZXZlcnkoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gY29udGFpbmVlW2tleV0gPT09IGNvbnRhaW5lcltrZXldOyB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udGFpbnNTZWdtZW50R3JvdXAoY29udGFpbmVyLCBjb250YWluZWUpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5zU2VnbWVudEdyb3VwSGVscGVyKGNvbnRhaW5lciwgY29udGFpbmVlLCBjb250YWluZWUuc2VnbWVudHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb250YWluc1NlZ21lbnRHcm91cEhlbHBlcihjb250YWluZXIsIGNvbnRhaW5lZSwgY29udGFpbmVlUGF0aHMpIHtcbiAgICAgICAgaWYgKGNvbnRhaW5lci5zZWdtZW50cy5sZW5ndGggPiBjb250YWluZWVQYXRocy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gY29udGFpbmVyLnNlZ21lbnRzLnNsaWNlKDAsIGNvbnRhaW5lZVBhdGhzLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoIWVxdWFsUGF0aChjdXJyZW50LCBjb250YWluZWVQYXRocykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lZS5oYXNDaGlsZHJlbigpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRhaW5lci5zZWdtZW50cy5sZW5ndGggPT09IGNvbnRhaW5lZVBhdGhzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCFlcXVhbFBhdGgoY29udGFpbmVyLnNlZ21lbnRzLCBjb250YWluZWVQYXRocykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgYyBpbiBjb250YWluZWUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRhaW5lci5jaGlsZHJlbltjXSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICghY29udGFpbnNTZWdtZW50R3JvdXAoY29udGFpbmVyLmNoaWxkcmVuW2NdLCBjb250YWluZWUuY2hpbGRyZW5bY10pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gY29udGFpbmVlUGF0aHMuc2xpY2UoMCwgY29udGFpbmVyLnNlZ21lbnRzLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IGNvbnRhaW5lZVBhdGhzLnNsaWNlKGNvbnRhaW5lci5zZWdtZW50cy5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKCFlcXVhbFBhdGgoY29udGFpbmVyLnNlZ21lbnRzLCBjdXJyZW50KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5lci5jaGlsZHJlbltQUklNQVJZX09VVExFVF0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5zU2VnbWVudEdyb3VwSGVscGVyKGNvbnRhaW5lci5jaGlsZHJlbltQUklNQVJZX09VVExFVF0sIGNvbnRhaW5lZSwgbmV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBSZXByZXNlbnRzIHRoZSBwYXJzZWQgVVJMLlxuICAgICAqXG4gICAgICogU2luY2UgYSByb3V0ZXIgc3RhdGUgaXMgYSB0cmVlLCBhbmQgdGhlIFVSTCBpcyBub3RoaW5nIGJ1dCBhIHNlcmlhbGl6ZWQgc3RhdGUsIHRoZSBVUkwgaXMgYVxuICAgICAqIHNlcmlhbGl6ZWQgdHJlZS5cbiAgICAgKiBVcmxUcmVlIGlzIGEgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBwcm92aWRlcyBhIGxvdCBvZiBhZmZvcmRhbmNlcyBpbiBkZWFsaW5nIHdpdGggVVJMc1xuICAgICAqXG4gICAgICogQHVzYWdlTm90ZXNcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogQENvbXBvbmVudCh7dGVtcGxhdGVVcmw6J3RlbXBsYXRlLmh0bWwnfSlcbiAgICAgKiBjbGFzcyBNeUNvbXBvbmVudCB7XG4gICAgICogICBjb25zdHJ1Y3Rvcihyb3V0ZXI6IFJvdXRlcikge1xuICAgICAqICAgICBjb25zdCB0cmVlOiBVcmxUcmVlID1cbiAgICAgKiAgICAgICByb3V0ZXIucGFyc2VVcmwoJy90ZWFtLzMzLyh1c2VyL3ZpY3Rvci8vc3VwcG9ydDpoZWxwKT9kZWJ1Zz10cnVlI2ZyYWdtZW50Jyk7XG4gICAgICogICAgIGNvbnN0IGYgPSB0cmVlLmZyYWdtZW50OyAvLyByZXR1cm4gJ2ZyYWdtZW50J1xuICAgICAqICAgICBjb25zdCBxID0gdHJlZS5xdWVyeVBhcmFtczsgLy8gcmV0dXJucyB7ZGVidWc6ICd0cnVlJ31cbiAgICAgKiAgICAgY29uc3QgZzogVXJsU2VnbWVudEdyb3VwID0gdHJlZS5yb290LmNoaWxkcmVuW1BSSU1BUllfT1VUTEVUXTtcbiAgICAgKiAgICAgY29uc3QgczogVXJsU2VnbWVudFtdID0gZy5zZWdtZW50czsgLy8gcmV0dXJucyAyIHNlZ21lbnRzICd0ZWFtJyBhbmQgJzMzJ1xuICAgICAqICAgICBnLmNoaWxkcmVuW1BSSU1BUllfT1VUTEVUXS5zZWdtZW50czsgLy8gcmV0dXJucyAyIHNlZ21lbnRzICd1c2VyJyBhbmQgJ3ZpY3RvcidcbiAgICAgKiAgICAgZy5jaGlsZHJlblsnc3VwcG9ydCddLnNlZ21lbnRzOyAvLyByZXR1cm4gMSBzZWdtZW50ICdoZWxwJ1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgVXJsVHJlZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBmdW5jdGlvbiBVcmxUcmVlKFxuICAgICAgICAvKiogVGhlIHJvb3Qgc2VnbWVudCBncm91cCBvZiB0aGUgVVJMIHRyZWUgKi9cbiAgICAgICAgcm9vdCwgXG4gICAgICAgIC8qKiBUaGUgcXVlcnkgcGFyYW1zIG9mIHRoZSBVUkwgKi9cbiAgICAgICAgcXVlcnlQYXJhbXMsIFxuICAgICAgICAvKiogVGhlIGZyYWdtZW50IG9mIHRoZSBVUkwgKi9cbiAgICAgICAgZnJhZ21lbnQpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5UGFyYW1zID0gcXVlcnlQYXJhbXM7XG4gICAgICAgICAgICB0aGlzLmZyYWdtZW50ID0gZnJhZ21lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVybFRyZWUucHJvdG90eXBlLCBcInF1ZXJ5UGFyYW1NYXBcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9xdWVyeVBhcmFtTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXJ5UGFyYW1NYXAgPSBjb252ZXJ0VG9QYXJhbU1hcCh0aGlzLnF1ZXJ5UGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJ5UGFyYW1NYXA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgVXJsVHJlZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBERUZBVUxUX1NFUklBTElaRVIuc2VyaWFsaXplKHRoaXMpOyB9O1xuICAgICAgICByZXR1cm4gVXJsVHJlZTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogUmVwcmVzZW50cyB0aGUgcGFyc2VkIFVSTCBzZWdtZW50IGdyb3VwLlxuICAgICAqXG4gICAgICogU2VlIGBVcmxUcmVlYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgVXJsU2VnbWVudEdyb3VwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBVcmxTZWdtZW50R3JvdXAoXG4gICAgICAgIC8qKiBUaGUgVVJMIHNlZ21lbnRzIG9mIHRoaXMgZ3JvdXAuIFNlZSBgVXJsU2VnbWVudGAgZm9yIG1vcmUgaW5mb3JtYXRpb24gKi9cbiAgICAgICAgc2VnbWVudHMsIFxuICAgICAgICAvKiogVGhlIGxpc3Qgb2YgY2hpbGRyZW4gb2YgdGhpcyBncm91cCAqL1xuICAgICAgICBjaGlsZHJlbikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuc2VnbWVudHMgPSBzZWdtZW50cztcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgICAgIC8qKiBUaGUgcGFyZW50IG5vZGUgaW4gdGhlIHVybCB0cmVlICovXG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICBmb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gdi5wYXJlbnQgPSBfdGhpczsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIHNlZ21lbnQgaGFzIGNoaWxkIHNlZ21lbnRzICovXG4gICAgICAgIFVybFNlZ21lbnRHcm91cC5wcm90b3R5cGUuaGFzQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm51bWJlck9mQ2hpbGRyZW4gPiAwOyB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVXJsU2VnbWVudEdyb3VwLnByb3RvdHlwZSwgXCJudW1iZXJPZkNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgIC8qKiBOdW1iZXIgb2YgY2hpbGQgc2VnbWVudHMgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gT2JqZWN0LmtleXModGhpcy5jaGlsZHJlbikubGVuZ3RoOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgVXJsU2VnbWVudEdyb3VwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlcmlhbGl6ZVBhdGhzKHRoaXMpOyB9O1xuICAgICAgICByZXR1cm4gVXJsU2VnbWVudEdyb3VwO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBSZXByZXNlbnRzIGEgc2luZ2xlIFVSTCBzZWdtZW50LlxuICAgICAqXG4gICAgICogQSBVcmxTZWdtZW50IGlzIGEgcGFydCBvZiBhIFVSTCBiZXR3ZWVuIHRoZSB0d28gc2xhc2hlcy4gSXQgY29udGFpbnMgYSBwYXRoIGFuZCB0aGUgbWF0cml4XG4gICAgICogcGFyYW1ldGVycyBhc3NvY2lhdGVkIHdpdGggdGhlIHNlZ21lbnQuXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqwqAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogQENvbXBvbmVudCh7dGVtcGxhdGVVcmw6J3RlbXBsYXRlLmh0bWwnfSlcbiAgICAgKiBjbGFzcyBNeUNvbXBvbmVudCB7XG4gICAgICogICBjb25zdHJ1Y3Rvcihyb3V0ZXI6IFJvdXRlcikge1xuICAgICAqICAgICBjb25zdCB0cmVlOiBVcmxUcmVlID0gcm91dGVyLnBhcnNlVXJsKCcvdGVhbTtpZD0zMycpO1xuICAgICAqICAgICBjb25zdCBnOiBVcmxTZWdtZW50R3JvdXAgPSB0cmVlLnJvb3QuY2hpbGRyZW5bUFJJTUFSWV9PVVRMRVRdO1xuICAgICAqICAgICBjb25zdCBzOiBVcmxTZWdtZW50W10gPSBnLnNlZ21lbnRzO1xuICAgICAqICAgICBzWzBdLnBhdGg7IC8vIHJldHVybnMgJ3RlYW0nXG4gICAgICogICAgIHNbMF0ucGFyYW1ldGVyczsgLy8gcmV0dXJucyB7aWQ6IDMzfVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgVXJsU2VnbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVXJsU2VnbWVudChcbiAgICAgICAgLyoqIFRoZSBwYXRoIHBhcnQgb2YgYSBVUkwgc2VnbWVudCAqL1xuICAgICAgICBwYXRoLCBcbiAgICAgICAgLyoqIFRoZSBtYXRyaXggcGFyYW1ldGVycyBhc3NvY2lhdGVkIHdpdGggYSBzZWdtZW50ICovXG4gICAgICAgIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVcmxTZWdtZW50LnByb3RvdHlwZSwgXCJwYXJhbWV0ZXJNYXBcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9wYXJhbWV0ZXJNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyYW1ldGVyTWFwID0gY29udmVydFRvUGFyYW1NYXAodGhpcy5wYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtZXRlck1hcDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICBVcmxTZWdtZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlcmlhbGl6ZVBhdGgodGhpcyk7IH07XG4gICAgICAgIHJldHVybiBVcmxTZWdtZW50O1xuICAgIH0oKSk7XG4gICAgZnVuY3Rpb24gZXF1YWxTZWdtZW50cyhhcywgYnMpIHtcbiAgICAgICAgcmV0dXJuIGVxdWFsUGF0aChhcywgYnMpICYmIGFzLmV2ZXJ5KGZ1bmN0aW9uIChhLCBpKSB7IHJldHVybiBzaGFsbG93RXF1YWwoYS5wYXJhbWV0ZXJzLCBic1tpXS5wYXJhbWV0ZXJzKTsgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVxdWFsUGF0aChhcywgYnMpIHtcbiAgICAgICAgaWYgKGFzLmxlbmd0aCAhPT0gYnMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gYXMuZXZlcnkoZnVuY3Rpb24gKGEsIGkpIHsgcmV0dXJuIGEucGF0aCA9PT0gYnNbaV0ucGF0aDsgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcENoaWxkcmVuSW50b0FycmF5KHNlZ21lbnQsIGZuKSB7XG4gICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgZm9yRWFjaChzZWdtZW50LmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQsIGNoaWxkT3V0bGV0KSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRPdXRsZXQgPT09IFBSSU1BUllfT1VUTEVUKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChmbihjaGlsZCwgY2hpbGRPdXRsZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGZvckVhY2goc2VnbWVudC5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkLCBjaGlsZE91dGxldCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkT3V0bGV0ICE9PSBQUklNQVJZX09VVExFVCkge1xuICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoZm4oY2hpbGQsIGNoaWxkT3V0bGV0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFNlcmlhbGl6ZXMgYW5kIGRlc2VyaWFsaXplcyBhIFVSTCBzdHJpbmcgaW50byBhIFVSTCB0cmVlLlxuICAgICAqXG4gICAgICogVGhlIHVybCBzZXJpYWxpemF0aW9uIHN0cmF0ZWd5IGlzIGN1c3RvbWl6YWJsZS4gWW91IGNhblxuICAgICAqIG1ha2UgYWxsIFVSTHMgY2FzZSBpbnNlbnNpdGl2ZSBieSBwcm92aWRpbmcgYSBjdXN0b20gVXJsU2VyaWFsaXplci5cbiAgICAgKlxuICAgICAqIFNlZSBgRGVmYXVsdFVybFNlcmlhbGl6ZXJgIGZvciBhbiBleGFtcGxlIG9mIGEgVVJMIHNlcmlhbGl6ZXIuXG4gICAgICpcbiAgICAgKiBAcHVibGljQXBpXG4gICAgICovXG4gICAgdmFyIFVybFNlcmlhbGl6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFVybFNlcmlhbGl6ZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVybFNlcmlhbGl6ZXI7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIEEgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYFVybFNlcmlhbGl6ZXJgLlxuICAgICAqXG4gICAgICogRXhhbXBsZSBVUkxzOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogL2luYm94LzMzKHBvcHVwOmNvbXBvc2UpXG4gICAgICogL2luYm94LzMzO29wZW49dHJ1ZS9tZXNzYWdlcy80NFxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogRGVmYXVsdFVybFNlcmlhbGl6ZXIgdXNlcyBwYXJlbnRoZXNlcyB0byBzZXJpYWxpemUgc2Vjb25kYXJ5IHNlZ21lbnRzIChlLmcuLCBwb3B1cDpjb21wb3NlKSwgdGhlXG4gICAgICogY29sb24gc3ludGF4IHRvIHNwZWNpZnkgdGhlIG91dGxldCwgYW5kIHRoZSAnO3BhcmFtZXRlcj12YWx1ZScgc3ludGF4IChlLmcuLCBvcGVuPXRydWUpIHRvXG4gICAgICogc3BlY2lmeSByb3V0ZSBzcGVjaWZpYyBwYXJhbWV0ZXJzLlxuICAgICAqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBEZWZhdWx0VXJsU2VyaWFsaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRGVmYXVsdFVybFNlcmlhbGl6ZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIFBhcnNlcyBhIHVybCBpbnRvIGEgYFVybFRyZWVgICovXG4gICAgICAgIERlZmF1bHRVcmxTZXJpYWxpemVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgIHZhciBwID0gbmV3IFVybFBhcnNlcih1cmwpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVcmxUcmVlKHAucGFyc2VSb290U2VnbWVudCgpLCBwLnBhcnNlUXVlcnlQYXJhbXMoKSwgcC5wYXJzZUZyYWdtZW50KCkpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQ29udmVydHMgYSBgVXJsVHJlZWAgaW50byBhIHVybCAqL1xuICAgICAgICBEZWZhdWx0VXJsU2VyaWFsaXplci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKHRyZWUpIHtcbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gXCIvXCIgKyBzZXJpYWxpemVTZWdtZW50KHRyZWUucm9vdCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcXVlcnkgPSBzZXJpYWxpemVRdWVyeVBhcmFtcyh0cmVlLnF1ZXJ5UGFyYW1zKTtcbiAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IHR5cGVvZiB0cmVlLmZyYWdtZW50ID09PSBcInN0cmluZ1wiID8gXCIjXCIgKyBlbmNvZGVVcmlGcmFnbWVudCh0cmVlLmZyYWdtZW50KSA6ICcnO1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyBzZWdtZW50ICsgcXVlcnkgKyBmcmFnbWVudDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIERlZmF1bHRVcmxTZXJpYWxpemVyO1xuICAgIH0oKSk7XG4gICAgdmFyIERFRkFVTFRfU0VSSUFMSVpFUiA9IG5ldyBEZWZhdWx0VXJsU2VyaWFsaXplcigpO1xuICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZVBhdGhzKHNlZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIHNlZ21lbnQuc2VnbWVudHMubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBzZXJpYWxpemVQYXRoKHApOyB9KS5qb2luKCcvJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZVNlZ21lbnQoc2VnbWVudCwgcm9vdCkge1xuICAgICAgICBpZiAoIXNlZ21lbnQuaGFzQ2hpbGRyZW4oKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVBhdGhzKHNlZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb290KSB7XG4gICAgICAgICAgICB2YXIgcHJpbWFyeSA9IHNlZ21lbnQuY2hpbGRyZW5bUFJJTUFSWV9PVVRMRVRdID9cbiAgICAgICAgICAgICAgICBzZXJpYWxpemVTZWdtZW50KHNlZ21lbnQuY2hpbGRyZW5bUFJJTUFSWV9PVVRMRVRdLCBmYWxzZSkgOlxuICAgICAgICAgICAgICAgICcnO1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuXzEgPSBbXTtcbiAgICAgICAgICAgIGZvckVhY2goc2VnbWVudC5jaGlsZHJlbiwgZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgICAgICAgICBpZiAoayAhPT0gUFJJTUFSWV9PVVRMRVQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5fMS5wdXNoKGsgKyBcIjpcIiArIHNlcmlhbGl6ZVNlZ21lbnQodiwgZmFsc2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbl8xLmxlbmd0aCA+IDAgPyBwcmltYXJ5ICsgXCIoXCIgKyBjaGlsZHJlbl8xLmpvaW4oJy8vJykgKyBcIilcIiA6IHByaW1hcnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBtYXBDaGlsZHJlbkludG9BcnJheShzZWdtZW50LCBmdW5jdGlvbiAodiwgaykge1xuICAgICAgICAgICAgICAgIGlmIChrID09PSBQUklNQVJZX09VVExFVCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3NlcmlhbGl6ZVNlZ21lbnQoc2VnbWVudC5jaGlsZHJlbltQUklNQVJZX09VVExFVF0sIGZhbHNlKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbayArIFwiOlwiICsgc2VyaWFsaXplU2VnbWVudCh2LCBmYWxzZSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplUGF0aHMoc2VnbWVudCkgKyBcIi8oXCIgKyBjaGlsZHJlbi5qb2luKCcvLycpICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlcyBhIFVSSSBzdHJpbmcgd2l0aCB0aGUgZGVmYXVsdCBlbmNvZGluZy4gVGhpcyBmdW5jdGlvbiB3aWxsIG9ubHkgZXZlciBiZSBjYWxsZWQgZnJvbVxuICAgICAqIGBlbmNvZGVVcmlRdWVyeWAgb3IgYGVuY29kZVVyaVNlZ21lbnRgIGFzIGl0J3MgdGhlIGJhc2Ugc2V0IG9mIGVuY29kaW5ncyB0byBiZSB1c2VkLiBXZSBuZWVkXG4gICAgICogYSBjdXN0b20gZW5jb2RpbmcgYmVjYXVzZSBlbmNvZGVVUklDb21wb25lbnQgaXMgdG9vIGFnZ3Jlc3NpdmUgYW5kIGVuY29kZXMgc3R1ZmYgdGhhdCBkb2Vzbid0XG4gICAgICogaGF2ZSB0byBiZSBlbmNvZGVkIHBlciBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5jb2RlVXJpU3RyaW5nKHMpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyU0MC9nLCAnQCcpXG4gICAgICAgICAgICAucmVwbGFjZSgvJTNBL2dpLCAnOicpXG4gICAgICAgICAgICAucmVwbGFjZSgvJTI0L2csICckJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8lMkMvZ2ksICcsJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIHVzZWQgdG8gZW5jb2RlIGJvdGgga2V5cyBhbmQgdmFsdWVzIGluIGEgcXVlcnkgc3RyaW5nIGtleS92YWx1ZS4gSW5cbiAgICAgKiB0aGUgZm9sbG93aW5nIFVSTCwgeW91IG5lZWQgdG8gY2FsbCBlbmNvZGVVcmlRdWVyeSBvbiBcImtcIiBhbmQgXCJ2XCI6XG4gICAgICpcbiAgICAgKiBodHRwOi8vd3d3LnNpdGUub3JnL2h0bWw7bWs9bXY/az12I2ZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbmNvZGVVcmlRdWVyeShzKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVVcmlTdHJpbmcocykucmVwbGFjZSgvJTNCL2dpLCAnOycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSB1c2VkIHRvIGVuY29kZSBhIFVSTCBmcmFnbWVudC4gSW4gdGhlIGZvbGxvd2luZyBVUkwsIHlvdSBuZWVkIHRvIGNhbGxcbiAgICAgKiBlbmNvZGVVcmlGcmFnbWVudCBvbiBcImZcIjpcbiAgICAgKlxuICAgICAqIGh0dHA6Ly93d3cuc2l0ZS5vcmcvaHRtbDttaz1tdj9rPXYjZlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVuY29kZVVyaUZyYWdtZW50KHMpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVVSSShzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgcnVuIG9uIGFueSBVUkkgc2VnbWVudCBhcyB3ZWxsIGFzIHRoZSBrZXkgYW5kIHZhbHVlIGluIGEga2V5L3ZhbHVlXG4gICAgICogcGFpciBmb3IgbWF0cml4IHBhcmFtcy4gSW4gdGhlIGZvbGxvd2luZyBVUkwsIHlvdSBuZWVkIHRvIGNhbGwgZW5jb2RlVXJpU2VnbWVudCBvbiBcImh0bWxcIixcbiAgICAgKiBcIm1rXCIsIGFuZCBcIm12XCI6XG4gICAgICpcbiAgICAgKiBodHRwOi8vd3d3LnNpdGUub3JnL2h0bWw7bWs9bXY/az12I2ZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbmNvZGVVcmlTZWdtZW50KHMpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVVyaVN0cmluZyhzKS5yZXBsYWNlKC9cXCgvZywgJyUyOCcpLnJlcGxhY2UoL1xcKS9nLCAnJTI5JykucmVwbGFjZSgvJTI2L2dpLCAnJicpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGUocykge1xuICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHMpO1xuICAgIH1cbiAgICAvLyBRdWVyeSBrZXlzL3ZhbHVlcyBzaG91bGQgaGF2ZSB0aGUgXCIrXCIgcmVwbGFjZWQgZmlyc3QsIGFzIFwiK1wiIGluIGEgcXVlcnkgc3RyaW5nIGlzIFwiIFwiLlxuICAgIC8vIGRlY29kZVVSSUNvbXBvbmVudCBmdW5jdGlvbiB3aWxsIG5vdCBkZWNvZGUgXCIrXCIgYXMgYSBzcGFjZS5cbiAgICBmdW5jdGlvbiBkZWNvZGVRdWVyeShzKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGUocy5yZXBsYWNlKC9cXCsvZywgJyUyMCcpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2VyaWFsaXplUGF0aChwYXRoKSB7XG4gICAgICAgIHJldHVybiBcIlwiICsgZW5jb2RlVXJpU2VnbWVudChwYXRoLnBhdGgpICsgc2VyaWFsaXplTWF0cml4UGFyYW1zKHBhdGgucGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZU1hdHJpeFBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHBhcmFtcylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gXCI7XCIgKyBlbmNvZGVVcmlTZWdtZW50KGtleSkgKyBcIj1cIiArIGVuY29kZVVyaVNlZ21lbnQocGFyYW1zW2tleV0pOyB9KVxuICAgICAgICAgICAgLmpvaW4oJycpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXJpYWxpemVRdWVyeVBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgdmFyIHN0clBhcmFtcyA9IE9iamVjdC5rZXlzKHBhcmFtcykubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJhbXNbbmFtZV07XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgP1xuICAgICAgICAgICAgICAgIHZhbHVlLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gZW5jb2RlVXJpUXVlcnkobmFtZSkgKyBcIj1cIiArIGVuY29kZVVyaVF1ZXJ5KHYpOyB9KS5qb2luKCcmJykgOlxuICAgICAgICAgICAgICAgIGVuY29kZVVyaVF1ZXJ5KG5hbWUpICsgXCI9XCIgKyBlbmNvZGVVcmlRdWVyeSh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3RyUGFyYW1zLmxlbmd0aCA/IFwiP1wiICsgc3RyUGFyYW1zLmpvaW4oXCImXCIpIDogJyc7XG4gICAgfVxuICAgIHZhciBTRUdNRU5UX1JFID0gL15bXlxcLygpPzs9I10rLztcbiAgICBmdW5jdGlvbiBtYXRjaFNlZ21lbnRzKHN0cikge1xuICAgICAgICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2goU0VHTUVOVF9SRSk7XG4gICAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzBdIDogJyc7XG4gICAgfVxuICAgIHZhciBRVUVSWV9QQVJBTV9SRSA9IC9eW149PyYjXSsvO1xuICAgIC8vIFJldHVybiB0aGUgbmFtZSBvZiB0aGUgcXVlcnkgcGFyYW0gYXQgdGhlIHN0YXJ0IG9mIHRoZSBzdHJpbmcgb3IgYW4gZW1wdHkgc3RyaW5nXG4gICAgZnVuY3Rpb24gbWF0Y2hRdWVyeVBhcmFtcyhzdHIpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKFFVRVJZX1BBUkFNX1JFKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMF0gOiAnJztcbiAgICB9XG4gICAgdmFyIFFVRVJZX1BBUkFNX1ZBTFVFX1JFID0gL15bXj8mI10rLztcbiAgICAvLyBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBxdWVyeSBwYXJhbSBhdCB0aGUgc3RhcnQgb2YgdGhlIHN0cmluZyBvciBhbiBlbXB0eSBzdHJpbmdcbiAgICBmdW5jdGlvbiBtYXRjaFVybFF1ZXJ5UGFyYW1WYWx1ZShzdHIpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKFFVRVJZX1BBUkFNX1ZBTFVFX1JFKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMF0gOiAnJztcbiAgICB9XG4gICAgdmFyIFVybFBhcnNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVXJsUGFyc2VyKHVybCkge1xuICAgICAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgICAgICB0aGlzLnJlbWFpbmluZyA9IHVybDtcbiAgICAgICAgfVxuICAgICAgICBVcmxQYXJzZXIucHJvdG90eXBlLnBhcnNlUm9vdFNlZ21lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVPcHRpb25hbCgnLycpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVtYWluaW5nID09PSAnJyB8fCB0aGlzLnBlZWtTdGFydHNXaXRoKCc/JykgfHwgdGhpcy5wZWVrU3RhcnRzV2l0aCgnIycpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVcmxTZWdtZW50R3JvdXAoW10sIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSByb290IHNlZ21lbnQgZ3JvdXAgbmV2ZXIgaGFzIHNlZ21lbnRzXG4gICAgICAgICAgICByZXR1cm4gbmV3IFVybFNlZ21lbnRHcm91cChbXSwgdGhpcy5wYXJzZUNoaWxkcmVuKCkpO1xuICAgICAgICB9O1xuICAgICAgICBVcmxQYXJzZXIucHJvdG90eXBlLnBhcnNlUXVlcnlQYXJhbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWwoJz8nKSkge1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZVF1ZXJ5UGFyYW0ocGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9IHdoaWxlICh0aGlzLmNvbnN1bWVPcHRpb25hbCgnJicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgIH07XG4gICAgICAgIFVybFBhcnNlci5wcm90b3R5cGUucGFyc2VGcmFnbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVPcHRpb25hbCgnIycpID8gZGVjb2RlVVJJQ29tcG9uZW50KHRoaXMucmVtYWluaW5nKSA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIFVybFBhcnNlci5wcm90b3R5cGUucGFyc2VDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlbWFpbmluZyA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVPcHRpb25hbCgnLycpO1xuICAgICAgICAgICAgdmFyIHNlZ21lbnRzID0gW107XG4gICAgICAgICAgICBpZiAoIXRoaXMucGVla1N0YXJ0c1dpdGgoJygnKSkge1xuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2godGhpcy5wYXJzZVNlZ21lbnQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5wZWVrU3RhcnRzV2l0aCgnLycpICYmICF0aGlzLnBlZWtTdGFydHNXaXRoKCcvLycpICYmICF0aGlzLnBlZWtTdGFydHNXaXRoKCcvKCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYXB0dXJlKCcvJyk7XG4gICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaCh0aGlzLnBhcnNlU2VnbWVudCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMucGVla1N0YXJ0c1dpdGgoJy8oJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhcHR1cmUoJy8nKTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IHRoaXMucGFyc2VQYXJlbnModHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5wZWVrU3RhcnRzV2l0aCgnKCcpKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gdGhpcy5wYXJzZVBhcmVucyhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoID4gMCB8fCBPYmplY3Qua2V5cyhjaGlsZHJlbikubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJlc1tQUklNQVJZX09VVExFVF0gPSBuZXcgVXJsU2VnbWVudEdyb3VwKHNlZ21lbnRzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgICAgICAvLyBwYXJzZSBhIHNlZ21lbnQgd2l0aCBpdHMgbWF0cml4IHBhcmFtZXRlcnNcbiAgICAgICAgLy8gaWUgYG5hbWU7azE9djE7azJgXG4gICAgICAgIFVybFBhcnNlci5wcm90b3R5cGUucGFyc2VTZWdtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhdGggPSBtYXRjaFNlZ21lbnRzKHRoaXMucmVtYWluaW5nKTtcbiAgICAgICAgICAgIGlmIChwYXRoID09PSAnJyAmJiB0aGlzLnBlZWtTdGFydHNXaXRoKCc7JykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbXB0eSBwYXRoIHVybCBzZWdtZW50IGNhbm5vdCBoYXZlIHBhcmFtZXRlcnM6ICdcIiArIHRoaXMucmVtYWluaW5nICsgXCInLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2FwdHVyZShwYXRoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXJsU2VnbWVudChkZWNvZGUocGF0aCksIHRoaXMucGFyc2VNYXRyaXhQYXJhbXMoKSk7XG4gICAgICAgIH07XG4gICAgICAgIFVybFBhcnNlci5wcm90b3R5cGUucGFyc2VNYXRyaXhQYXJhbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5jb25zdW1lT3B0aW9uYWwoJzsnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VQYXJhbShwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgfTtcbiAgICAgICAgVXJsUGFyc2VyLnByb3RvdHlwZS5wYXJzZVBhcmFtID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgICAgdmFyIGtleSA9IG1hdGNoU2VnbWVudHModGhpcy5yZW1haW5pbmcpO1xuICAgICAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNhcHR1cmUoa2V5KTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9ICcnO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uc3VtZU9wdGlvbmFsKCc9JykpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVNYXRjaCA9IG1hdGNoU2VnbWVudHModGhpcy5yZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVNYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYXB0dXJlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJhbXNbZGVjb2RlKGtleSldID0gZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUGFyc2UgYSBzaW5nbGUgcXVlcnkgcGFyYW1ldGVyIGBuYW1lWz12YWx1ZV1gXG4gICAgICAgIFVybFBhcnNlci5wcm90b3R5cGUucGFyc2VRdWVyeVBhcmFtID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgICAgdmFyIGtleSA9IG1hdGNoUXVlcnlQYXJhbXModGhpcy5yZW1haW5pbmcpO1xuICAgICAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNhcHR1cmUoa2V5KTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9ICcnO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uc3VtZU9wdGlvbmFsKCc9JykpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVNYXRjaCA9IG1hdGNoVXJsUXVlcnlQYXJhbVZhbHVlKHRoaXMucmVtYWluaW5nKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlTWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FwdHVyZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRlY29kZWRLZXkgPSBkZWNvZGVRdWVyeShrZXkpO1xuICAgICAgICAgICAgdmFyIGRlY29kZWRWYWwgPSBkZWNvZGVRdWVyeSh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAocGFyYW1zLmhhc093blByb3BlcnR5KGRlY29kZWRLZXkpKSB7XG4gICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRvIGV4aXN0aW5nIHZhbHVlc1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50VmFsID0gcGFyYW1zW2RlY29kZWRLZXldO1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjdXJyZW50VmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsID0gW2N1cnJlbnRWYWxdO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXNbZGVjb2RlZEtleV0gPSBjdXJyZW50VmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50VmFsLnB1c2goZGVjb2RlZFZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgdmFsdWVcbiAgICAgICAgICAgICAgICBwYXJhbXNbZGVjb2RlZEtleV0gPSBkZWNvZGVkVmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBwYXJzZSBgKGEvYi8vb3V0bGV0X25hbWU6Yy9kKWBcbiAgICAgICAgVXJsUGFyc2VyLnByb3RvdHlwZS5wYXJzZVBhcmVucyA9IGZ1bmN0aW9uIChhbGxvd1ByaW1hcnkpIHtcbiAgICAgICAgICAgIHZhciBzZWdtZW50cyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5jYXB0dXJlKCcoJyk7XG4gICAgICAgICAgICB3aGlsZSAoIXRoaXMuY29uc3VtZU9wdGlvbmFsKCcpJykgJiYgdGhpcy5yZW1haW5pbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoID0gbWF0Y2hTZWdtZW50cyh0aGlzLnJlbWFpbmluZyk7XG4gICAgICAgICAgICAgICAgdmFyIG5leHQgPSB0aGlzLnJlbWFpbmluZ1twYXRoLmxlbmd0aF07XG4gICAgICAgICAgICAgICAgLy8gaWYgaXMgaXMgbm90IG9uZSBvZiB0aGVzZSBjaGFyYWN0ZXJzLCB0aGVuIHRoZSBzZWdtZW50IHdhcyB1bmVzY2FwZWRcbiAgICAgICAgICAgICAgICAvLyBvciB0aGUgZ3JvdXAgd2FzIG5vdCBjbG9zZWRcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAhPT0gJy8nICYmIG5leHQgIT09ICcpJyAmJiBuZXh0ICE9PSAnOycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHBhcnNlIHVybCAnXCIgKyB0aGlzLnVybCArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG91dGxldE5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGguaW5kZXhPZignOicpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0bGV0TmFtZSA9IHBhdGguc3Vic3RyKDAsIHBhdGguaW5kZXhPZignOicpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYXB0dXJlKG91dGxldE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhcHR1cmUoJzonKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYWxsb3dQcmltYXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIG91dGxldE5hbWUgPSBQUklNQVJZX09VVExFVDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wYXJzZUNoaWxkcmVuKCk7XG4gICAgICAgICAgICAgICAgc2VnbWVudHNbb3V0bGV0TmFtZV0gPSBPYmplY3Qua2V5cyhjaGlsZHJlbikubGVuZ3RoID09PSAxID8gY2hpbGRyZW5bUFJJTUFSWV9PVVRMRVRdIDpcbiAgICAgICAgICAgICAgICAgICAgbmV3IFVybFNlZ21lbnRHcm91cChbXSwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZU9wdGlvbmFsKCcvLycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlZ21lbnRzO1xuICAgICAgICB9O1xuICAgICAgICBVcmxQYXJzZXIucHJvdG90eXBlLnBlZWtTdGFydHNXaXRoID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gdGhpcy5yZW1haW5pbmcuc3RhcnRzV2l0aChzdHIpOyB9O1xuICAgICAgICAvLyBDb25zdW1lcyB0aGUgcHJlZml4IHdoZW4gaXQgaXMgcHJlc2VudCBhbmQgcmV0dXJucyB3aGV0aGVyIGl0IGhhcyBiZWVuIGNvbnN1bWVkXG4gICAgICAgIFVybFBhcnNlci5wcm90b3R5cGUuY29uc3VtZU9wdGlvbmFsID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgaWYgKHRoaXMucGVla1N0YXJ0c1dpdGgoc3RyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtYWluaW5nID0gdGhpcy5yZW1haW5pbmcuc3Vic3RyaW5nKHN0ci5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBVcmxQYXJzZXIucHJvdG90eXBlLmNhcHR1cmUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29uc3VtZU9wdGlvbmFsKHN0cikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBcXFwiXCIgKyBzdHIgKyBcIlxcXCIuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVXJsUGFyc2VyO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIFRyZWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRyZWUocm9vdCkge1xuICAgICAgICAgICAgdGhpcy5fcm9vdCA9IHJvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyZWUucHJvdG90eXBlLCBcInJvb3RcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yb290LnZhbHVlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgVHJlZS5wcm90b3R5cGUucGFyZW50ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHZhciBwID0gdGhpcy5wYXRoRnJvbVJvb3QodCk7XG4gICAgICAgICAgICByZXR1cm4gcC5sZW5ndGggPiAxID8gcFtwLmxlbmd0aCAtIDJdIDogbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgVHJlZS5wcm90b3R5cGUuY2hpbGRyZW4gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdmFyIG4gPSBmaW5kTm9kZSh0LCB0aGlzLl9yb290KTtcbiAgICAgICAgICAgIHJldHVybiBuID8gbi5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQudmFsdWU7IH0pIDogW107XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIFRyZWUucHJvdG90eXBlLmZpcnN0Q2hpbGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdmFyIG4gPSBmaW5kTm9kZSh0LCB0aGlzLl9yb290KTtcbiAgICAgICAgICAgIHJldHVybiBuICYmIG4uY2hpbGRyZW4ubGVuZ3RoID4gMCA/IG4uY2hpbGRyZW5bMF0udmFsdWUgOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBUcmVlLnByb3RvdHlwZS5zaWJsaW5ncyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB2YXIgcCA9IGZpbmRQYXRoKHQsIHRoaXMuX3Jvb3QpO1xuICAgICAgICAgICAgaWYgKHAubGVuZ3RoIDwgMilcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB2YXIgYyA9IHBbcC5sZW5ndGggLSAyXS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudmFsdWU7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIGMuZmlsdGVyKGZ1bmN0aW9uIChjYykgeyByZXR1cm4gY2MgIT09IHQ7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBUcmVlLnByb3RvdHlwZS5wYXRoRnJvbVJvb3QgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gZmluZFBhdGgodCwgdGhpcy5fcm9vdCkubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnZhbHVlOyB9KTsgfTtcbiAgICAgICAgcmV0dXJuIFRyZWU7XG4gICAgfSgpKTtcbiAgICAvLyBERlMgZm9yIHRoZSBub2RlIG1hdGNoaW5nIHRoZSB2YWx1ZVxuICAgIGZ1bmN0aW9uIGZpbmROb2RlKHZhbHVlLCBub2RlKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICBpZiAodmFsdWUgPT09IG5vZGUudmFsdWUpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMobm9kZS5jaGlsZHJlbiksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZV8xID0gZmluZE5vZGUodmFsdWUsIGNoaWxkKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZV8xKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZV8xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFJldHVybiB0aGUgcGF0aCB0byB0aGUgbm9kZSB3aXRoIHRoZSBnaXZlbiB2YWx1ZSB1c2luZyBERlNcbiAgICBmdW5jdGlvbiBmaW5kUGF0aCh2YWx1ZSwgbm9kZSkge1xuICAgICAgICB2YXIgZV8yLCBfYTtcbiAgICAgICAgaWYgKHZhbHVlID09PSBub2RlLnZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIFtub2RlXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMobm9kZS5jaGlsZHJlbiksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IGZpbmRQYXRoKHZhbHVlLCBjaGlsZCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGgudW5zaGlmdChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICB2YXIgVHJlZU5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRyZWVOb2RlKHZhbHVlLCBjaGlsZHJlbikge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICAgIFRyZWVOb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiVHJlZU5vZGUoXCIgKyB0aGlzLnZhbHVlICsgXCIpXCI7IH07XG4gICAgICAgIHJldHVybiBUcmVlTm9kZTtcbiAgICB9KCkpO1xuICAgIC8vIFJldHVybiB0aGUgbGlzdCBvZiBUIGluZGV4ZWQgYnkgb3V0bGV0IG5hbWVcbiAgICBmdW5jdGlvbiBub2RlQ2hpbGRyZW5Bc01hcChub2RlKSB7XG4gICAgICAgIHZhciBtYXAgPSB7fTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIG1hcFtjaGlsZC52YWx1ZS5vdXRsZXRdID0gY2hpbGQ7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogUmVwcmVzZW50cyB0aGUgc3RhdGUgb2YgdGhlIHJvdXRlci5cbiAgICAgKlxuICAgICAqIFJvdXRlclN0YXRlIGlzIGEgdHJlZSBvZiBhY3RpdmF0ZWQgcm91dGVzLiBFdmVyeSBub2RlIGluIHRoaXMgdHJlZSBrbm93cyBhYm91dCB0aGUgXCJjb25zdW1lZFwiIFVSTFxuICAgICAqIHNlZ21lbnRzLCB0aGUgZXh0cmFjdGVkIHBhcmFtZXRlcnMsIGFuZCB0aGUgcmVzb2x2ZWQgZGF0YS5cbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIEBDb21wb25lbnQoe3RlbXBsYXRlVXJsOid0ZW1wbGF0ZS5odG1sJ30pXG4gICAgICogY2xhc3MgTXlDb21wb25lbnQge1xuICAgICAqICAgY29uc3RydWN0b3Iocm91dGVyOiBSb3V0ZXIpIHtcbiAgICAgKiAgICAgY29uc3Qgc3RhdGU6IFJvdXRlclN0YXRlID0gcm91dGVyLnJvdXRlclN0YXRlO1xuICAgICAqICAgICBjb25zdCByb290OiBBY3RpdmF0ZWRSb3V0ZSA9IHN0YXRlLnJvb3Q7XG4gICAgICogICAgIGNvbnN0IGNoaWxkID0gcm9vdC5maXJzdENoaWxkO1xuICAgICAqICAgICBjb25zdCBpZDogT2JzZXJ2YWJsZTxzdHJpbmc+ID0gY2hpbGQucGFyYW1zLm1hcChwID0+IHAuaWQpO1xuICAgICAqICAgICAvLy4uLlxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFNlZSBgQWN0aXZhdGVkUm91dGVgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBSb3V0ZXJTdGF0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFJvdXRlclN0YXRlLCBfc3VwZXIpO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIGZ1bmN0aW9uIFJvdXRlclN0YXRlKHJvb3QsIFxuICAgICAgICAvKiogVGhlIGN1cnJlbnQgc25hcHNob3Qgb2YgdGhlIHJvdXRlciBzdGF0ZSAqL1xuICAgICAgICBzbmFwc2hvdCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcm9vdCkgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLnNuYXBzaG90ID0gc25hcHNob3Q7XG4gICAgICAgICAgICBzZXRSb3V0ZXJTdGF0ZShfdGhpcywgcm9vdCk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgUm91dGVyU3RhdGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zbmFwc2hvdC50b1N0cmluZygpOyB9O1xuICAgICAgICByZXR1cm4gUm91dGVyU3RhdGU7XG4gICAgfShUcmVlKSk7XG4gICAgZnVuY3Rpb24gY3JlYXRlRW1wdHlTdGF0ZSh1cmxUcmVlLCByb290Q29tcG9uZW50KSB7XG4gICAgICAgIHZhciBzbmFwc2hvdCA9IGNyZWF0ZUVtcHR5U3RhdGVTbmFwc2hvdCh1cmxUcmVlLCByb290Q29tcG9uZW50KTtcbiAgICAgICAgdmFyIGVtcHR5VXJsID0gbmV3IHJ4anMuQmVoYXZpb3JTdWJqZWN0KFtuZXcgVXJsU2VnbWVudCgnJywge30pXSk7XG4gICAgICAgIHZhciBlbXB0eVBhcmFtcyA9IG5ldyByeGpzLkJlaGF2aW9yU3ViamVjdCh7fSk7XG4gICAgICAgIHZhciBlbXB0eURhdGEgPSBuZXcgcnhqcy5CZWhhdmlvclN1YmplY3Qoe30pO1xuICAgICAgICB2YXIgZW1wdHlRdWVyeVBhcmFtcyA9IG5ldyByeGpzLkJlaGF2aW9yU3ViamVjdCh7fSk7XG4gICAgICAgIHZhciBmcmFnbWVudCA9IG5ldyByeGpzLkJlaGF2aW9yU3ViamVjdCgnJyk7XG4gICAgICAgIHZhciBhY3RpdmF0ZWQgPSBuZXcgQWN0aXZhdGVkUm91dGUoZW1wdHlVcmwsIGVtcHR5UGFyYW1zLCBlbXB0eVF1ZXJ5UGFyYW1zLCBmcmFnbWVudCwgZW1wdHlEYXRhLCBQUklNQVJZX09VVExFVCwgcm9vdENvbXBvbmVudCwgc25hcHNob3Qucm9vdCk7XG4gICAgICAgIGFjdGl2YXRlZC5zbmFwc2hvdCA9IHNuYXBzaG90LnJvb3Q7XG4gICAgICAgIHJldHVybiBuZXcgUm91dGVyU3RhdGUobmV3IFRyZWVOb2RlKGFjdGl2YXRlZCwgW10pLCBzbmFwc2hvdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVtcHR5U3RhdGVTbmFwc2hvdCh1cmxUcmVlLCByb290Q29tcG9uZW50KSB7XG4gICAgICAgIHZhciBlbXB0eVBhcmFtcyA9IHt9O1xuICAgICAgICB2YXIgZW1wdHlEYXRhID0ge307XG4gICAgICAgIHZhciBlbXB0eVF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIHZhciBmcmFnbWVudCA9ICcnO1xuICAgICAgICB2YXIgYWN0aXZhdGVkID0gbmV3IEFjdGl2YXRlZFJvdXRlU25hcHNob3QoW10sIGVtcHR5UGFyYW1zLCBlbXB0eVF1ZXJ5UGFyYW1zLCBmcmFnbWVudCwgZW1wdHlEYXRhLCBQUklNQVJZX09VVExFVCwgcm9vdENvbXBvbmVudCwgbnVsbCwgdXJsVHJlZS5yb290LCAtMSwge30pO1xuICAgICAgICByZXR1cm4gbmV3IFJvdXRlclN0YXRlU25hcHNob3QoJycsIG5ldyBUcmVlTm9kZShhY3RpdmF0ZWQsIFtdKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogQ29udGFpbnMgdGhlIGluZm9ybWF0aW9uIGFib3V0IGEgcm91dGUgYXNzb2NpYXRlZCB3aXRoIGEgY29tcG9uZW50IGxvYWRlZCBpbiBhblxuICAgICAqIG91dGxldC4gIEFuIGBBY3RpdmF0ZWRSb3V0ZWAgY2FuIGFsc28gYmUgdXNlZCB0byB0cmF2ZXJzZSB0aGUgcm91dGVyIHN0YXRlIHRyZWUuXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgcm91dGVyL2FjdGl2YXRlZC1yb3V0ZS9tb2R1bGUudHMgcmVnaW9uPVwiYWN0aXZhdGVkLXJvdXRlXCJcbiAgICAgKiAgICAgaGVhZGVyPVwiYWN0aXZhdGVkLXJvdXRlLmNvbXBvbmVudC50c1wiIGxpbmVudW1zPVwiZmFsc2VcIn1cbiAgICAgKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgQWN0aXZhdGVkUm91dGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgZnVuY3Rpb24gQWN0aXZhdGVkUm91dGUoXG4gICAgICAgIC8qKiBBbiBvYnNlcnZhYmxlIG9mIHRoZSBVUkwgc2VnbWVudHMgbWF0Y2hlZCBieSB0aGlzIHJvdXRlICovXG4gICAgICAgIHVybCwgXG4gICAgICAgIC8qKiBBbiBvYnNlcnZhYmxlIG9mIHRoZSBtYXRyaXggcGFyYW1ldGVycyBzY29wZWQgdG8gdGhpcyByb3V0ZSAqL1xuICAgICAgICBwYXJhbXMsIFxuICAgICAgICAvKiogQW4gb2JzZXJ2YWJsZSBvZiB0aGUgcXVlcnkgcGFyYW1ldGVycyBzaGFyZWQgYnkgYWxsIHRoZSByb3V0ZXMgKi9cbiAgICAgICAgcXVlcnlQYXJhbXMsIFxuICAgICAgICAvKiogQW4gb2JzZXJ2YWJsZSBvZiB0aGUgVVJMIGZyYWdtZW50IHNoYXJlZCBieSBhbGwgdGhlIHJvdXRlcyAqL1xuICAgICAgICBmcmFnbWVudCwgXG4gICAgICAgIC8qKiBBbiBvYnNlcnZhYmxlIG9mIHRoZSBzdGF0aWMgYW5kIHJlc29sdmVkIGRhdGEgb2YgdGhpcyByb3V0ZS4gKi9cbiAgICAgICAgZGF0YSwgXG4gICAgICAgIC8qKiBUaGUgb3V0bGV0IG5hbWUgb2YgdGhlIHJvdXRlLiBJdCdzIGEgY29uc3RhbnQgKi9cbiAgICAgICAgb3V0bGV0LCBcbiAgICAgICAgLyoqIFRoZSBjb21wb25lbnQgb2YgdGhlIHJvdXRlLiBJdCdzIGEgY29uc3RhbnQgKi9cbiAgICAgICAgLy8gVE9ETyh2c2F2a2luKTogcmVtb3ZlIHxzdHJpbmdcbiAgICAgICAgY29tcG9uZW50LCBmdXR1cmVTbmFwc2hvdCkge1xuICAgICAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgICAgIHRoaXMucXVlcnlQYXJhbXMgPSBxdWVyeVBhcmFtcztcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnQgPSBmcmFnbWVudDtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICB0aGlzLm91dGxldCA9IG91dGxldDtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICAgICAgdGhpcy5fZnV0dXJlU25hcHNob3QgPSBmdXR1cmVTbmFwc2hvdDtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZhdGVkUm91dGUucHJvdG90eXBlLCBcInJvdXRlQ29uZmlnXCIsIHtcbiAgICAgICAgICAgIC8qKiBUaGUgY29uZmlndXJhdGlvbiB1c2VkIHRvIG1hdGNoIHRoaXMgcm91dGUgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZnV0dXJlU25hcHNob3Qucm91dGVDb25maWc7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZhdGVkUm91dGUucHJvdG90eXBlLCBcInJvb3RcIiwge1xuICAgICAgICAgICAgLyoqIFRoZSByb290IG9mIHRoZSByb3V0ZXIgc3RhdGUgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcm91dGVyU3RhdGUucm9vdDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RpdmF0ZWRSb3V0ZS5wcm90b3R5cGUsIFwicGFyZW50XCIsIHtcbiAgICAgICAgICAgIC8qKiBUaGUgcGFyZW50IG9mIHRoaXMgcm91dGUgaW4gdGhlIHJvdXRlciBzdGF0ZSB0cmVlICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3JvdXRlclN0YXRlLnBhcmVudCh0aGlzKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RpdmF0ZWRSb3V0ZS5wcm90b3R5cGUsIFwiZmlyc3RDaGlsZFwiLCB7XG4gICAgICAgICAgICAvKiogVGhlIGZpcnN0IGNoaWxkIG9mIHRoaXMgcm91dGUgaW4gdGhlIHJvdXRlciBzdGF0ZSB0cmVlICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3JvdXRlclN0YXRlLmZpcnN0Q2hpbGQodGhpcyk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZhdGVkUm91dGUucHJvdG90eXBlLCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgIC8qKiBUaGUgY2hpbGRyZW4gb2YgdGhpcyByb3V0ZSBpbiB0aGUgcm91dGVyIHN0YXRlIHRyZWUgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcm91dGVyU3RhdGUuY2hpbGRyZW4odGhpcyk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZhdGVkUm91dGUucHJvdG90eXBlLCBcInBhdGhGcm9tUm9vdFwiLCB7XG4gICAgICAgICAgICAvKiogVGhlIHBhdGggZnJvbSB0aGUgcm9vdCBvZiB0aGUgcm91dGVyIHN0YXRlIHRyZWUgdG8gdGhpcyByb3V0ZSAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yb3V0ZXJTdGF0ZS5wYXRoRnJvbVJvb3QodGhpcyk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZhdGVkUm91dGUucHJvdG90eXBlLCBcInBhcmFtTWFwXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcGFyYW1NYXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyYW1NYXAgPSB0aGlzLnBhcmFtcy5waXBlKG9wZXJhdG9ycy5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIGNvbnZlcnRUb1BhcmFtTWFwKHApOyB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJhbU1hcDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZhdGVkUm91dGUucHJvdG90eXBlLCBcInF1ZXJ5UGFyYW1NYXBcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9xdWVyeVBhcmFtTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXJ5UGFyYW1NYXAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWVyeVBhcmFtcy5waXBlKG9wZXJhdG9ycy5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIGNvbnZlcnRUb1BhcmFtTWFwKHApOyB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9xdWVyeVBhcmFtTWFwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIEFjdGl2YXRlZFJvdXRlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNuYXBzaG90ID8gdGhpcy5zbmFwc2hvdC50b1N0cmluZygpIDogXCJGdXR1cmUoXCIgKyB0aGlzLl9mdXR1cmVTbmFwc2hvdCArIFwiKVwiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQWN0aXZhdGVkUm91dGU7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmhlcml0ZWQgcGFyYW1zLCBkYXRhLCBhbmQgcmVzb2x2ZSBmb3IgYSBnaXZlbiByb3V0ZS5cbiAgICAgKiBCeSBkZWZhdWx0LCB0aGlzIG9ubHkgaW5oZXJpdHMgdmFsdWVzIHVwIHRvIHRoZSBuZWFyZXN0IHBhdGgtbGVzcyBvciBjb21wb25lbnQtbGVzcyByb3V0ZS5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmhlcml0ZWRQYXJhbXNEYXRhUmVzb2x2ZShyb3V0ZSwgcGFyYW1zSW5oZXJpdGFuY2VTdHJhdGVneSkge1xuICAgICAgICBpZiAocGFyYW1zSW5oZXJpdGFuY2VTdHJhdGVneSA9PT0gdm9pZCAwKSB7IHBhcmFtc0luaGVyaXRhbmNlU3RyYXRlZ3kgPSAnZW1wdHlPbmx5JzsgfVxuICAgICAgICB2YXIgcGF0aEZyb21Sb290ID0gcm91dGUucGF0aEZyb21Sb290O1xuICAgICAgICB2YXIgaW5oZXJpdGluZ1N0YXJ0aW5nRnJvbSA9IDA7XG4gICAgICAgIGlmIChwYXJhbXNJbmhlcml0YW5jZVN0cmF0ZWd5ICE9PSAnYWx3YXlzJykge1xuICAgICAgICAgICAgaW5oZXJpdGluZ1N0YXJ0aW5nRnJvbSA9IHBhdGhGcm9tUm9vdC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgd2hpbGUgKGluaGVyaXRpbmdTdGFydGluZ0Zyb20gPj0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gcGF0aEZyb21Sb290W2luaGVyaXRpbmdTdGFydGluZ0Zyb21dO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRfMSA9IHBhdGhGcm9tUm9vdFtpbmhlcml0aW5nU3RhcnRpbmdGcm9tIC0gMV07XG4gICAgICAgICAgICAgICAgLy8gY3VycmVudCByb3V0ZSBpcyBhbiBlbXB0eSBwYXRoID0+IGluaGVyaXRzIGl0cyBwYXJlbnQncyBwYXJhbXMgYW5kIGRhdGFcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5yb3V0ZUNvbmZpZyAmJiBjdXJyZW50LnJvdXRlQ29uZmlnLnBhdGggPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGluaGVyaXRpbmdTdGFydGluZ0Zyb20tLTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFyZW50IGlzIGNvbXBvbmVudGxlc3MgPT4gY3VycmVudCByb3V0ZSBzaG91bGQgaW5oZXJpdCBpdHMgcGFyYW1zIGFuZCBkYXRhXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFwYXJlbnRfMS5jb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5oZXJpdGluZ1N0YXJ0aW5nRnJvbS0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbGF0dGVuSW5oZXJpdGVkKHBhdGhGcm9tUm9vdC5zbGljZShpbmhlcml0aW5nU3RhcnRpbmdGcm9tKSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuSW5oZXJpdGVkKHBhdGhGcm9tUm9vdCkge1xuICAgICAgICByZXR1cm4gcGF0aEZyb21Sb290LnJlZHVjZShmdW5jdGlvbiAocmVzLCBjdXJyKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gX19hc3NpZ24kMSh7fSwgcmVzLnBhcmFtcywgY3Vyci5wYXJhbXMpO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBfX2Fzc2lnbiQxKHt9LCByZXMuZGF0YSwgY3Vyci5kYXRhKTtcbiAgICAgICAgICAgIHZhciByZXNvbHZlID0gX19hc3NpZ24kMSh7fSwgcmVzLnJlc29sdmUsIGN1cnIuX3Jlc29sdmVkRGF0YSk7XG4gICAgICAgICAgICByZXR1cm4geyBwYXJhbXM6IHBhcmFtcywgZGF0YTogZGF0YSwgcmVzb2x2ZTogcmVzb2x2ZSB9O1xuICAgICAgICB9LCB7IHBhcmFtczoge30sIGRhdGE6IHt9LCByZXNvbHZlOiB7fSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBDb250YWlucyB0aGUgaW5mb3JtYXRpb24gYWJvdXQgYSByb3V0ZSBhc3NvY2lhdGVkIHdpdGggYSBjb21wb25lbnQgbG9hZGVkIGluIGFuXG4gICAgICogb3V0bGV0IGF0IGEgcGFydGljdWxhciBtb21lbnQgaW4gdGltZS4gQWN0aXZhdGVkUm91dGVTbmFwc2hvdCBjYW4gYWxzbyBiZSB1c2VkIHRvXG4gICAgICogdHJhdmVyc2UgdGhlIHJvdXRlciBzdGF0ZSB0cmVlLlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogQENvbXBvbmVudCh7dGVtcGxhdGVVcmw6Jy4vbXktY29tcG9uZW50Lmh0bWwnfSlcbiAgICAgKiBjbGFzcyBNeUNvbXBvbmVudCB7XG4gICAgICogICBjb25zdHJ1Y3Rvcihyb3V0ZTogQWN0aXZhdGVkUm91dGUpIHtcbiAgICAgKiAgICAgY29uc3QgaWQ6IHN0cmluZyA9IHJvdXRlLnNuYXBzaG90LnBhcmFtcy5pZDtcbiAgICAgKiAgICAgY29uc3QgdXJsOiBzdHJpbmcgPSByb3V0ZS5zbmFwc2hvdC51cmwuam9pbignJyk7XG4gICAgICogICAgIGNvbnN0IHVzZXIgPSByb3V0ZS5zbmFwc2hvdC5kYXRhLnVzZXI7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIGZ1bmN0aW9uIEFjdGl2YXRlZFJvdXRlU25hcHNob3QoXG4gICAgICAgIC8qKiBUaGUgVVJMIHNlZ21lbnRzIG1hdGNoZWQgYnkgdGhpcyByb3V0ZSAqL1xuICAgICAgICB1cmwsIFxuICAgICAgICAvKiogVGhlIG1hdHJpeCBwYXJhbWV0ZXJzIHNjb3BlZCB0byB0aGlzIHJvdXRlICovXG4gICAgICAgIHBhcmFtcywgXG4gICAgICAgIC8qKiBUaGUgcXVlcnkgcGFyYW1ldGVycyBzaGFyZWQgYnkgYWxsIHRoZSByb3V0ZXMgKi9cbiAgICAgICAgcXVlcnlQYXJhbXMsIFxuICAgICAgICAvKiogVGhlIFVSTCBmcmFnbWVudCBzaGFyZWQgYnkgYWxsIHRoZSByb3V0ZXMgKi9cbiAgICAgICAgZnJhZ21lbnQsIFxuICAgICAgICAvKiogVGhlIHN0YXRpYyBhbmQgcmVzb2x2ZWQgZGF0YSBvZiB0aGlzIHJvdXRlICovXG4gICAgICAgIGRhdGEsIFxuICAgICAgICAvKiogVGhlIG91dGxldCBuYW1lIG9mIHRoZSByb3V0ZSAqL1xuICAgICAgICBvdXRsZXQsIFxuICAgICAgICAvKiogVGhlIGNvbXBvbmVudCBvZiB0aGUgcm91dGUgKi9cbiAgICAgICAgY29tcG9uZW50LCByb3V0ZUNvbmZpZywgdXJsU2VnbWVudCwgbGFzdFBhdGhJbmRleCwgcmVzb2x2ZSkge1xuICAgICAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgICAgIHRoaXMucXVlcnlQYXJhbXMgPSBxdWVyeVBhcmFtcztcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnQgPSBmcmFnbWVudDtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICB0aGlzLm91dGxldCA9IG91dGxldDtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICAgICAgdGhpcy5yb3V0ZUNvbmZpZyA9IHJvdXRlQ29uZmlnO1xuICAgICAgICAgICAgdGhpcy5fdXJsU2VnbWVudCA9IHVybFNlZ21lbnQ7XG4gICAgICAgICAgICB0aGlzLl9sYXN0UGF0aEluZGV4ID0gbGFzdFBhdGhJbmRleDtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LnByb3RvdHlwZSwgXCJyb290XCIsIHtcbiAgICAgICAgICAgIC8qKiBUaGUgcm9vdCBvZiB0aGUgcm91dGVyIHN0YXRlICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3JvdXRlclN0YXRlLnJvb3Q7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZhdGVkUm91dGVTbmFwc2hvdC5wcm90b3R5cGUsIFwicGFyZW50XCIsIHtcbiAgICAgICAgICAgIC8qKiBUaGUgcGFyZW50IG9mIHRoaXMgcm91dGUgaW4gdGhlIHJvdXRlciBzdGF0ZSB0cmVlICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3JvdXRlclN0YXRlLnBhcmVudCh0aGlzKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LnByb3RvdHlwZSwgXCJmaXJzdENoaWxkXCIsIHtcbiAgICAgICAgICAgIC8qKiBUaGUgZmlyc3QgY2hpbGQgb2YgdGhpcyByb3V0ZSBpbiB0aGUgcm91dGVyIHN0YXRlIHRyZWUgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcm91dGVyU3RhdGUuZmlyc3RDaGlsZCh0aGlzKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LnByb3RvdHlwZSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICAvKiogVGhlIGNoaWxkcmVuIG9mIHRoaXMgcm91dGUgaW4gdGhlIHJvdXRlciBzdGF0ZSB0cmVlICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3JvdXRlclN0YXRlLmNoaWxkcmVuKHRoaXMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2YXRlZFJvdXRlU25hcHNob3QucHJvdG90eXBlLCBcInBhdGhGcm9tUm9vdFwiLCB7XG4gICAgICAgICAgICAvKiogVGhlIHBhdGggZnJvbSB0aGUgcm9vdCBvZiB0aGUgcm91dGVyIHN0YXRlIHRyZWUgdG8gdGhpcyByb3V0ZSAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yb3V0ZXJTdGF0ZS5wYXRoRnJvbVJvb3QodGhpcyk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZhdGVkUm91dGVTbmFwc2hvdC5wcm90b3R5cGUsIFwicGFyYW1NYXBcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9wYXJhbU1hcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJhbU1hcCA9IGNvbnZlcnRUb1BhcmFtTWFwKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtTWFwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LnByb3RvdHlwZSwgXCJxdWVyeVBhcmFtTWFwXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcXVlcnlQYXJhbU1hcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9xdWVyeVBhcmFtTWFwID0gY29udmVydFRvUGFyYW1NYXAodGhpcy5xdWVyeVBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9xdWVyeVBhcmFtTWFwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIEFjdGl2YXRlZFJvdXRlU25hcHNob3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHVybCA9IHRoaXMudXJsLm1hcChmdW5jdGlvbiAoc2VnbWVudCkgeyByZXR1cm4gc2VnbWVudC50b1N0cmluZygpOyB9KS5qb2luKCcvJyk7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlZCA9IHRoaXMucm91dGVDb25maWcgPyB0aGlzLnJvdXRlQ29uZmlnLnBhdGggOiAnJztcbiAgICAgICAgICAgIHJldHVybiBcIlJvdXRlKHVybDonXCIgKyB1cmwgKyBcIicsIHBhdGg6J1wiICsgbWF0Y2hlZCArIFwiJylcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEFjdGl2YXRlZFJvdXRlU25hcHNob3Q7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFJlcHJlc2VudHMgdGhlIHN0YXRlIG9mIHRoZSByb3V0ZXIgYXQgYSBtb21lbnQgaW4gdGltZS5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYSB0cmVlIG9mIGFjdGl2YXRlZCByb3V0ZSBzbmFwc2hvdHMuIEV2ZXJ5IG5vZGUgaW4gdGhpcyB0cmVlIGtub3dzIGFib3V0XG4gICAgICogdGhlIFwiY29uc3VtZWRcIiBVUkwgc2VnbWVudHMsIHRoZSBleHRyYWN0ZWQgcGFyYW1ldGVycywgYW5kIHRoZSByZXNvbHZlZCBkYXRhLlxuICAgICAqXG4gICAgICogQHVzYWdlTm90ZXNcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogQENvbXBvbmVudCh7dGVtcGxhdGVVcmw6J3RlbXBsYXRlLmh0bWwnfSlcbiAgICAgKiBjbGFzcyBNeUNvbXBvbmVudCB7XG4gICAgICogICBjb25zdHJ1Y3Rvcihyb3V0ZXI6IFJvdXRlcikge1xuICAgICAqICAgICBjb25zdCBzdGF0ZTogUm91dGVyU3RhdGUgPSByb3V0ZXIucm91dGVyU3RhdGU7XG4gICAgICogICAgIGNvbnN0IHNuYXBzaG90OiBSb3V0ZXJTdGF0ZVNuYXBzaG90ID0gc3RhdGUuc25hcHNob3Q7XG4gICAgICogICAgIGNvbnN0IHJvb3Q6IEFjdGl2YXRlZFJvdXRlU25hcHNob3QgPSBzbmFwc2hvdC5yb290O1xuICAgICAqICAgICBjb25zdCBjaGlsZCA9IHJvb3QuZmlyc3RDaGlsZDtcbiAgICAgKiAgICAgY29uc3QgaWQ6IE9ic2VydmFibGU8c3RyaW5nPiA9IGNoaWxkLnBhcmFtcy5tYXAocCA9PiBwLmlkKTtcbiAgICAgKiAgICAgLy8uLi5cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcHVibGljQXBpXG4gICAgICovXG4gICAgdmFyIFJvdXRlclN0YXRlU25hcHNob3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhSb3V0ZXJTdGF0ZVNuYXBzaG90LCBfc3VwZXIpO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIGZ1bmN0aW9uIFJvdXRlclN0YXRlU25hcHNob3QoXG4gICAgICAgIC8qKiBUaGUgdXJsIGZyb20gd2hpY2ggdGhpcyBzbmFwc2hvdCB3YXMgY3JlYXRlZCAqL1xuICAgICAgICB1cmwsIHJvb3QpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJvb3QpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy51cmwgPSB1cmw7XG4gICAgICAgICAgICBzZXRSb3V0ZXJTdGF0ZShfdGhpcywgcm9vdCk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgUm91dGVyU3RhdGVTbmFwc2hvdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXJpYWxpemVOb2RlKHRoaXMuX3Jvb3QpOyB9O1xuICAgICAgICByZXR1cm4gUm91dGVyU3RhdGVTbmFwc2hvdDtcbiAgICB9KFRyZWUpKTtcbiAgICBmdW5jdGlvbiBzZXRSb3V0ZXJTdGF0ZShzdGF0ZSwgbm9kZSkge1xuICAgICAgICBub2RlLnZhbHVlLl9yb3V0ZXJTdGF0ZSA9IHN0YXRlO1xuICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIHNldFJvdXRlclN0YXRlKHN0YXRlLCBjKTsgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZU5vZGUobm9kZSkge1xuICAgICAgICB2YXIgYyA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCA/IFwiIHsgXCIgKyBub2RlLmNoaWxkcmVuLm1hcChzZXJpYWxpemVOb2RlKS5qb2luKCcsICcpICsgXCIgfSBcIiA6ICcnO1xuICAgICAgICByZXR1cm4gXCJcIiArIG5vZGUudmFsdWUgKyBjO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZXhwZWN0YXRpb24gaXMgdGhhdCB0aGUgYWN0aXZhdGUgcm91dGUgaXMgY3JlYXRlZCB3aXRoIHRoZSByaWdodCBzZXQgb2YgcGFyYW1ldGVycy5cbiAgICAgKiBTbyB3ZSBwdXNoIG5ldyB2YWx1ZXMgaW50byB0aGUgb2JzZXJ2YWJsZXMgb25seSB3aGVuIHRoZXkgYXJlIG5vdCB0aGUgaW5pdGlhbCB2YWx1ZXMuXG4gICAgICogQW5kIHdlIGRldGVjdCB0aGF0IGJ5IGNoZWNraW5nIGlmIHRoZSBzbmFwc2hvdCBmaWVsZCBpcyBzZXQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWR2YW5jZUFjdGl2YXRlZFJvdXRlKHJvdXRlKSB7XG4gICAgICAgIGlmIChyb3V0ZS5zbmFwc2hvdCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRTbmFwc2hvdCA9IHJvdXRlLnNuYXBzaG90O1xuICAgICAgICAgICAgdmFyIG5leHRTbmFwc2hvdCA9IHJvdXRlLl9mdXR1cmVTbmFwc2hvdDtcbiAgICAgICAgICAgIHJvdXRlLnNuYXBzaG90ID0gbmV4dFNuYXBzaG90O1xuICAgICAgICAgICAgaWYgKCFzaGFsbG93RXF1YWwoY3VycmVudFNuYXBzaG90LnF1ZXJ5UGFyYW1zLCBuZXh0U25hcHNob3QucXVlcnlQYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgcm91dGUucXVlcnlQYXJhbXMubmV4dChuZXh0U25hcHNob3QucXVlcnlQYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRTbmFwc2hvdC5mcmFnbWVudCAhPT0gbmV4dFNuYXBzaG90LmZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgcm91dGUuZnJhZ21lbnQubmV4dChuZXh0U25hcHNob3QuZnJhZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzaGFsbG93RXF1YWwoY3VycmVudFNuYXBzaG90LnBhcmFtcywgbmV4dFNuYXBzaG90LnBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICByb3V0ZS5wYXJhbXMubmV4dChuZXh0U25hcHNob3QucGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2hhbGxvd0VxdWFsQXJyYXlzKGN1cnJlbnRTbmFwc2hvdC51cmwsIG5leHRTbmFwc2hvdC51cmwpKSB7XG4gICAgICAgICAgICAgICAgcm91dGUudXJsLm5leHQobmV4dFNuYXBzaG90LnVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNoYWxsb3dFcXVhbChjdXJyZW50U25hcHNob3QuZGF0YSwgbmV4dFNuYXBzaG90LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgcm91dGUuZGF0YS5uZXh0KG5leHRTbmFwc2hvdC5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJvdXRlLnNuYXBzaG90ID0gcm91dGUuX2Z1dHVyZVNuYXBzaG90O1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBmb3IgcmVzb2x2ZWQgZGF0YVxuICAgICAgICAgICAgcm91dGUuZGF0YS5uZXh0KHJvdXRlLl9mdXR1cmVTbmFwc2hvdC5kYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBlcXVhbFBhcmFtc0FuZFVybFNlZ21lbnRzKGEsIGIpIHtcbiAgICAgICAgdmFyIGVxdWFsVXJsUGFyYW1zID0gc2hhbGxvd0VxdWFsKGEucGFyYW1zLCBiLnBhcmFtcykgJiYgZXF1YWxTZWdtZW50cyhhLnVybCwgYi51cmwpO1xuICAgICAgICB2YXIgcGFyZW50c01pc21hdGNoID0gIWEucGFyZW50ICE9PSAhYi5wYXJlbnQ7XG4gICAgICAgIHJldHVybiBlcXVhbFVybFBhcmFtcyAmJiAhcGFyZW50c01pc21hdGNoICYmXG4gICAgICAgICAgICAoIWEucGFyZW50IHx8IGVxdWFsUGFyYW1zQW5kVXJsU2VnbWVudHMoYS5wYXJlbnQsIGIucGFyZW50KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJvdXRlclN0YXRlKHJvdXRlUmV1c2VTdHJhdGVneSwgY3VyciwgcHJldlN0YXRlKSB7XG4gICAgICAgIHZhciByb290ID0gY3JlYXRlTm9kZShyb3V0ZVJldXNlU3RyYXRlZ3ksIGN1cnIuX3Jvb3QsIHByZXZTdGF0ZSA/IHByZXZTdGF0ZS5fcm9vdCA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBuZXcgUm91dGVyU3RhdGUocm9vdCwgY3Vycik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU5vZGUocm91dGVSZXVzZVN0cmF0ZWd5LCBjdXJyLCBwcmV2U3RhdGUpIHtcbiAgICAgICAgLy8gcmV1c2UgYW4gYWN0aXZhdGVkIHJvdXRlIHRoYXQgaXMgY3VycmVudGx5IGRpc3BsYXllZCBvbiB0aGUgc2NyZWVuXG4gICAgICAgIGlmIChwcmV2U3RhdGUgJiYgcm91dGVSZXVzZVN0cmF0ZWd5LnNob3VsZFJldXNlUm91dGUoY3Vyci52YWx1ZSwgcHJldlN0YXRlLnZhbHVlLnNuYXBzaG90KSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gcHJldlN0YXRlLnZhbHVlO1xuICAgICAgICAgICAgdmFsdWUuX2Z1dHVyZVNuYXBzaG90ID0gY3Vyci52YWx1ZTtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGNyZWF0ZU9yUmV1c2VDaGlsZHJlbihyb3V0ZVJldXNlU3RyYXRlZ3ksIGN1cnIsIHByZXZTdGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKHZhbHVlLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAvLyByZXRyaWV2ZSBhbiBhY3RpdmF0ZWQgcm91dGUgdGhhdCBpcyB1c2VkIHRvIGJlIGRpc3BsYXllZCwgYnV0IGlzIG5vdCBjdXJyZW50bHkgZGlzcGxheWVkXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGV0YWNoZWRSb3V0ZUhhbmRsZSA9IHJvdXRlUmV1c2VTdHJhdGVneS5yZXRyaWV2ZShjdXJyLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChkZXRhY2hlZFJvdXRlSGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyZWUgPSBkZXRhY2hlZFJvdXRlSGFuZGxlLnJvdXRlO1xuICAgICAgICAgICAgICAgIHNldEZ1dHVyZVNuYXBzaG90c09mQWN0aXZhdGVkUm91dGVzKGN1cnIsIHRyZWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gY3JlYXRlQWN0aXZhdGVkUm91dGUoY3Vyci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gY3Vyci5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGNyZWF0ZU5vZGUocm91dGVSZXVzZVN0cmF0ZWd5LCBjKTsgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmVlTm9kZSh2YWx1ZSwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldEZ1dHVyZVNuYXBzaG90c09mQWN0aXZhdGVkUm91dGVzKGN1cnIsIHJlc3VsdCkge1xuICAgICAgICBpZiAoY3Vyci52YWx1ZS5yb3V0ZUNvbmZpZyAhPT0gcmVzdWx0LnZhbHVlLnJvdXRlQ29uZmlnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWF0dGFjaCBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90IGNyZWF0ZWQgZnJvbSBhIGRpZmZlcmVudCByb3V0ZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyLmNoaWxkcmVuLmxlbmd0aCAhPT0gcmVzdWx0LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVhdHRhY2ggQWN0aXZhdGVkUm91dGVTbmFwc2hvdCB3aXRoIGEgZGlmZmVyZW50IG51bWJlciBvZiBjaGlsZHJlbicpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC52YWx1ZS5fZnV0dXJlU25hcHNob3QgPSBjdXJyLnZhbHVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1cnIuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHNldEZ1dHVyZVNuYXBzaG90c09mQWN0aXZhdGVkUm91dGVzKGN1cnIuY2hpbGRyZW5baV0sIHJlc3VsdC5jaGlsZHJlbltpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlT3JSZXVzZUNoaWxkcmVuKHJvdXRlUmV1c2VTdHJhdGVneSwgY3VyciwgcHJldlN0YXRlKSB7XG4gICAgICAgIHJldHVybiBjdXJyLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKHByZXZTdGF0ZS5jaGlsZHJlbiksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdXRlUmV1c2VTdHJhdGVneS5zaG91bGRSZXVzZVJvdXRlKHAudmFsdWUuc25hcHNob3QsIGNoaWxkLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU5vZGUocm91dGVSZXVzZVN0cmF0ZWd5LCBjaGlsZCwgcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTm9kZShyb3V0ZVJldXNlU3RyYXRlZ3ksIGNoaWxkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFjdGl2YXRlZFJvdXRlKGMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmF0ZWRSb3V0ZShuZXcgcnhqcy5CZWhhdmlvclN1YmplY3QoYy51cmwpLCBuZXcgcnhqcy5CZWhhdmlvclN1YmplY3QoYy5wYXJhbXMpLCBuZXcgcnhqcy5CZWhhdmlvclN1YmplY3QoYy5xdWVyeVBhcmFtcyksIG5ldyByeGpzLkJlaGF2aW9yU3ViamVjdChjLmZyYWdtZW50KSwgbmV3IHJ4anMuQmVoYXZpb3JTdWJqZWN0KGMuZGF0YSksIGMub3V0bGV0LCBjLmNvbXBvbmVudCwgYyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVVybFRyZWUocm91dGUsIHVybFRyZWUsIGNvbW1hbmRzLCBxdWVyeVBhcmFtcywgZnJhZ21lbnQpIHtcbiAgICAgICAgaWYgKGNvbW1hbmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRyZWUodXJsVHJlZS5yb290LCB1cmxUcmVlLnJvb3QsIHVybFRyZWUsIHF1ZXJ5UGFyYW1zLCBmcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hdiA9IGNvbXB1dGVOYXZpZ2F0aW9uKGNvbW1hbmRzKTtcbiAgICAgICAgaWYgKG5hdi50b1Jvb3QoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRyZWUodXJsVHJlZS5yb290LCBuZXcgVXJsU2VnbWVudEdyb3VwKFtdLCB7fSksIHVybFRyZWUsIHF1ZXJ5UGFyYW1zLCBmcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0aW5nUG9zaXRpb24gPSBmaW5kU3RhcnRpbmdQb3NpdGlvbihuYXYsIHVybFRyZWUsIHJvdXRlKTtcbiAgICAgICAgdmFyIHNlZ21lbnRHcm91cCA9IHN0YXJ0aW5nUG9zaXRpb24ucHJvY2Vzc0NoaWxkcmVuID9cbiAgICAgICAgICAgIHVwZGF0ZVNlZ21lbnRHcm91cENoaWxkcmVuKHN0YXJ0aW5nUG9zaXRpb24uc2VnbWVudEdyb3VwLCBzdGFydGluZ1Bvc2l0aW9uLmluZGV4LCBuYXYuY29tbWFuZHMpIDpcbiAgICAgICAgICAgIHVwZGF0ZVNlZ21lbnRHcm91cChzdGFydGluZ1Bvc2l0aW9uLnNlZ21lbnRHcm91cCwgc3RhcnRpbmdQb3NpdGlvbi5pbmRleCwgbmF2LmNvbW1hbmRzKTtcbiAgICAgICAgcmV0dXJuIHRyZWUoc3RhcnRpbmdQb3NpdGlvbi5zZWdtZW50R3JvdXAsIHNlZ21lbnRHcm91cCwgdXJsVHJlZSwgcXVlcnlQYXJhbXMsIGZyYWdtZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNNYXRyaXhQYXJhbXMoY29tbWFuZCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGNvbW1hbmQgPT09ICdvYmplY3QnICYmIGNvbW1hbmQgIT0gbnVsbCAmJiAhY29tbWFuZC5vdXRsZXRzICYmICFjb21tYW5kLnNlZ21lbnRQYXRoO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmVlKG9sZFNlZ21lbnRHcm91cCwgbmV3U2VnbWVudEdyb3VwLCB1cmxUcmVlLCBxdWVyeVBhcmFtcywgZnJhZ21lbnQpIHtcbiAgICAgICAgdmFyIHFwID0ge307XG4gICAgICAgIGlmIChxdWVyeVBhcmFtcykge1xuICAgICAgICAgICAgZm9yRWFjaChxdWVyeVBhcmFtcywgZnVuY3Rpb24gKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgcXBbbmFtZV0gPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gXCJcIiArIHY7IH0pIDogXCJcIiArIHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVybFRyZWUucm9vdCA9PT0gb2xkU2VnbWVudEdyb3VwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVybFRyZWUobmV3U2VnbWVudEdyb3VwLCBxcCwgZnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVXJsVHJlZShyZXBsYWNlU2VnbWVudCh1cmxUcmVlLnJvb3QsIG9sZFNlZ21lbnRHcm91cCwgbmV3U2VnbWVudEdyb3VwKSwgcXAsIGZyYWdtZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVwbGFjZVNlZ21lbnQoY3VycmVudCwgb2xkU2VnbWVudCwgbmV3U2VnbWVudCkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB7fTtcbiAgICAgICAgZm9yRWFjaChjdXJyZW50LmNoaWxkcmVuLCBmdW5jdGlvbiAoYywgb3V0bGV0TmFtZSkge1xuICAgICAgICAgICAgaWYgKGMgPT09IG9sZFNlZ21lbnQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltvdXRsZXROYW1lXSA9IG5ld1NlZ21lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltvdXRsZXROYW1lXSA9IHJlcGxhY2VTZWdtZW50KGMsIG9sZFNlZ21lbnQsIG5ld1NlZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBVcmxTZWdtZW50R3JvdXAoY3VycmVudC5zZWdtZW50cywgY2hpbGRyZW4pO1xuICAgIH1cbiAgICB2YXIgTmF2aWdhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmF2aWdhdGlvbihpc0Fic29sdXRlLCBudW1iZXJPZkRvdWJsZURvdHMsIGNvbW1hbmRzKSB7XG4gICAgICAgICAgICB0aGlzLmlzQWJzb2x1dGUgPSBpc0Fic29sdXRlO1xuICAgICAgICAgICAgdGhpcy5udW1iZXJPZkRvdWJsZURvdHMgPSBudW1iZXJPZkRvdWJsZURvdHM7XG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRzID0gY29tbWFuZHM7XG4gICAgICAgICAgICBpZiAoaXNBYnNvbHV0ZSAmJiBjb21tYW5kcy5sZW5ndGggPiAwICYmIGlzTWF0cml4UGFyYW1zKGNvbW1hbmRzWzBdKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUm9vdCBzZWdtZW50IGNhbm5vdCBoYXZlIG1hdHJpeCBwYXJhbWV0ZXJzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY21kV2l0aE91dGxldCA9IGNvbW1hbmRzLmZpbmQoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIHR5cGVvZiBjID09PSAnb2JqZWN0JyAmJiBjICE9IG51bGwgJiYgYy5vdXRsZXRzOyB9KTtcbiAgICAgICAgICAgIGlmIChjbWRXaXRoT3V0bGV0ICYmIGNtZFdpdGhPdXRsZXQgIT09IGxhc3QoY29tbWFuZHMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd7b3V0bGV0czp7fX0gaGFzIHRvIGJlIHRoZSBsYXN0IGNvbW1hbmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBOYXZpZ2F0aW9uLnByb3RvdHlwZS50b1Jvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0Fic29sdXRlICYmIHRoaXMuY29tbWFuZHMubGVuZ3RoID09PSAxICYmIHRoaXMuY29tbWFuZHNbMF0gPT0gJy8nO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTmF2aWdhdGlvbjtcbiAgICB9KCkpO1xuICAgIC8qKiBUcmFuc2Zvcm1zIGNvbW1hbmRzIHRvIGEgbm9ybWFsaXplZCBgTmF2aWdhdGlvbmAgKi9cbiAgICBmdW5jdGlvbiBjb21wdXRlTmF2aWdhdGlvbihjb21tYW5kcykge1xuICAgICAgICBpZiAoKHR5cGVvZiBjb21tYW5kc1swXSA9PT0gJ3N0cmluZycpICYmIGNvbW1hbmRzLmxlbmd0aCA9PT0gMSAmJiBjb21tYW5kc1swXSA9PT0gJy8nKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5hdmlnYXRpb24odHJ1ZSwgMCwgY29tbWFuZHMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBudW1iZXJPZkRvdWJsZURvdHMgPSAwO1xuICAgICAgICB2YXIgaXNBYnNvbHV0ZSA9IGZhbHNlO1xuICAgICAgICB2YXIgcmVzID0gY29tbWFuZHMucmVkdWNlKGZ1bmN0aW9uIChyZXMsIGNtZCwgY21kSWR4KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNtZCA9PT0gJ29iamVjdCcgJiYgY21kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY21kLm91dGxldHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG91dGxldHNfMSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBmb3JFYWNoKGNtZC5vdXRsZXRzLCBmdW5jdGlvbiAoY29tbWFuZHMsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGxldHNfMVtuYW1lXSA9IHR5cGVvZiBjb21tYW5kcyA9PT0gJ3N0cmluZycgPyBjb21tYW5kcy5zcGxpdCgnLycpIDogY29tbWFuZHM7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19zcHJlYWQocmVzLCBbeyBvdXRsZXRzOiBvdXRsZXRzXzEgfV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY21kLnNlZ21lbnRQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZChyZXMsIFtjbWQuc2VnbWVudFBhdGhdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoISh0eXBlb2YgY21kID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19zcHJlYWQocmVzLCBbY21kXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY21kSWR4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY21kLnNwbGl0KCcvJykuZm9yRWFjaChmdW5jdGlvbiAodXJsUGFydCwgcGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0SW5kZXggPT0gMCAmJiB1cmxQYXJ0ID09PSAnLicpIDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFydEluZGV4ID09IDAgJiYgdXJsUGFydCA9PT0gJycpIHsgLy8gICcvYSdcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQWJzb2x1dGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHVybFBhcnQgPT09ICcuLicpIHsgLy8gICcuLi9hJ1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyT2ZEb3VibGVEb3RzKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodXJsUGFydCAhPSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2godXJsUGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkKHJlcywgW2NtZF0pO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIHJldHVybiBuZXcgTmF2aWdhdGlvbihpc0Fic29sdXRlLCBudW1iZXJPZkRvdWJsZURvdHMsIHJlcyk7XG4gICAgfVxuICAgIHZhciBQb3NpdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUG9zaXRpb24oc2VnbWVudEdyb3VwLCBwcm9jZXNzQ2hpbGRyZW4sIGluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLnNlZ21lbnRHcm91cCA9IHNlZ21lbnRHcm91cDtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0NoaWxkcmVuID0gcHJvY2Vzc0NoaWxkcmVuO1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQb3NpdGlvbjtcbiAgICB9KCkpO1xuICAgIGZ1bmN0aW9uIGZpbmRTdGFydGluZ1Bvc2l0aW9uKG5hdiwgdHJlZSwgcm91dGUpIHtcbiAgICAgICAgaWYgKG5hdi5pc0Fic29sdXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHRyZWUucm9vdCwgdHJ1ZSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvdXRlLnNuYXBzaG90Ll9sYXN0UGF0aEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbihyb3V0ZS5zbmFwc2hvdC5fdXJsU2VnbWVudCwgdHJ1ZSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1vZGlmaWVyID0gaXNNYXRyaXhQYXJhbXMobmF2LmNvbW1hbmRzWzBdKSA/IDAgOiAxO1xuICAgICAgICB2YXIgaW5kZXggPSByb3V0ZS5zbmFwc2hvdC5fbGFzdFBhdGhJbmRleCArIG1vZGlmaWVyO1xuICAgICAgICByZXR1cm4gY3JlYXRlUG9zaXRpb25BcHBseWluZ0RvdWJsZURvdHMocm91dGUuc25hcHNob3QuX3VybFNlZ21lbnQsIGluZGV4LCBuYXYubnVtYmVyT2ZEb3VibGVEb3RzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25BcHBseWluZ0RvdWJsZURvdHMoZ3JvdXAsIGluZGV4LCBudW1iZXJPZkRvdWJsZURvdHMpIHtcbiAgICAgICAgdmFyIGcgPSBncm91cDtcbiAgICAgICAgdmFyIGNpID0gaW5kZXg7XG4gICAgICAgIHZhciBkZCA9IG51bWJlck9mRG91YmxlRG90cztcbiAgICAgICAgd2hpbGUgKGRkID4gY2kpIHtcbiAgICAgICAgICAgIGRkIC09IGNpO1xuICAgICAgICAgICAgZyA9IGcucGFyZW50O1xuICAgICAgICAgICAgaWYgKCFnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG51bWJlciBvZiBcXCcuLi9cXCcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNpID0gZy5zZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbihnLCBmYWxzZSwgY2kgLSBkZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFBhdGgoY29tbWFuZCkge1xuICAgICAgICBpZiAodHlwZW9mIGNvbW1hbmQgPT09ICdvYmplY3QnICYmIGNvbW1hbmQgIT0gbnVsbCAmJiBjb21tYW5kLm91dGxldHMpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21tYW5kLm91dGxldHNbUFJJTUFSWV9PVVRMRVRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiICsgY29tbWFuZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0T3V0bGV0cyhjb21tYW5kcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoISh0eXBlb2YgY29tbWFuZHNbMF0gPT09ICdvYmplY3QnKSlcbiAgICAgICAgICAgIHJldHVybiBfYSA9IHt9LCBfYVtQUklNQVJZX09VVExFVF0gPSBjb21tYW5kcywgX2E7XG4gICAgICAgIGlmIChjb21tYW5kc1swXS5vdXRsZXRzID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gX2IgPSB7fSwgX2JbUFJJTUFSWV9PVVRMRVRdID0gY29tbWFuZHMsIF9iO1xuICAgICAgICByZXR1cm4gY29tbWFuZHNbMF0ub3V0bGV0cztcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlU2VnbWVudEdyb3VwKHNlZ21lbnRHcm91cCwgc3RhcnRJbmRleCwgY29tbWFuZHMpIHtcbiAgICAgICAgaWYgKCFzZWdtZW50R3JvdXApIHtcbiAgICAgICAgICAgIHNlZ21lbnRHcm91cCA9IG5ldyBVcmxTZWdtZW50R3JvdXAoW10sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VnbWVudEdyb3VwLnNlZ21lbnRzLmxlbmd0aCA9PT0gMCAmJiBzZWdtZW50R3JvdXAuaGFzQ2hpbGRyZW4oKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVNlZ21lbnRHcm91cENoaWxkcmVuKHNlZ21lbnRHcm91cCwgc3RhcnRJbmRleCwgY29tbWFuZHMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtID0gcHJlZml4ZWRXaXRoKHNlZ21lbnRHcm91cCwgc3RhcnRJbmRleCwgY29tbWFuZHMpO1xuICAgICAgICB2YXIgc2xpY2VkQ29tbWFuZHMgPSBjb21tYW5kcy5zbGljZShtLmNvbW1hbmRJbmRleCk7XG4gICAgICAgIGlmIChtLm1hdGNoICYmIG0ucGF0aEluZGV4IDwgc2VnbWVudEdyb3VwLnNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGcgPSBuZXcgVXJsU2VnbWVudEdyb3VwKHNlZ21lbnRHcm91cC5zZWdtZW50cy5zbGljZSgwLCBtLnBhdGhJbmRleCksIHt9KTtcbiAgICAgICAgICAgIGcuY2hpbGRyZW5bUFJJTUFSWV9PVVRMRVRdID1cbiAgICAgICAgICAgICAgICBuZXcgVXJsU2VnbWVudEdyb3VwKHNlZ21lbnRHcm91cC5zZWdtZW50cy5zbGljZShtLnBhdGhJbmRleCksIHNlZ21lbnRHcm91cC5jaGlsZHJlbik7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlU2VnbWVudEdyb3VwQ2hpbGRyZW4oZywgMCwgc2xpY2VkQ29tbWFuZHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG0ubWF0Y2ggJiYgc2xpY2VkQ29tbWFuZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVybFNlZ21lbnRHcm91cChzZWdtZW50R3JvdXAuc2VnbWVudHMsIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtLm1hdGNoICYmICFzZWdtZW50R3JvdXAuaGFzQ2hpbGRyZW4oKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU5ld1NlZ21lbnRHcm91cChzZWdtZW50R3JvdXAsIHN0YXJ0SW5kZXgsIGNvbW1hbmRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtLm1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlU2VnbWVudEdyb3VwQ2hpbGRyZW4oc2VnbWVudEdyb3VwLCAwLCBzbGljZWRDb21tYW5kcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTmV3U2VnbWVudEdyb3VwKHNlZ21lbnRHcm91cCwgc3RhcnRJbmRleCwgY29tbWFuZHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVNlZ21lbnRHcm91cENoaWxkcmVuKHNlZ21lbnRHcm91cCwgc3RhcnRJbmRleCwgY29tbWFuZHMpIHtcbiAgICAgICAgaWYgKGNvbW1hbmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVcmxTZWdtZW50R3JvdXAoc2VnbWVudEdyb3VwLnNlZ21lbnRzLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgb3V0bGV0c18yID0gZ2V0T3V0bGV0cyhjb21tYW5kcyk7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW5fMSA9IHt9O1xuICAgICAgICAgICAgZm9yRWFjaChvdXRsZXRzXzIsIGZ1bmN0aW9uIChjb21tYW5kcywgb3V0bGV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbW1hbmRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuXzFbb3V0bGV0XSA9IHVwZGF0ZVNlZ21lbnRHcm91cChzZWdtZW50R3JvdXAuY2hpbGRyZW5bb3V0bGV0XSwgc3RhcnRJbmRleCwgY29tbWFuZHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yRWFjaChzZWdtZW50R3JvdXAuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCwgY2hpbGRPdXRsZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAob3V0bGV0c18yW2NoaWxkT3V0bGV0XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuXzFbY2hpbGRPdXRsZXRdID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVybFNlZ21lbnRHcm91cChzZWdtZW50R3JvdXAuc2VnbWVudHMsIGNoaWxkcmVuXzEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZWZpeGVkV2l0aChzZWdtZW50R3JvdXAsIHN0YXJ0SW5kZXgsIGNvbW1hbmRzKSB7XG4gICAgICAgIHZhciBjdXJyZW50Q29tbWFuZEluZGV4ID0gMDtcbiAgICAgICAgdmFyIGN1cnJlbnRQYXRoSW5kZXggPSBzdGFydEluZGV4O1xuICAgICAgICB2YXIgbm9NYXRjaCA9IHsgbWF0Y2g6IGZhbHNlLCBwYXRoSW5kZXg6IDAsIGNvbW1hbmRJbmRleDogMCB9O1xuICAgICAgICB3aGlsZSAoY3VycmVudFBhdGhJbmRleCA8IHNlZ21lbnRHcm91cC5zZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q29tbWFuZEluZGV4ID49IGNvbW1hbmRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9NYXRjaDtcbiAgICAgICAgICAgIHZhciBwYXRoID0gc2VnbWVudEdyb3VwLnNlZ21lbnRzW2N1cnJlbnRQYXRoSW5kZXhdO1xuICAgICAgICAgICAgdmFyIGN1cnIgPSBnZXRQYXRoKGNvbW1hbmRzW2N1cnJlbnRDb21tYW5kSW5kZXhdKTtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gY3VycmVudENvbW1hbmRJbmRleCA8IGNvbW1hbmRzLmxlbmd0aCAtIDEgPyBjb21tYW5kc1tjdXJyZW50Q29tbWFuZEluZGV4ICsgMV0gOiBudWxsO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRQYXRoSW5kZXggPiAwICYmIGN1cnIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChjdXJyICYmIG5leHQgJiYgKHR5cGVvZiBuZXh0ID09PSAnb2JqZWN0JykgJiYgbmV4dC5vdXRsZXRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBhcmUoY3VyciwgbmV4dCwgcGF0aCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub01hdGNoO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb21tYW5kSW5kZXggKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghY29tcGFyZShjdXJyLCB7fSwgcGF0aCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub01hdGNoO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb21tYW5kSW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRQYXRoSW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtYXRjaDogdHJ1ZSwgcGF0aEluZGV4OiBjdXJyZW50UGF0aEluZGV4LCBjb21tYW5kSW5kZXg6IGN1cnJlbnRDb21tYW5kSW5kZXggfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlTmV3U2VnbWVudEdyb3VwKHNlZ21lbnRHcm91cCwgc3RhcnRJbmRleCwgY29tbWFuZHMpIHtcbiAgICAgICAgdmFyIHBhdGhzID0gc2VnbWVudEdyb3VwLnNlZ21lbnRzLnNsaWNlKDAsIHN0YXJ0SW5kZXgpO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgY29tbWFuZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbW1hbmRzW2ldID09PSAnb2JqZWN0JyAmJiBjb21tYW5kc1tpXS5vdXRsZXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBjcmVhdGVOZXdTZWdtZW50Q2hpbGRyZW4oY29tbWFuZHNbaV0ub3V0bGV0cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVcmxTZWdtZW50R3JvdXAocGF0aHMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHdlIHN0YXJ0IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwsIHdlIG5lZWQgdG8gcmV1c2UgdGhlIHBhdGggcGFydCBmcm9tIHRoZSBzZWdtZW50XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCAmJiBpc01hdHJpeFBhcmFtcyhjb21tYW5kc1swXSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHNlZ21lbnRHcm91cC5zZWdtZW50c1tzdGFydEluZGV4XTtcbiAgICAgICAgICAgICAgICBwYXRocy5wdXNoKG5ldyBVcmxTZWdtZW50KHAucGF0aCwgY29tbWFuZHNbMF0pKTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY3VyciA9IGdldFBhdGgoY29tbWFuZHNbaV0pO1xuICAgICAgICAgICAgdmFyIG5leHQgPSAoaSA8IGNvbW1hbmRzLmxlbmd0aCAtIDEpID8gY29tbWFuZHNbaSArIDFdIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChjdXJyICYmIG5leHQgJiYgaXNNYXRyaXhQYXJhbXMobmV4dCkpIHtcbiAgICAgICAgICAgICAgICBwYXRocy5wdXNoKG5ldyBVcmxTZWdtZW50KGN1cnIsIHN0cmluZ2lmeShuZXh0KSkpO1xuICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdGhzLnB1c2gobmV3IFVybFNlZ21lbnQoY3Vyciwge30pKTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBVcmxTZWdtZW50R3JvdXAocGF0aHMsIHt9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlTmV3U2VnbWVudENoaWxkcmVuKG91dGxldHMpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0ge307XG4gICAgICAgIGZvckVhY2gob3V0bGV0cywgZnVuY3Rpb24gKGNvbW1hbmRzLCBvdXRsZXQpIHtcbiAgICAgICAgICAgIGlmIChjb21tYW5kcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuW291dGxldF0gPSBjcmVhdGVOZXdTZWdtZW50R3JvdXAobmV3IFVybFNlZ21lbnRHcm91cChbXSwge30pLCAwLCBjb21tYW5kcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0cmluZ2lmeShwYXJhbXMpIHtcbiAgICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgICBmb3JFYWNoKHBhcmFtcywgZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIHJlc1trXSA9IFwiXCIgKyB2OyB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGFyZShwYXRoLCBwYXJhbXMsIHNlZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIHBhdGggPT0gc2VnbWVudC5wYXRoICYmIHNoYWxsb3dFcXVhbChwYXJhbXMsIHNlZ21lbnQucGFyYW1ldGVycyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBhY3RpdmF0ZVJvdXRlcyA9IGZ1bmN0aW9uIChyb290Q29udGV4dHMsIHJvdXRlUmV1c2VTdHJhdGVneSwgZm9yd2FyZEV2ZW50KSB7XG4gICAgICAgIHJldHVybiBvcGVyYXRvcnMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICBuZXcgQWN0aXZhdGVSb3V0ZXMocm91dGVSZXVzZVN0cmF0ZWd5LCB0LnRhcmdldFJvdXRlclN0YXRlLCB0LmN1cnJlbnRSb3V0ZXJTdGF0ZSwgZm9yd2FyZEV2ZW50KVxuICAgICAgICAgICAgICAgIC5hY3RpdmF0ZShyb290Q29udGV4dHMpO1xuICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdmFyIEFjdGl2YXRlUm91dGVzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBY3RpdmF0ZVJvdXRlcyhyb3V0ZVJldXNlU3RyYXRlZ3ksIGZ1dHVyZVN0YXRlLCBjdXJyU3RhdGUsIGZvcndhcmRFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5yb3V0ZVJldXNlU3RyYXRlZ3kgPSByb3V0ZVJldXNlU3RyYXRlZ3k7XG4gICAgICAgICAgICB0aGlzLmZ1dHVyZVN0YXRlID0gZnV0dXJlU3RhdGU7XG4gICAgICAgICAgICB0aGlzLmN1cnJTdGF0ZSA9IGN1cnJTdGF0ZTtcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZEV2ZW50ID0gZm9yd2FyZEV2ZW50O1xuICAgICAgICB9XG4gICAgICAgIEFjdGl2YXRlUm91dGVzLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uIChwYXJlbnRDb250ZXh0cykge1xuICAgICAgICAgICAgdmFyIGZ1dHVyZVJvb3QgPSB0aGlzLmZ1dHVyZVN0YXRlLl9yb290O1xuICAgICAgICAgICAgdmFyIGN1cnJSb290ID0gdGhpcy5jdXJyU3RhdGUgPyB0aGlzLmN1cnJTdGF0ZS5fcm9vdCA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGVDaGlsZFJvdXRlcyhmdXR1cmVSb290LCBjdXJyUm9vdCwgcGFyZW50Q29udGV4dHMpO1xuICAgICAgICAgICAgYWR2YW5jZUFjdGl2YXRlZFJvdXRlKHRoaXMuZnV0dXJlU3RhdGUucm9vdCk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlQ2hpbGRSb3V0ZXMoZnV0dXJlUm9vdCwgY3VyclJvb3QsIHBhcmVudENvbnRleHRzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gRGUtYWN0aXZhdGUgdGhlIGNoaWxkIHJvdXRlIHRoYXQgYXJlIG5vdCByZS11c2VkIGZvciB0aGUgZnV0dXJlIHN0YXRlXG4gICAgICAgIEFjdGl2YXRlUm91dGVzLnByb3RvdHlwZS5kZWFjdGl2YXRlQ2hpbGRSb3V0ZXMgPSBmdW5jdGlvbiAoZnV0dXJlTm9kZSwgY3Vyck5vZGUsIGNvbnRleHRzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZUNoaWxkcmVuQXNNYXAoY3Vyck5vZGUpO1xuICAgICAgICAgICAgLy8gUmVjdXJzZSBvbiB0aGUgcm91dGVzIGFjdGl2ZSBpbiB0aGUgZnV0dXJlIHN0YXRlIHRvIGRlLWFjdGl2YXRlIGRlZXBlciBjaGlsZHJlblxuICAgICAgICAgICAgZnV0dXJlTm9kZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChmdXR1cmVDaGlsZCkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZE91dGxldE5hbWUgPSBmdXR1cmVDaGlsZC52YWx1ZS5vdXRsZXQ7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGVhY3RpdmF0ZVJvdXRlcyhmdXR1cmVDaGlsZCwgY2hpbGRyZW5bY2hpbGRPdXRsZXROYW1lXSwgY29udGV4dHMpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjaGlsZHJlbltjaGlsZE91dGxldE5hbWVdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBEZS1hY3RpdmF0ZSB0aGUgcm91dGVzIHRoYXQgd2lsbCBub3QgYmUgcmUtdXNlZFxuICAgICAgICAgICAgZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKHYsIGNoaWxkTmFtZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmRlYWN0aXZhdGVSb3V0ZUFuZEl0c0NoaWxkcmVuKHYsIGNvbnRleHRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBBY3RpdmF0ZVJvdXRlcy5wcm90b3R5cGUuZGVhY3RpdmF0ZVJvdXRlcyA9IGZ1bmN0aW9uIChmdXR1cmVOb2RlLCBjdXJyTm9kZSwgcGFyZW50Q29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGZ1dHVyZSA9IGZ1dHVyZU5vZGUudmFsdWU7XG4gICAgICAgICAgICB2YXIgY3VyciA9IGN1cnJOb2RlID8gY3Vyck5vZGUudmFsdWUgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGZ1dHVyZSA9PT0gY3Vycikge1xuICAgICAgICAgICAgICAgIC8vIFJldXNpbmcgdGhlIG5vZGUsIGNoZWNrIHRvIHNlZSBpZiB0aGUgY2hpbGRyZW4gbmVlZCB0byBiZSBkZS1hY3RpdmF0ZWRcbiAgICAgICAgICAgICAgICBpZiAoZnV0dXJlLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgbm9ybWFsIHJvdXRlLCB3ZSBuZWVkIHRvIGdvIHRocm91Z2ggYW4gb3V0bGV0LlxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IHBhcmVudENvbnRleHQuZ2V0Q29udGV4dChmdXR1cmUub3V0bGV0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZUNoaWxkUm91dGVzKGZ1dHVyZU5vZGUsIGN1cnJOb2RlLCBjb250ZXh0LmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIGNvbXBvbmVudGxlc3Mgcm91dGUsIHdlIHJlY3Vyc2UgYnV0IGtlZXAgdGhlIHNhbWUgb3V0bGV0IG1hcC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlQ2hpbGRSb3V0ZXMoZnV0dXJlTm9kZSwgY3Vyck5vZGUsIHBhcmVudENvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERlYWN0aXZhdGUgdGhlIGN1cnJlbnQgcm91dGUgd2hpY2ggd2lsbCBub3QgYmUgcmUtdXNlZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGVSb3V0ZUFuZEl0c0NoaWxkcmVuKGN1cnJOb2RlLCBwYXJlbnRDb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEFjdGl2YXRlUm91dGVzLnByb3RvdHlwZS5kZWFjdGl2YXRlUm91dGVBbmRJdHNDaGlsZHJlbiA9IGZ1bmN0aW9uIChyb3V0ZSwgcGFyZW50Q29udGV4dHMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJvdXRlUmV1c2VTdHJhdGVneS5zaG91bGREZXRhY2gocm91dGUudmFsdWUuc25hcHNob3QpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXRhY2hBbmRTdG9yZVJvdXRlU3VidHJlZShyb3V0ZSwgcGFyZW50Q29udGV4dHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlUm91dGVBbmRPdXRsZXQocm91dGUsIHBhcmVudENvbnRleHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQWN0aXZhdGVSb3V0ZXMucHJvdG90eXBlLmRldGFjaEFuZFN0b3JlUm91dGVTdWJ0cmVlID0gZnVuY3Rpb24gKHJvdXRlLCBwYXJlbnRDb250ZXh0cykge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBwYXJlbnRDb250ZXh0cy5nZXRDb250ZXh0KHJvdXRlLnZhbHVlLm91dGxldCk7XG4gICAgICAgICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Lm91dGxldCkge1xuICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRSZWYgPSBjb250ZXh0Lm91dGxldC5kZXRhY2goKTtcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dHMgPSBjb250ZXh0LmNoaWxkcmVuLm9uT3V0bGV0RGVhY3RpdmF0ZWQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJvdXRlUmV1c2VTdHJhdGVneS5zdG9yZShyb3V0ZS52YWx1ZS5zbmFwc2hvdCwgeyBjb21wb25lbnRSZWY6IGNvbXBvbmVudFJlZiwgcm91dGU6IHJvdXRlLCBjb250ZXh0czogY29udGV4dHMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEFjdGl2YXRlUm91dGVzLnByb3RvdHlwZS5kZWFjdGl2YXRlUm91dGVBbmRPdXRsZXQgPSBmdW5jdGlvbiAocm91dGUsIHBhcmVudENvbnRleHRzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBwYXJlbnRDb250ZXh0cy5nZXRDb250ZXh0KHJvdXRlLnZhbHVlLm91dGxldCk7XG4gICAgICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGVDaGlsZHJlbkFzTWFwKHJvdXRlKTtcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dHNfMSA9IHJvdXRlLnZhbHVlLmNvbXBvbmVudCA/IGNvbnRleHQuY2hpbGRyZW4gOiBwYXJlbnRDb250ZXh0cztcbiAgICAgICAgICAgICAgICBmb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gX3RoaXMuZGVhY3RpdmF0ZVJvdXRlQW5kSXRzQ2hpbGRyZW4odiwgY29udGV4dHNfMSk7IH0pO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0Lm91dGxldCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBEZXN0cm95IHRoZSBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vdXRsZXQuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBEZXN0cm95IHRoZSBjb250ZXh0cyBmb3IgYWxsIHRoZSBvdXRsZXRzIHRoYXQgd2VyZSBpbiB0aGUgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2hpbGRyZW4ub25PdXRsZXREZWFjdGl2YXRlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQWN0aXZhdGVSb3V0ZXMucHJvdG90eXBlLmFjdGl2YXRlQ2hpbGRSb3V0ZXMgPSBmdW5jdGlvbiAoZnV0dXJlTm9kZSwgY3Vyck5vZGUsIGNvbnRleHRzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZUNoaWxkcmVuQXNNYXAoY3Vyck5vZGUpO1xuICAgICAgICAgICAgZnV0dXJlTm9kZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWN0aXZhdGVSb3V0ZXMoYywgY2hpbGRyZW5bYy52YWx1ZS5vdXRsZXRdLCBjb250ZXh0cyk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZm9yd2FyZEV2ZW50KG5ldyBBY3RpdmF0aW9uRW5kKGMudmFsdWUuc25hcHNob3QpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGZ1dHVyZU5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3J3YXJkRXZlbnQobmV3IENoaWxkQWN0aXZhdGlvbkVuZChmdXR1cmVOb2RlLnZhbHVlLnNuYXBzaG90KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEFjdGl2YXRlUm91dGVzLnByb3RvdHlwZS5hY3RpdmF0ZVJvdXRlcyA9IGZ1bmN0aW9uIChmdXR1cmVOb2RlLCBjdXJyTm9kZSwgcGFyZW50Q29udGV4dHMpIHtcbiAgICAgICAgICAgIHZhciBmdXR1cmUgPSBmdXR1cmVOb2RlLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGN1cnIgPSBjdXJyTm9kZSA/IGN1cnJOb2RlLnZhbHVlIDogbnVsbDtcbiAgICAgICAgICAgIGFkdmFuY2VBY3RpdmF0ZWRSb3V0ZShmdXR1cmUpO1xuICAgICAgICAgICAgLy8gcmV1c2luZyB0aGUgbm9kZVxuICAgICAgICAgICAgaWYgKGZ1dHVyZSA9PT0gY3Vycikge1xuICAgICAgICAgICAgICAgIGlmIChmdXR1cmUuY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBub3JtYWwgcm91dGUsIHdlIG5lZWQgdG8gZ28gdGhyb3VnaCBhbiBvdXRsZXQuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gcGFyZW50Q29udGV4dHMuZ2V0T3JDcmVhdGVDb250ZXh0KGZ1dHVyZS5vdXRsZXQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2YXRlQ2hpbGRSb3V0ZXMoZnV0dXJlTm9kZSwgY3Vyck5vZGUsIGNvbnRleHQuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIGNvbXBvbmVudGxlc3Mgcm91dGUsIHdlIHJlY3Vyc2UgYnV0IGtlZXAgdGhlIHNhbWUgb3V0bGV0IG1hcC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZUNoaWxkUm91dGVzKGZ1dHVyZU5vZGUsIGN1cnJOb2RlLCBwYXJlbnRDb250ZXh0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZ1dHVyZS5jb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIG5vcm1hbCByb3V0ZSwgd2UgbmVlZCB0byBwbGFjZSB0aGUgY29tcG9uZW50IGludG8gdGhlIG91dGxldCBhbmQgcmVjdXJzZS5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBwYXJlbnRDb250ZXh0cy5nZXRPckNyZWF0ZUNvbnRleHQoZnV0dXJlLm91dGxldCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJvdXRlUmV1c2VTdHJhdGVneS5zaG91bGRBdHRhY2goZnV0dXJlLnNuYXBzaG90KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlZCA9IHRoaXMucm91dGVSZXVzZVN0cmF0ZWd5LnJldHJpZXZlKGZ1dHVyZS5zbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJvdXRlUmV1c2VTdHJhdGVneS5zdG9yZShmdXR1cmUuc25hcHNob3QsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5jaGlsZHJlbi5vbk91dGxldFJlQXR0YWNoZWQoc3RvcmVkLmNvbnRleHRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYXR0YWNoUmVmID0gc3RvcmVkLmNvbXBvbmVudFJlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucm91dGUgPSBzdG9yZWQucm91dGUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5vdXRsZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBdHRhY2ggcmlnaHQgYXdheSB3aGVuIHRoZSBvdXRsZXQgaGFzIGFscmVhZHkgYmVlbiBpbnN0YW50aWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgYXR0YWNoIGZyb20gYFJvdXRlck91dGxldC5uZ09uSW5pdGAgd2hlbiBpdCBpcyBpbnN0YW50aWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm91dGxldC5hdHRhY2goc3RvcmVkLmNvbXBvbmVudFJlZiwgc3RvcmVkLnJvdXRlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2VBY3RpdmF0ZWRSb3V0ZU5vZGVBbmRJdHNDaGlsZHJlbihzdG9yZWQucm91dGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHBhcmVudExvYWRlZENvbmZpZyhmdXR1cmUuc25hcHNob3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNtcEZhY3RvcnlSZXNvbHZlciA9IGNvbmZpZyA/IGNvbmZpZy5tb2R1bGUuY29tcG9uZW50RmFjdG9yeVJlc29sdmVyIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYXR0YWNoUmVmID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucm91dGUgPSBmdXR1cmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlc29sdmVyID0gY21wRmFjdG9yeVJlc29sdmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQub3V0bGV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWN0aXZhdGUgdGhlIG91dGxldCB3aGVuIGl0IGhhcyBhbHJlYWR5IGJlZW4gaW5zdGFudGlhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGl0IHdpbGwgZ2V0IGFjdGl2YXRlZCBmcm9tIGl0cyBgbmdPbkluaXRgIHdoZW4gaW5zdGFudGlhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vdXRsZXQuYWN0aXZhdGVXaXRoKGZ1dHVyZSwgY21wRmFjdG9yeVJlc29sdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVDaGlsZFJvdXRlcyhmdXR1cmVOb2RlLCBudWxsLCBjb250ZXh0LmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIGNvbXBvbmVudGxlc3Mgcm91dGUsIHdlIHJlY3Vyc2UgYnV0IGtlZXAgdGhlIHNhbWUgb3V0bGV0IG1hcC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZUNoaWxkUm91dGVzKGZ1dHVyZU5vZGUsIG51bGwsIHBhcmVudENvbnRleHRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBBY3RpdmF0ZVJvdXRlcztcbiAgICB9KCkpO1xuICAgIGZ1bmN0aW9uIGFkdmFuY2VBY3RpdmF0ZWRSb3V0ZU5vZGVBbmRJdHNDaGlsZHJlbihub2RlKSB7XG4gICAgICAgIGFkdmFuY2VBY3RpdmF0ZWRSb3V0ZShub2RlLnZhbHVlKTtcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKGFkdmFuY2VBY3RpdmF0ZWRSb3V0ZU5vZGVBbmRJdHNDaGlsZHJlbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcmVudExvYWRlZENvbmZpZyhzbmFwc2hvdCkge1xuICAgICAgICBmb3IgKHZhciBzID0gc25hcHNob3QucGFyZW50OyBzOyBzID0gcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciByb3V0ZSA9IHMucm91dGVDb25maWc7XG4gICAgICAgICAgICBpZiAocm91dGUgJiYgcm91dGUuX2xvYWRlZENvbmZpZylcbiAgICAgICAgICAgICAgICByZXR1cm4gcm91dGUuX2xvYWRlZENvbmZpZztcbiAgICAgICAgICAgIGlmIChyb3V0ZSAmJiByb3V0ZS5jb21wb25lbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFNpbXBsZSBmdW5jdGlvbiBjaGVjaywgYnV0IGdlbmVyaWMgc28gdHlwZSBpbmZlcmVuY2Ugd2lsbCBmbG93LiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogZnVuY3Rpb24gcHJvZHVjdChhOiBudW1iZXIsIGI6IG51bWJlcikge1xuICAgICAqICAgcmV0dXJuIGEgKiBiO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGlmIChpc0Z1bmN0aW9uPHByb2R1Y3Q+KGZuKSkge1xuICAgICAqICAgcmV0dXJuIGZuKDEsIDIpO1xuICAgICAqIH0gZWxzZSB7XG4gICAgICogICB0aHJvdyBcIk11c3QgcHJvdmlkZSB0aGUgYHByb2R1Y3RgIGZ1bmN0aW9uXCI7XG4gICAgICogfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHYgPT09ICdmdW5jdGlvbic7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzQm9vbGVhbih2KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdiA9PT0gJ2Jvb2xlYW4nO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1VybFRyZWUodikge1xuICAgICAgICByZXR1cm4gdiBpbnN0YW5jZW9mIFVybFRyZWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzQ2FuTG9hZChndWFyZCkge1xuICAgICAgICByZXR1cm4gZ3VhcmQgJiYgaXNGdW5jdGlvbihndWFyZC5jYW5Mb2FkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNDYW5BY3RpdmF0ZShndWFyZCkge1xuICAgICAgICByZXR1cm4gZ3VhcmQgJiYgaXNGdW5jdGlvbihndWFyZC5jYW5BY3RpdmF0ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzQ2FuQWN0aXZhdGVDaGlsZChndWFyZCkge1xuICAgICAgICByZXR1cm4gZ3VhcmQgJiYgaXNGdW5jdGlvbihndWFyZC5jYW5BY3RpdmF0ZUNoaWxkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNDYW5EZWFjdGl2YXRlKGd1YXJkKSB7XG4gICAgICAgIHJldHVybiBndWFyZCAmJiBpc0Z1bmN0aW9uKGd1YXJkLmNhbkRlYWN0aXZhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgTm9NYXRjaCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTm9NYXRjaChzZWdtZW50R3JvdXApIHtcbiAgICAgICAgICAgIHRoaXMuc2VnbWVudEdyb3VwID0gc2VnbWVudEdyb3VwIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5vTWF0Y2g7XG4gICAgfSgpKTtcbiAgICB2YXIgQWJzb2x1dGVSZWRpcmVjdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQWJzb2x1dGVSZWRpcmVjdCh1cmxUcmVlKSB7XG4gICAgICAgICAgICB0aGlzLnVybFRyZWUgPSB1cmxUcmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBYnNvbHV0ZVJlZGlyZWN0O1xuICAgIH0oKSk7XG4gICAgZnVuY3Rpb24gbm9NYXRjaChzZWdtZW50R3JvdXApIHtcbiAgICAgICAgcmV0dXJuIG5ldyByeGpzLk9ic2VydmFibGUoZnVuY3Rpb24gKG9icykgeyByZXR1cm4gb2JzLmVycm9yKG5ldyBOb01hdGNoKHNlZ21lbnRHcm91cCkpOyB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWJzb2x1dGVSZWRpcmVjdChuZXdUcmVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgcnhqcy5PYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnMpIHsgcmV0dXJuIG9icy5lcnJvcihuZXcgQWJzb2x1dGVSZWRpcmVjdChuZXdUcmVlKSk7IH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBuYW1lZE91dGxldHNSZWRpcmVjdChyZWRpcmVjdFRvKSB7XG4gICAgICAgIHJldHVybiBuZXcgcnhqcy5PYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnMpIHsgcmV0dXJuIG9icy5lcnJvcihuZXcgRXJyb3IoXCJPbmx5IGFic29sdXRlIHJlZGlyZWN0cyBjYW4gaGF2ZSBuYW1lZCBvdXRsZXRzLiByZWRpcmVjdFRvOiAnXCIgKyByZWRpcmVjdFRvICsgXCInXCIpKTsgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbkxvYWRGYWlscyhyb3V0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IHJ4anMuT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzKSB7IHJldHVybiBvYnMuZXJyb3IobmF2aWdhdGlvbkNhbmNlbGluZ0Vycm9yKFwiQ2Fubm90IGxvYWQgY2hpbGRyZW4gYmVjYXVzZSB0aGUgZ3VhcmQgb2YgdGhlIHJvdXRlIFxcXCJwYXRoOiAnXCIgKyByb3V0ZS5wYXRoICsgXCInXFxcIiByZXR1cm5lZCBmYWxzZVwiKSk7IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBgVXJsVHJlZWAgd2l0aCB0aGUgcmVkaXJlY3Rpb24gYXBwbGllZC5cbiAgICAgKlxuICAgICAqIExhenkgbW9kdWxlcyBhcmUgbG9hZGVkIGFsb25nIHRoZSB3YXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXBwbHlSZWRpcmVjdHMobW9kdWxlSW5qZWN0b3IsIGNvbmZpZ0xvYWRlciwgdXJsU2VyaWFsaXplciwgdXJsVHJlZSwgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXBwbHlSZWRpcmVjdHMobW9kdWxlSW5qZWN0b3IsIGNvbmZpZ0xvYWRlciwgdXJsU2VyaWFsaXplciwgdXJsVHJlZSwgY29uZmlnKS5hcHBseSgpO1xuICAgIH1cbiAgICB2YXIgQXBwbHlSZWRpcmVjdHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFwcGx5UmVkaXJlY3RzKG1vZHVsZUluamVjdG9yLCBjb25maWdMb2FkZXIsIHVybFNlcmlhbGl6ZXIsIHVybFRyZWUsIGNvbmZpZykge1xuICAgICAgICAgICAgdGhpcy5jb25maWdMb2FkZXIgPSBjb25maWdMb2FkZXI7XG4gICAgICAgICAgICB0aGlzLnVybFNlcmlhbGl6ZXIgPSB1cmxTZXJpYWxpemVyO1xuICAgICAgICAgICAgdGhpcy51cmxUcmVlID0gdXJsVHJlZTtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICAgICAgdGhpcy5hbGxvd1JlZGlyZWN0cyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm5nTW9kdWxlID0gbW9kdWxlSW5qZWN0b3IuZ2V0KGNvcmUuTmdNb2R1bGVSZWYpO1xuICAgICAgICB9XG4gICAgICAgIEFwcGx5UmVkaXJlY3RzLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZXhwYW5kZWQkID0gdGhpcy5leHBhbmRTZWdtZW50R3JvdXAodGhpcy5uZ01vZHVsZSwgdGhpcy5jb25maWcsIHRoaXMudXJsVHJlZS5yb290LCBQUklNQVJZX09VVExFVCk7XG4gICAgICAgICAgICB2YXIgdXJsVHJlZXMkID0gZXhwYW5kZWQkLnBpcGUob3BlcmF0b3JzLm1hcChmdW5jdGlvbiAocm9vdFNlZ21lbnRHcm91cCkgeyByZXR1cm4gX3RoaXMuY3JlYXRlVXJsVHJlZShyb290U2VnbWVudEdyb3VwLCBfdGhpcy51cmxUcmVlLnF1ZXJ5UGFyYW1zLCBfdGhpcy51cmxUcmVlLmZyYWdtZW50KTsgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIHVybFRyZWVzJC5waXBlKG9wZXJhdG9ycy5jYXRjaEVycm9yKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBBYnNvbHV0ZVJlZGlyZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFmdGVyIGFuIGFic29sdXRlIHJlZGlyZWN0IHdlIGRvIG5vdCBhcHBseSBhbnkgbW9yZSByZWRpcmVjdHMhXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFsbG93UmVkaXJlY3RzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gcnVuIG1hdGNoaW5nLCBzbyB3ZSBjYW4gZmV0Y2ggYWxsIGxhenktbG9hZGVkIG1vZHVsZXNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm1hdGNoKGUudXJsVHJlZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgTm9NYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBfdGhpcy5ub01hdGNoRXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIEFwcGx5UmVkaXJlY3RzLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uICh0cmVlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGV4cGFuZGVkJCA9IHRoaXMuZXhwYW5kU2VnbWVudEdyb3VwKHRoaXMubmdNb2R1bGUsIHRoaXMuY29uZmlnLCB0cmVlLnJvb3QsIFBSSU1BUllfT1VUTEVUKTtcbiAgICAgICAgICAgIHZhciBtYXBwZWQkID0gZXhwYW5kZWQkLnBpcGUob3BlcmF0b3JzLm1hcChmdW5jdGlvbiAocm9vdFNlZ21lbnRHcm91cCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jcmVhdGVVcmxUcmVlKHJvb3RTZWdtZW50R3JvdXAsIHRyZWUucXVlcnlQYXJhbXMsIHRyZWUuZnJhZ21lbnQpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIG1hcHBlZCQucGlwZShvcGVyYXRvcnMuY2F0Y2hFcnJvcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgTm9NYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBfdGhpcy5ub01hdGNoRXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIEFwcGx5UmVkaXJlY3RzLnByb3RvdHlwZS5ub01hdGNoRXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcIkNhbm5vdCBtYXRjaCBhbnkgcm91dGVzLiBVUkwgU2VnbWVudDogJ1wiICsgZS5zZWdtZW50R3JvdXAgKyBcIidcIik7XG4gICAgICAgIH07XG4gICAgICAgIEFwcGx5UmVkaXJlY3RzLnByb3RvdHlwZS5jcmVhdGVVcmxUcmVlID0gZnVuY3Rpb24gKHJvb3RDYW5kaWRhdGUsIHF1ZXJ5UGFyYW1zLCBmcmFnbWVudCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIHJvb3QgPSByb290Q2FuZGlkYXRlLnNlZ21lbnRzLmxlbmd0aCA+IDAgP1xuICAgICAgICAgICAgICAgIG5ldyBVcmxTZWdtZW50R3JvdXAoW10sIChfYSA9IHt9LCBfYVtQUklNQVJZX09VVExFVF0gPSByb290Q2FuZGlkYXRlLCBfYSkpIDpcbiAgICAgICAgICAgICAgICByb290Q2FuZGlkYXRlO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVcmxUcmVlKHJvb3QsIHF1ZXJ5UGFyYW1zLCBmcmFnbWVudCk7XG4gICAgICAgIH07XG4gICAgICAgIEFwcGx5UmVkaXJlY3RzLnByb3RvdHlwZS5leHBhbmRTZWdtZW50R3JvdXAgPSBmdW5jdGlvbiAobmdNb2R1bGUsIHJvdXRlcywgc2VnbWVudEdyb3VwLCBvdXRsZXQpIHtcbiAgICAgICAgICAgIGlmIChzZWdtZW50R3JvdXAuc2VnbWVudHMubGVuZ3RoID09PSAwICYmIHNlZ21lbnRHcm91cC5oYXNDaGlsZHJlbigpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwYW5kQ2hpbGRyZW4obmdNb2R1bGUsIHJvdXRlcywgc2VnbWVudEdyb3VwKVxuICAgICAgICAgICAgICAgICAgICAucGlwZShvcGVyYXRvcnMubWFwKGZ1bmN0aW9uIChjaGlsZHJlbikgeyByZXR1cm4gbmV3IFVybFNlZ21lbnRHcm91cChbXSwgY2hpbGRyZW4pOyB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHBhbmRTZWdtZW50KG5nTW9kdWxlLCBzZWdtZW50R3JvdXAsIHJvdXRlcywgc2VnbWVudEdyb3VwLnNlZ21lbnRzLCBvdXRsZXQsIHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBleHBhbmQgc2VnbWVudCBncm91cHMgZm9yIGFsbCB0aGUgY2hpbGQgb3V0bGV0c1xuICAgICAgICBBcHBseVJlZGlyZWN0cy5wcm90b3R5cGUuZXhwYW5kQ2hpbGRyZW4gPSBmdW5jdGlvbiAobmdNb2R1bGUsIHJvdXRlcywgc2VnbWVudEdyb3VwKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHdhaXRGb3JNYXAoc2VnbWVudEdyb3VwLmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGRPdXRsZXQsIGNoaWxkKSB7IHJldHVybiBfdGhpcy5leHBhbmRTZWdtZW50R3JvdXAobmdNb2R1bGUsIHJvdXRlcywgY2hpbGQsIGNoaWxkT3V0bGV0KTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEFwcGx5UmVkaXJlY3RzLnByb3RvdHlwZS5leHBhbmRTZWdtZW50ID0gZnVuY3Rpb24gKG5nTW9kdWxlLCBzZWdtZW50R3JvdXAsIHJvdXRlcywgc2VnbWVudHMsIG91dGxldCwgYWxsb3dSZWRpcmVjdHMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gcnhqcy5vZi5hcHBseSh2b2lkIDAsIF9fc3ByZWFkKHJvdXRlcykpLnBpcGUob3BlcmF0b3JzLm1hcChmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICAgIHZhciBleHBhbmRlZCQgPSBfdGhpcy5leHBhbmRTZWdtZW50QWdhaW5zdFJvdXRlKG5nTW9kdWxlLCBzZWdtZW50R3JvdXAsIHJvdXRlcywgciwgc2VnbWVudHMsIG91dGxldCwgYWxsb3dSZWRpcmVjdHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBleHBhbmRlZCQucGlwZShvcGVyYXRvcnMuY2F0Y2hFcnJvcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIE5vTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8oaSk6IHRoaXMgcmV0dXJuIHR5cGUgZG9lc24ndCBtYXRjaCB0aGUgZGVjbGFyZWQgT2JzZXJ2YWJsZTxVcmxTZWdtZW50R3JvdXA+IC1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRhbGsgdG8gSmFzb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByeGpzLm9mKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSksIG9wZXJhdG9ycy5jb25jYXRBbGwoKSwgb3BlcmF0b3JzLmZpcnN0KGZ1bmN0aW9uIChzKSB7IHJldHVybiAhIXM7IH0pLCBvcGVyYXRvcnMuY2F0Y2hFcnJvcihmdW5jdGlvbiAoZSwgXykge1xuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2Ygcnhqcy5FbXB0eUVycm9yIHx8IGUubmFtZSA9PT0gJ0VtcHR5RXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5ub0xlZnRvdmVyc0luVXJsKHNlZ21lbnRHcm91cCwgc2VnbWVudHMsIG91dGxldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByeGpzLm9mKG5ldyBVcmxTZWdtZW50R3JvdXAoW10sIHt9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vTWF0Y2goc2VnbWVudEdyb3VwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwbHlSZWRpcmVjdHMucHJvdG90eXBlLm5vTGVmdG92ZXJzSW5VcmwgPSBmdW5jdGlvbiAoc2VnbWVudEdyb3VwLCBzZWdtZW50cywgb3V0bGV0KSB7XG4gICAgICAgICAgICByZXR1cm4gc2VnbWVudHMubGVuZ3RoID09PSAwICYmICFzZWdtZW50R3JvdXAuY2hpbGRyZW5bb3V0bGV0XTtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwbHlSZWRpcmVjdHMucHJvdG90eXBlLmV4cGFuZFNlZ21lbnRBZ2FpbnN0Um91dGUgPSBmdW5jdGlvbiAobmdNb2R1bGUsIHNlZ21lbnRHcm91cCwgcm91dGVzLCByb3V0ZSwgcGF0aHMsIG91dGxldCwgYWxsb3dSZWRpcmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChnZXRPdXRsZXQocm91dGUpICE9PSBvdXRsZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9NYXRjaChzZWdtZW50R3JvdXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvdXRlLnJlZGlyZWN0VG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hdGNoU2VnbWVudEFnYWluc3RSb3V0ZShuZ01vZHVsZSwgc2VnbWVudEdyb3VwLCByb3V0ZSwgcGF0aHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFsbG93UmVkaXJlY3RzICYmIHRoaXMuYWxsb3dSZWRpcmVjdHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leHBhbmRTZWdtZW50QWdhaW5zdFJvdXRlVXNpbmdSZWRpcmVjdChuZ01vZHVsZSwgc2VnbWVudEdyb3VwLCByb3V0ZXMsIHJvdXRlLCBwYXRocywgb3V0bGV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub01hdGNoKHNlZ21lbnRHcm91cCk7XG4gICAgICAgIH07XG4gICAgICAgIEFwcGx5UmVkaXJlY3RzLnByb3RvdHlwZS5leHBhbmRTZWdtZW50QWdhaW5zdFJvdXRlVXNpbmdSZWRpcmVjdCA9IGZ1bmN0aW9uIChuZ01vZHVsZSwgc2VnbWVudEdyb3VwLCByb3V0ZXMsIHJvdXRlLCBzZWdtZW50cywgb3V0bGV0KSB7XG4gICAgICAgICAgICBpZiAocm91dGUucGF0aCA9PT0gJyoqJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cGFuZFdpbGRDYXJkV2l0aFBhcmFtc0FnYWluc3RSb3V0ZVVzaW5nUmVkaXJlY3QobmdNb2R1bGUsIHJvdXRlcywgcm91dGUsIG91dGxldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHBhbmRSZWd1bGFyU2VnbWVudEFnYWluc3RSb3V0ZVVzaW5nUmVkaXJlY3QobmdNb2R1bGUsIHNlZ21lbnRHcm91cCwgcm91dGVzLCByb3V0ZSwgc2VnbWVudHMsIG91dGxldCk7XG4gICAgICAgIH07XG4gICAgICAgIEFwcGx5UmVkaXJlY3RzLnByb3RvdHlwZS5leHBhbmRXaWxkQ2FyZFdpdGhQYXJhbXNBZ2FpbnN0Um91dGVVc2luZ1JlZGlyZWN0ID0gZnVuY3Rpb24gKG5nTW9kdWxlLCByb3V0ZXMsIHJvdXRlLCBvdXRsZXQpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgbmV3VHJlZSA9IHRoaXMuYXBwbHlSZWRpcmVjdENvbW1hbmRzKFtdLCByb3V0ZS5yZWRpcmVjdFRvLCB7fSk7XG4gICAgICAgICAgICBpZiAocm91dGUucmVkaXJlY3RUby5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWJzb2x1dGVSZWRpcmVjdChuZXdUcmVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbmVyYWxpemVTZWdtZW50cyhyb3V0ZSwgbmV3VHJlZSkucGlwZShvcGVyYXRvcnMubWVyZ2VNYXAoZnVuY3Rpb24gKG5ld1NlZ21lbnRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gbmV3IFVybFNlZ21lbnRHcm91cChuZXdTZWdtZW50cywge30pO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5leHBhbmRTZWdtZW50KG5nTW9kdWxlLCBncm91cCwgcm91dGVzLCBuZXdTZWdtZW50cywgb3V0bGV0LCBmYWxzZSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIEFwcGx5UmVkaXJlY3RzLnByb3RvdHlwZS5leHBhbmRSZWd1bGFyU2VnbWVudEFnYWluc3RSb3V0ZVVzaW5nUmVkaXJlY3QgPSBmdW5jdGlvbiAobmdNb2R1bGUsIHNlZ21lbnRHcm91cCwgcm91dGVzLCByb3V0ZSwgc2VnbWVudHMsIG91dGxldCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBfYSA9IG1hdGNoKHNlZ21lbnRHcm91cCwgcm91dGUsIHNlZ21lbnRzKSwgbWF0Y2hlZCA9IF9hLm1hdGNoZWQsIGNvbnN1bWVkU2VnbWVudHMgPSBfYS5jb25zdW1lZFNlZ21lbnRzLCBsYXN0Q2hpbGQgPSBfYS5sYXN0Q2hpbGQsIHBvc2l0aW9uYWxQYXJhbVNlZ21lbnRzID0gX2EucG9zaXRpb25hbFBhcmFtU2VnbWVudHM7XG4gICAgICAgICAgICBpZiAoIW1hdGNoZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vTWF0Y2goc2VnbWVudEdyb3VwKTtcbiAgICAgICAgICAgIHZhciBuZXdUcmVlID0gdGhpcy5hcHBseVJlZGlyZWN0Q29tbWFuZHMoY29uc3VtZWRTZWdtZW50cywgcm91dGUucmVkaXJlY3RUbywgcG9zaXRpb25hbFBhcmFtU2VnbWVudHMpO1xuICAgICAgICAgICAgaWYgKHJvdXRlLnJlZGlyZWN0VG8uc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFic29sdXRlUmVkaXJlY3QobmV3VHJlZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saW5lcmFsaXplU2VnbWVudHMocm91dGUsIG5ld1RyZWUpLnBpcGUob3BlcmF0b3JzLm1lcmdlTWFwKGZ1bmN0aW9uIChuZXdTZWdtZW50cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5leHBhbmRTZWdtZW50KG5nTW9kdWxlLCBzZWdtZW50R3JvdXAsIHJvdXRlcywgbmV3U2VnbWVudHMuY29uY2F0KHNlZ21lbnRzLnNsaWNlKGxhc3RDaGlsZCkpLCBvdXRsZXQsIGZhbHNlKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwbHlSZWRpcmVjdHMucHJvdG90eXBlLm1hdGNoU2VnbWVudEFnYWluc3RSb3V0ZSA9IGZ1bmN0aW9uIChuZ01vZHVsZSwgcmF3U2VnbWVudEdyb3VwLCByb3V0ZSwgc2VnbWVudHMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAocm91dGUucGF0aCA9PT0gJyoqJykge1xuICAgICAgICAgICAgICAgIGlmIChyb3V0ZS5sb2FkQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnTG9hZGVyLmxvYWQobmdNb2R1bGUuaW5qZWN0b3IsIHJvdXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnBpcGUob3BlcmF0b3JzLm1hcChmdW5jdGlvbiAoY2ZnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZS5fbG9hZGVkQ29uZmlnID0gY2ZnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVcmxTZWdtZW50R3JvdXAoc2VnbWVudHMsIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcnhqcy5vZihuZXcgVXJsU2VnbWVudEdyb3VwKHNlZ21lbnRzLCB7fSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9hID0gbWF0Y2gocmF3U2VnbWVudEdyb3VwLCByb3V0ZSwgc2VnbWVudHMpLCBtYXRjaGVkID0gX2EubWF0Y2hlZCwgY29uc3VtZWRTZWdtZW50cyA9IF9hLmNvbnN1bWVkU2VnbWVudHMsIGxhc3RDaGlsZCA9IF9hLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIGlmICghbWF0Y2hlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9NYXRjaChyYXdTZWdtZW50R3JvdXApO1xuICAgICAgICAgICAgdmFyIHJhd1NsaWNlZFNlZ21lbnRzID0gc2VnbWVudHMuc2xpY2UobGFzdENoaWxkKTtcbiAgICAgICAgICAgIHZhciBjaGlsZENvbmZpZyQgPSB0aGlzLmdldENoaWxkQ29uZmlnKG5nTW9kdWxlLCByb3V0ZSwgc2VnbWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkQ29uZmlnJC5waXBlKG9wZXJhdG9ycy5tZXJnZU1hcChmdW5jdGlvbiAocm91dGVyQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkTW9kdWxlID0gcm91dGVyQ29uZmlnLm1vZHVsZTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRDb25maWcgPSByb3V0ZXJDb25maWcucm91dGVzO1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IHNwbGl0KHJhd1NlZ21lbnRHcm91cCwgY29uc3VtZWRTZWdtZW50cywgcmF3U2xpY2VkU2VnbWVudHMsIGNoaWxkQ29uZmlnKSwgc2VnbWVudEdyb3VwID0gX2Euc2VnbWVudEdyb3VwLCBzbGljZWRTZWdtZW50cyA9IF9hLnNsaWNlZFNlZ21lbnRzO1xuICAgICAgICAgICAgICAgIGlmIChzbGljZWRTZWdtZW50cy5sZW5ndGggPT09IDAgJiYgc2VnbWVudEdyb3VwLmhhc0NoaWxkcmVuKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4cGFuZGVkJF8xID0gX3RoaXMuZXhwYW5kQ2hpbGRyZW4oY2hpbGRNb2R1bGUsIGNoaWxkQ29uZmlnLCBzZWdtZW50R3JvdXApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwYW5kZWQkXzEucGlwZShvcGVyYXRvcnMubWFwKGZ1bmN0aW9uIChjaGlsZHJlbikgeyByZXR1cm4gbmV3IFVybFNlZ21lbnRHcm91cChjb25zdW1lZFNlZ21lbnRzLCBjaGlsZHJlbik7IH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkQ29uZmlnLmxlbmd0aCA9PT0gMCAmJiBzbGljZWRTZWdtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ4anMub2YobmV3IFVybFNlZ21lbnRHcm91cChjb25zdW1lZFNlZ21lbnRzLCB7fSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZXhwYW5kZWQkID0gX3RoaXMuZXhwYW5kU2VnbWVudChjaGlsZE1vZHVsZSwgc2VnbWVudEdyb3VwLCBjaGlsZENvbmZpZywgc2xpY2VkU2VnbWVudHMsIFBSSU1BUllfT1VUTEVULCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwYW5kZWQkLnBpcGUob3BlcmF0b3JzLm1hcChmdW5jdGlvbiAoY3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVcmxTZWdtZW50R3JvdXAoY29uc3VtZWRTZWdtZW50cy5jb25jYXQoY3Muc2VnbWVudHMpLCBjcy5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICBBcHBseVJlZGlyZWN0cy5wcm90b3R5cGUuZ2V0Q2hpbGRDb25maWcgPSBmdW5jdGlvbiAobmdNb2R1bGUsIHJvdXRlLCBzZWdtZW50cykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmIChyb3V0ZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBjaGlsZHJlbiBiZWxvbmcgdG8gdGhlIHNhbWUgbW9kdWxlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ4anMub2YobmV3IExvYWRlZFJvdXRlckNvbmZpZyhyb3V0ZS5jaGlsZHJlbiwgbmdNb2R1bGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyb3V0ZS5sb2FkQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBsYXp5IGNoaWxkcmVuIGJlbG9uZyB0byB0aGUgbG9hZGVkIG1vZHVsZVxuICAgICAgICAgICAgICAgIGlmIChyb3V0ZS5fbG9hZGVkQ29uZmlnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ4anMub2Yocm91dGUuX2xvYWRlZENvbmZpZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBydW5DYW5Mb2FkR3VhcmQobmdNb2R1bGUuaW5qZWN0b3IsIHJvdXRlLCBzZWdtZW50cylcbiAgICAgICAgICAgICAgICAgICAgLnBpcGUob3BlcmF0b3JzLm1lcmdlTWFwKGZ1bmN0aW9uIChzaG91bGRMb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRMb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY29uZmlnTG9hZGVyLmxvYWQobmdNb2R1bGUuaW5qZWN0b3IsIHJvdXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5waXBlKG9wZXJhdG9ycy5tYXAoZnVuY3Rpb24gKGNmZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlLl9sb2FkZWRDb25maWcgPSBjZmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNmZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FuTG9hZEZhaWxzKHJvdXRlKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnhqcy5vZihuZXcgTG9hZGVkUm91dGVyQ29uZmlnKFtdLCBuZ01vZHVsZSkpO1xuICAgICAgICB9O1xuICAgICAgICBBcHBseVJlZGlyZWN0cy5wcm90b3R5cGUubGluZXJhbGl6ZVNlZ21lbnRzID0gZnVuY3Rpb24gKHJvdXRlLCB1cmxUcmVlKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgICAgICB2YXIgYyA9IHVybFRyZWUucm9vdDtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChjLnNlZ21lbnRzKTtcbiAgICAgICAgICAgICAgICBpZiAoYy5udW1iZXJPZkNoaWxkcmVuID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByeGpzLm9mKHJlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjLm51bWJlck9mQ2hpbGRyZW4gPiAxIHx8ICFjLmNoaWxkcmVuW1BSSU1BUllfT1VUTEVUXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZWRPdXRsZXRzUmVkaXJlY3Qocm91dGUucmVkaXJlY3RUbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGMgPSBjLmNoaWxkcmVuW1BSSU1BUllfT1VUTEVUXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQXBwbHlSZWRpcmVjdHMucHJvdG90eXBlLmFwcGx5UmVkaXJlY3RDb21tYW5kcyA9IGZ1bmN0aW9uIChzZWdtZW50cywgcmVkaXJlY3RUbywgcG9zUGFyYW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBseVJlZGlyZWN0Q3JlYXRyZVVybFRyZWUocmVkaXJlY3RUbywgdGhpcy51cmxTZXJpYWxpemVyLnBhcnNlKHJlZGlyZWN0VG8pLCBzZWdtZW50cywgcG9zUGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwbHlSZWRpcmVjdHMucHJvdG90eXBlLmFwcGx5UmVkaXJlY3RDcmVhdHJlVXJsVHJlZSA9IGZ1bmN0aW9uIChyZWRpcmVjdFRvLCB1cmxUcmVlLCBzZWdtZW50cywgcG9zUGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgbmV3Um9vdCA9IHRoaXMuY3JlYXRlU2VnbWVudEdyb3VwKHJlZGlyZWN0VG8sIHVybFRyZWUucm9vdCwgc2VnbWVudHMsIHBvc1BhcmFtcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVybFRyZWUobmV3Um9vdCwgdGhpcy5jcmVhdGVRdWVyeVBhcmFtcyh1cmxUcmVlLnF1ZXJ5UGFyYW1zLCB0aGlzLnVybFRyZWUucXVlcnlQYXJhbXMpLCB1cmxUcmVlLmZyYWdtZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwbHlSZWRpcmVjdHMucHJvdG90eXBlLmNyZWF0ZVF1ZXJ5UGFyYW1zID0gZnVuY3Rpb24gKHJlZGlyZWN0VG9QYXJhbXMsIGFjdHVhbFBhcmFtcykge1xuICAgICAgICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgICAgICAgZm9yRWFjaChyZWRpcmVjdFRvUGFyYW1zLCBmdW5jdGlvbiAodiwgaykge1xuICAgICAgICAgICAgICAgIHZhciBjb3B5U291cmNlVmFsdWUgPSB0eXBlb2YgdiA9PT0gJ3N0cmluZycgJiYgdi5zdGFydHNXaXRoKCc6Jyk7XG4gICAgICAgICAgICAgICAgaWYgKGNvcHlTb3VyY2VWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlTmFtZSA9IHYuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICByZXNba10gPSBhY3R1YWxQYXJhbXNbc291cmNlTmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNba10gPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICAgICAgQXBwbHlSZWRpcmVjdHMucHJvdG90eXBlLmNyZWF0ZVNlZ21lbnRHcm91cCA9IGZ1bmN0aW9uIChyZWRpcmVjdFRvLCBncm91cCwgc2VnbWVudHMsIHBvc1BhcmFtcykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciB1cGRhdGVkU2VnbWVudHMgPSB0aGlzLmNyZWF0ZVNlZ21lbnRzKHJlZGlyZWN0VG8sIGdyb3VwLnNlZ21lbnRzLCBzZWdtZW50cywgcG9zUGFyYW1zKTtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHt9O1xuICAgICAgICAgICAgZm9yRWFjaChncm91cC5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5bbmFtZV0gPSBfdGhpcy5jcmVhdGVTZWdtZW50R3JvdXAocmVkaXJlY3RUbywgY2hpbGQsIHNlZ21lbnRzLCBwb3NQYXJhbXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVybFNlZ21lbnRHcm91cCh1cGRhdGVkU2VnbWVudHMsIGNoaWxkcmVuKTtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwbHlSZWRpcmVjdHMucHJvdG90eXBlLmNyZWF0ZVNlZ21lbnRzID0gZnVuY3Rpb24gKHJlZGlyZWN0VG8sIHJlZGlyZWN0VG9TZWdtZW50cywgYWN0dWFsU2VnbWVudHMsIHBvc1BhcmFtcykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiByZWRpcmVjdFRvU2VnbWVudHMubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnBhdGguc3RhcnRzV2l0aCgnOicpID8gX3RoaXMuZmluZFBvc1BhcmFtKHJlZGlyZWN0VG8sIHMsIHBvc1BhcmFtcykgOlxuICAgICAgICAgICAgICAgIF90aGlzLmZpbmRPclJldHVybihzLCBhY3R1YWxTZWdtZW50cyk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBBcHBseVJlZGlyZWN0cy5wcm90b3R5cGUuZmluZFBvc1BhcmFtID0gZnVuY3Rpb24gKHJlZGlyZWN0VG8sIHJlZGlyZWN0VG9VcmxTZWdtZW50LCBwb3NQYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSBwb3NQYXJhbXNbcmVkaXJlY3RUb1VybFNlZ21lbnQucGF0aC5zdWJzdHJpbmcoMSldO1xuICAgICAgICAgICAgaWYgKCFwb3MpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlZGlyZWN0IHRvICdcIiArIHJlZGlyZWN0VG8gKyBcIicuIENhbm5vdCBmaW5kICdcIiArIHJlZGlyZWN0VG9VcmxTZWdtZW50LnBhdGggKyBcIicuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgfTtcbiAgICAgICAgQXBwbHlSZWRpcmVjdHMucHJvdG90eXBlLmZpbmRPclJldHVybiA9IGZ1bmN0aW9uIChyZWRpcmVjdFRvVXJsU2VnbWVudCwgYWN0dWFsU2VnbWVudHMpIHtcbiAgICAgICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGFjdHVhbFNlZ21lbnRzXzEgPSBfX3ZhbHVlcyhhY3R1YWxTZWdtZW50cyksIGFjdHVhbFNlZ21lbnRzXzFfMSA9IGFjdHVhbFNlZ21lbnRzXzEubmV4dCgpOyAhYWN0dWFsU2VnbWVudHNfMV8xLmRvbmU7IGFjdHVhbFNlZ21lbnRzXzFfMSA9IGFjdHVhbFNlZ21lbnRzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gYWN0dWFsU2VnbWVudHNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocy5wYXRoID09PSByZWRpcmVjdFRvVXJsU2VnbWVudC5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWxTZWdtZW50cy5zcGxpY2UoaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlkeCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0dWFsU2VnbWVudHNfMV8xICYmICFhY3R1YWxTZWdtZW50c18xXzEuZG9uZSAmJiAoX2EgPSBhY3R1YWxTZWdtZW50c18xLnJldHVybikpIF9hLmNhbGwoYWN0dWFsU2VnbWVudHNfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWRpcmVjdFRvVXJsU2VnbWVudDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEFwcGx5UmVkaXJlY3RzO1xuICAgIH0oKSk7XG4gICAgZnVuY3Rpb24gcnVuQ2FuTG9hZEd1YXJkKG1vZHVsZUluamVjdG9yLCByb3V0ZSwgc2VnbWVudHMpIHtcbiAgICAgICAgdmFyIGNhbkxvYWQgPSByb3V0ZS5jYW5Mb2FkO1xuICAgICAgICBpZiAoIWNhbkxvYWQgfHwgY2FuTG9hZC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gcnhqcy5vZih0cnVlKTtcbiAgICAgICAgdmFyIG9icyA9IHJ4anMuZnJvbShjYW5Mb2FkKS5waXBlKG9wZXJhdG9ycy5tYXAoZnVuY3Rpb24gKGluamVjdGlvblRva2VuKSB7XG4gICAgICAgICAgICB2YXIgZ3VhcmQgPSBtb2R1bGVJbmplY3Rvci5nZXQoaW5qZWN0aW9uVG9rZW4pO1xuICAgICAgICAgICAgdmFyIGd1YXJkVmFsO1xuICAgICAgICAgICAgaWYgKGlzQ2FuTG9hZChndWFyZCkpIHtcbiAgICAgICAgICAgICAgICBndWFyZFZhbCA9IGd1YXJkLmNhbkxvYWQocm91dGUsIHNlZ21lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oZ3VhcmQpKSB7XG4gICAgICAgICAgICAgICAgZ3VhcmRWYWwgPSBndWFyZChyb3V0ZSwgc2VnbWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIENhbkxvYWQgZ3VhcmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3cmFwSW50b09ic2VydmFibGUoZ3VhcmRWYWwpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBvYnMucGlwZShvcGVyYXRvcnMuY29uY2F0QWxsKCksIG9wZXJhdG9ycy5ldmVyeShmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiByZXN1bHQgPT09IHRydWU7IH0pKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWF0Y2goc2VnbWVudEdyb3VwLCByb3V0ZSwgc2VnbWVudHMpIHtcbiAgICAgICAgaWYgKHJvdXRlLnBhdGggPT09ICcnKSB7XG4gICAgICAgICAgICBpZiAoKHJvdXRlLnBhdGhNYXRjaCA9PT0gJ2Z1bGwnKSAmJiAoc2VnbWVudEdyb3VwLmhhc0NoaWxkcmVuKCkgfHwgc2VnbWVudHMubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtYXRjaGVkOiBmYWxzZSwgY29uc3VtZWRTZWdtZW50czogW10sIGxhc3RDaGlsZDogMCwgcG9zaXRpb25hbFBhcmFtU2VnbWVudHM6IHt9IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBtYXRjaGVkOiB0cnVlLCBjb25zdW1lZFNlZ21lbnRzOiBbXSwgbGFzdENoaWxkOiAwLCBwb3NpdGlvbmFsUGFyYW1TZWdtZW50czoge30gfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF0Y2hlciA9IHJvdXRlLm1hdGNoZXIgfHwgZGVmYXVsdFVybE1hdGNoZXI7XG4gICAgICAgIHZhciByZXMgPSBtYXRjaGVyKHNlZ21lbnRzLCBzZWdtZW50R3JvdXAsIHJvdXRlKTtcbiAgICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uc3VtZWRTZWdtZW50czogW10sXG4gICAgICAgICAgICAgICAgbGFzdENoaWxkOiAwLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uYWxQYXJhbVNlZ21lbnRzOiB7fSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1hdGNoZWQ6IHRydWUsXG4gICAgICAgICAgICBjb25zdW1lZFNlZ21lbnRzOiByZXMuY29uc3VtZWQsXG4gICAgICAgICAgICBsYXN0Q2hpbGQ6IHJlcy5jb25zdW1lZC5sZW5ndGgsXG4gICAgICAgICAgICBwb3NpdGlvbmFsUGFyYW1TZWdtZW50czogcmVzLnBvc1BhcmFtcyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3BsaXQoc2VnbWVudEdyb3VwLCBjb25zdW1lZFNlZ21lbnRzLCBzbGljZWRTZWdtZW50cywgY29uZmlnKSB7XG4gICAgICAgIGlmIChzbGljZWRTZWdtZW50cy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICBjb250YWluc0VtcHR5UGF0aFJlZGlyZWN0c1dpdGhOYW1lZE91dGxldHMoc2VnbWVudEdyb3VwLCBzbGljZWRTZWdtZW50cywgY29uZmlnKSkge1xuICAgICAgICAgICAgdmFyIHMgPSBuZXcgVXJsU2VnbWVudEdyb3VwKGNvbnN1bWVkU2VnbWVudHMsIGNyZWF0ZUNoaWxkcmVuRm9yRW1wdHlTZWdtZW50cyhjb25maWcsIG5ldyBVcmxTZWdtZW50R3JvdXAoc2xpY2VkU2VnbWVudHMsIHNlZ21lbnRHcm91cC5jaGlsZHJlbikpKTtcbiAgICAgICAgICAgIHJldHVybiB7IHNlZ21lbnRHcm91cDogbWVyZ2VUcml2aWFsQ2hpbGRyZW4ocyksIHNsaWNlZFNlZ21lbnRzOiBbXSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzbGljZWRTZWdtZW50cy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgIGNvbnRhaW5zRW1wdHlQYXRoUmVkaXJlY3RzKHNlZ21lbnRHcm91cCwgc2xpY2VkU2VnbWVudHMsIGNvbmZpZykpIHtcbiAgICAgICAgICAgIHZhciBzID0gbmV3IFVybFNlZ21lbnRHcm91cChzZWdtZW50R3JvdXAuc2VnbWVudHMsIGFkZEVtcHR5U2VnbWVudHNUb0NoaWxkcmVuSWZOZWVkZWQoc2VnbWVudEdyb3VwLCBzbGljZWRTZWdtZW50cywgY29uZmlnLCBzZWdtZW50R3JvdXAuY2hpbGRyZW4pKTtcbiAgICAgICAgICAgIHJldHVybiB7IHNlZ21lbnRHcm91cDogbWVyZ2VUcml2aWFsQ2hpbGRyZW4ocyksIHNsaWNlZFNlZ21lbnRzOiBzbGljZWRTZWdtZW50cyB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNlZ21lbnRHcm91cDogc2VnbWVudEdyb3VwLCBzbGljZWRTZWdtZW50czogc2xpY2VkU2VnbWVudHMgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWVyZ2VUcml2aWFsQ2hpbGRyZW4ocykge1xuICAgICAgICBpZiAocy5udW1iZXJPZkNoaWxkcmVuID09PSAxICYmIHMuY2hpbGRyZW5bUFJJTUFSWV9PVVRMRVRdKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHMuY2hpbGRyZW5bUFJJTUFSWV9PVVRMRVRdO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVcmxTZWdtZW50R3JvdXAocy5zZWdtZW50cy5jb25jYXQoYy5zZWdtZW50cyksIGMuY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRFbXB0eVNlZ21lbnRzVG9DaGlsZHJlbklmTmVlZGVkKHNlZ21lbnRHcm91cCwgc2xpY2VkU2VnbWVudHMsIHJvdXRlcywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGVfMiwgX2E7XG4gICAgICAgIHZhciByZXMgPSB7fTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIHJvdXRlc18xID0gX192YWx1ZXMocm91dGVzKSwgcm91dGVzXzFfMSA9IHJvdXRlc18xLm5leHQoKTsgIXJvdXRlc18xXzEuZG9uZTsgcm91dGVzXzFfMSA9IHJvdXRlc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciByID0gcm91dGVzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eVBhdGhSZWRpcmVjdChzZWdtZW50R3JvdXAsIHNsaWNlZFNlZ21lbnRzLCByKSAmJiAhY2hpbGRyZW5bZ2V0T3V0bGV0KHIpXSkge1xuICAgICAgICAgICAgICAgICAgICByZXNbZ2V0T3V0bGV0KHIpXSA9IG5ldyBVcmxTZWdtZW50R3JvdXAoW10sIHt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChyb3V0ZXNfMV8xICYmICFyb3V0ZXNfMV8xLmRvbmUgJiYgKF9hID0gcm91dGVzXzEucmV0dXJuKSkgX2EuY2FsbChyb3V0ZXNfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9fYXNzaWduJDEoe30sIGNoaWxkcmVuLCByZXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVDaGlsZHJlbkZvckVtcHR5U2VnbWVudHMocm91dGVzLCBwcmltYXJ5U2VnbWVudEdyb3VwKSB7XG4gICAgICAgIHZhciBlXzMsIF9hO1xuICAgICAgICB2YXIgcmVzID0ge307XG4gICAgICAgIHJlc1tQUklNQVJZX09VVExFVF0gPSBwcmltYXJ5U2VnbWVudEdyb3VwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgcm91dGVzXzIgPSBfX3ZhbHVlcyhyb3V0ZXMpLCByb3V0ZXNfMl8xID0gcm91dGVzXzIubmV4dCgpOyAhcm91dGVzXzJfMS5kb25lOyByb3V0ZXNfMl8xID0gcm91dGVzXzIubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSByb3V0ZXNfMl8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChyLnBhdGggPT09ICcnICYmIGdldE91dGxldChyKSAhPT0gUFJJTUFSWV9PVVRMRVQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW2dldE91dGxldChyKV0gPSBuZXcgVXJsU2VnbWVudEdyb3VwKFtdLCB7fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAocm91dGVzXzJfMSAmJiAhcm91dGVzXzJfMS5kb25lICYmIChfYSA9IHJvdXRlc18yLnJldHVybikpIF9hLmNhbGwocm91dGVzXzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnRhaW5zRW1wdHlQYXRoUmVkaXJlY3RzV2l0aE5hbWVkT3V0bGV0cyhzZWdtZW50R3JvdXAsIHNlZ21lbnRzLCByb3V0ZXMpIHtcbiAgICAgICAgcmV0dXJuIHJvdXRlcy5zb21lKGZ1bmN0aW9uIChyKSB7IHJldHVybiBpc0VtcHR5UGF0aFJlZGlyZWN0KHNlZ21lbnRHcm91cCwgc2VnbWVudHMsIHIpICYmIGdldE91dGxldChyKSAhPT0gUFJJTUFSWV9PVVRMRVQ7IH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb250YWluc0VtcHR5UGF0aFJlZGlyZWN0cyhzZWdtZW50R3JvdXAsIHNlZ21lbnRzLCByb3V0ZXMpIHtcbiAgICAgICAgcmV0dXJuIHJvdXRlcy5zb21lKGZ1bmN0aW9uIChyKSB7IHJldHVybiBpc0VtcHR5UGF0aFJlZGlyZWN0KHNlZ21lbnRHcm91cCwgc2VnbWVudHMsIHIpOyB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNFbXB0eVBhdGhSZWRpcmVjdChzZWdtZW50R3JvdXAsIHNlZ21lbnRzLCByKSB7XG4gICAgICAgIGlmICgoc2VnbWVudEdyb3VwLmhhc0NoaWxkcmVuKCkgfHwgc2VnbWVudHMubGVuZ3RoID4gMCkgJiYgci5wYXRoTWF0Y2ggPT09ICdmdWxsJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByLnBhdGggPT09ICcnICYmIHIucmVkaXJlY3RUbyAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRPdXRsZXQocm91dGUpIHtcbiAgICAgICAgcmV0dXJuIHJvdXRlLm91dGxldCB8fCBQUklNQVJZX09VVExFVDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXBwbHlSZWRpcmVjdHMkMShtb2R1bGVJbmplY3RvciwgY29uZmlnTG9hZGVyLCB1cmxTZXJpYWxpemVyLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2UucGlwZShvcGVyYXRvcnMuc3dpdGNoTWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiBhcHBseVJlZGlyZWN0cyhtb2R1bGVJbmplY3RvciwgY29uZmlnTG9hZGVyLCB1cmxTZXJpYWxpemVyLCB0LmV4dHJhY3RlZFVybCwgY29uZmlnKVxuICAgICAgICAgICAgICAgIC5waXBlKG9wZXJhdG9ycy5tYXAoZnVuY3Rpb24gKHVybEFmdGVyUmVkaXJlY3RzKSB7IHJldHVybiAoX19hc3NpZ24kMSh7fSwgdCwgeyB1cmxBZnRlclJlZGlyZWN0czogdXJsQWZ0ZXJSZWRpcmVjdHMgfSkpOyB9KSk7IH0pKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIENhbkFjdGl2YXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDYW5BY3RpdmF0ZShwYXRoKSB7XG4gICAgICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICAgICAgdGhpcy5yb3V0ZSA9IHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENhbkFjdGl2YXRlO1xuICAgIH0oKSk7XG4gICAgdmFyIENhbkRlYWN0aXZhdGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENhbkRlYWN0aXZhdGUoY29tcG9uZW50LCByb3V0ZSkge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgICAgICB0aGlzLnJvdXRlID0gcm91dGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENhbkRlYWN0aXZhdGU7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBnZXRBbGxSb3V0ZUd1YXJkcyhmdXR1cmUsIGN1cnIsIHBhcmVudENvbnRleHRzKSB7XG4gICAgICAgIHZhciBmdXR1cmVSb290ID0gZnV0dXJlLl9yb290O1xuICAgICAgICB2YXIgY3VyclJvb3QgPSBjdXJyID8gY3Vyci5fcm9vdCA6IG51bGw7XG4gICAgICAgIHJldHVybiBnZXRDaGlsZFJvdXRlR3VhcmRzKGZ1dHVyZVJvb3QsIGN1cnJSb290LCBwYXJlbnRDb250ZXh0cywgW2Z1dHVyZVJvb3QudmFsdWVdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q2FuQWN0aXZhdGVDaGlsZChwKSB7XG4gICAgICAgIHZhciBjYW5BY3RpdmF0ZUNoaWxkID0gcC5yb3V0ZUNvbmZpZyA/IHAucm91dGVDb25maWcuY2FuQWN0aXZhdGVDaGlsZCA6IG51bGw7XG4gICAgICAgIGlmICghY2FuQWN0aXZhdGVDaGlsZCB8fCBjYW5BY3RpdmF0ZUNoaWxkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4geyBub2RlOiBwLCBndWFyZHM6IGNhbkFjdGl2YXRlQ2hpbGQgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VG9rZW4odG9rZW4sIHNuYXBzaG90LCBtb2R1bGVJbmplY3Rvcikge1xuICAgICAgICB2YXIgY29uZmlnID0gZ2V0Q2xvc2VzdExvYWRlZENvbmZpZyhzbmFwc2hvdCk7XG4gICAgICAgIHZhciBpbmplY3RvciA9IGNvbmZpZyA/IGNvbmZpZy5tb2R1bGUuaW5qZWN0b3IgOiBtb2R1bGVJbmplY3RvcjtcbiAgICAgICAgcmV0dXJuIGluamVjdG9yLmdldCh0b2tlbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENsb3Nlc3RMb2FkZWRDb25maWcoc25hcHNob3QpIHtcbiAgICAgICAgaWYgKCFzbmFwc2hvdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBmb3IgKHZhciBzID0gc25hcHNob3QucGFyZW50OyBzOyBzID0gcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciByb3V0ZSA9IHMucm91dGVDb25maWc7XG4gICAgICAgICAgICBpZiAocm91dGUgJiYgcm91dGUuX2xvYWRlZENvbmZpZylcbiAgICAgICAgICAgICAgICByZXR1cm4gcm91dGUuX2xvYWRlZENvbmZpZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q2hpbGRSb3V0ZUd1YXJkcyhmdXR1cmVOb2RlLCBjdXJyTm9kZSwgY29udGV4dHMsIGZ1dHVyZVBhdGgsIGNoZWNrcykge1xuICAgICAgICBpZiAoY2hlY2tzID09PSB2b2lkIDApIHsgY2hlY2tzID0ge1xuICAgICAgICAgICAgY2FuRGVhY3RpdmF0ZUNoZWNrczogW10sXG4gICAgICAgICAgICBjYW5BY3RpdmF0ZUNoZWNrczogW11cbiAgICAgICAgfTsgfVxuICAgICAgICB2YXIgcHJldkNoaWxkcmVuID0gbm9kZUNoaWxkcmVuQXNNYXAoY3Vyck5vZGUpO1xuICAgICAgICAvLyBQcm9jZXNzIHRoZSBjaGlsZHJlbiBvZiB0aGUgZnV0dXJlIHJvdXRlXG4gICAgICAgIGZ1dHVyZU5vZGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgZ2V0Um91dGVHdWFyZHMoYywgcHJldkNoaWxkcmVuW2MudmFsdWUub3V0bGV0XSwgY29udGV4dHMsIGZ1dHVyZVBhdGguY29uY2F0KFtjLnZhbHVlXSksIGNoZWNrcyk7XG4gICAgICAgICAgICBkZWxldGUgcHJldkNoaWxkcmVuW2MudmFsdWUub3V0bGV0XTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFByb2Nlc3MgYW55IGNoaWxkcmVuIGxlZnQgZnJvbSB0aGUgY3VycmVudCByb3V0ZSAobm90IGFjdGl2ZSBmb3IgdGhlIGZ1dHVyZSByb3V0ZSlcbiAgICAgICAgZm9yRWFjaChwcmV2Q2hpbGRyZW4sIGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVhY3RpdmF0ZVJvdXRlQW5kSXRzQ2hpbGRyZW4odiwgY29udGV4dHMuZ2V0Q29udGV4dChrKSwgY2hlY2tzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjaGVja3M7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFJvdXRlR3VhcmRzKGZ1dHVyZU5vZGUsIGN1cnJOb2RlLCBwYXJlbnRDb250ZXh0cywgZnV0dXJlUGF0aCwgY2hlY2tzKSB7XG4gICAgICAgIGlmIChjaGVja3MgPT09IHZvaWQgMCkgeyBjaGVja3MgPSB7XG4gICAgICAgICAgICBjYW5EZWFjdGl2YXRlQ2hlY2tzOiBbXSxcbiAgICAgICAgICAgIGNhbkFjdGl2YXRlQ2hlY2tzOiBbXVxuICAgICAgICB9OyB9XG4gICAgICAgIHZhciBmdXR1cmUgPSBmdXR1cmVOb2RlLnZhbHVlO1xuICAgICAgICB2YXIgY3VyciA9IGN1cnJOb2RlID8gY3Vyck5vZGUudmFsdWUgOiBudWxsO1xuICAgICAgICB2YXIgY29udGV4dCA9IHBhcmVudENvbnRleHRzID8gcGFyZW50Q29udGV4dHMuZ2V0Q29udGV4dChmdXR1cmVOb2RlLnZhbHVlLm91dGxldCkgOiBudWxsO1xuICAgICAgICAvLyByZXVzaW5nIHRoZSBub2RlXG4gICAgICAgIGlmIChjdXJyICYmIGZ1dHVyZS5yb3V0ZUNvbmZpZyA9PT0gY3Vyci5yb3V0ZUNvbmZpZykge1xuICAgICAgICAgICAgdmFyIHNob3VsZFJ1biA9IHNob3VsZFJ1bkd1YXJkc0FuZFJlc29sdmVycyhjdXJyLCBmdXR1cmUsIGZ1dHVyZS5yb3V0ZUNvbmZpZy5ydW5HdWFyZHNBbmRSZXNvbHZlcnMpO1xuICAgICAgICAgICAgaWYgKHNob3VsZFJ1bikge1xuICAgICAgICAgICAgICAgIGNoZWNrcy5jYW5BY3RpdmF0ZUNoZWNrcy5wdXNoKG5ldyBDYW5BY3RpdmF0ZShmdXR1cmVQYXRoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHNldCB0aGUgZGF0YVxuICAgICAgICAgICAgICAgIGZ1dHVyZS5kYXRhID0gY3Vyci5kYXRhO1xuICAgICAgICAgICAgICAgIGZ1dHVyZS5fcmVzb2x2ZWREYXRhID0gY3Vyci5fcmVzb2x2ZWREYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIGNvbXBvbmVudCwgd2UgbmVlZCB0byBnbyB0aHJvdWdoIGFuIG91dGxldC5cbiAgICAgICAgICAgIGlmIChmdXR1cmUuY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgZ2V0Q2hpbGRSb3V0ZUd1YXJkcyhmdXR1cmVOb2RlLCBjdXJyTm9kZSwgY29udGV4dCA/IGNvbnRleHQuY2hpbGRyZW4gOiBudWxsLCBmdXR1cmVQYXRoLCBjaGVja3MpO1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgYSBjb21wb25lbnRsZXNzIHJvdXRlLCB3ZSByZWN1cnNlIGJ1dCBrZWVwIHRoZSBzYW1lIG91dGxldCBtYXAuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZXRDaGlsZFJvdXRlR3VhcmRzKGZ1dHVyZU5vZGUsIGN1cnJOb2RlLCBwYXJlbnRDb250ZXh0cywgZnV0dXJlUGF0aCwgY2hlY2tzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGRSdW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gY29udGV4dCAmJiBjb250ZXh0Lm91dGxldCAmJiBjb250ZXh0Lm91dGxldC5jb21wb25lbnQgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICBjaGVja3MuY2FuRGVhY3RpdmF0ZUNoZWNrcy5wdXNoKG5ldyBDYW5EZWFjdGl2YXRlKGNvbXBvbmVudCwgY3VycikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGN1cnIpIHtcbiAgICAgICAgICAgICAgICBkZWFjdGl2YXRlUm91dGVBbmRJdHNDaGlsZHJlbihjdXJyTm9kZSwgY29udGV4dCwgY2hlY2tzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoZWNrcy5jYW5BY3RpdmF0ZUNoZWNrcy5wdXNoKG5ldyBDYW5BY3RpdmF0ZShmdXR1cmVQYXRoKSk7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgY29tcG9uZW50LCB3ZSBuZWVkIHRvIGdvIHRocm91Z2ggYW4gb3V0bGV0LlxuICAgICAgICAgICAgaWYgKGZ1dHVyZS5jb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBnZXRDaGlsZFJvdXRlR3VhcmRzKGZ1dHVyZU5vZGUsIG51bGwsIGNvbnRleHQgPyBjb250ZXh0LmNoaWxkcmVuIDogbnVsbCwgZnV0dXJlUGF0aCwgY2hlY2tzKTtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgY29tcG9uZW50bGVzcyByb3V0ZSwgd2UgcmVjdXJzZSBidXQga2VlcCB0aGUgc2FtZSBvdXRsZXQgbWFwLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2V0Q2hpbGRSb3V0ZUd1YXJkcyhmdXR1cmVOb2RlLCBudWxsLCBwYXJlbnRDb250ZXh0cywgZnV0dXJlUGF0aCwgY2hlY2tzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hlY2tzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaG91bGRSdW5HdWFyZHNBbmRSZXNvbHZlcnMoY3VyciwgZnV0dXJlLCBtb2RlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbW9kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG1vZGUoY3VyciwgZnV0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3BhdGhQYXJhbXNDaGFuZ2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiAhZXF1YWxQYXRoKGN1cnIudXJsLCBmdXR1cmUudXJsKTtcbiAgICAgICAgICAgIGNhc2UgJ3BhdGhQYXJhbXNPclF1ZXJ5UGFyYW1zQ2hhbmdlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gIWVxdWFsUGF0aChjdXJyLnVybCwgZnV0dXJlLnVybCkgfHxcbiAgICAgICAgICAgICAgICAgICAgIXNoYWxsb3dFcXVhbChjdXJyLnF1ZXJ5UGFyYW1zLCBmdXR1cmUucXVlcnlQYXJhbXMpO1xuICAgICAgICAgICAgY2FzZSAnYWx3YXlzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNhc2UgJ3BhcmFtc09yUXVlcnlQYXJhbXNDaGFuZ2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiAhZXF1YWxQYXJhbXNBbmRVcmxTZWdtZW50cyhjdXJyLCBmdXR1cmUpIHx8XG4gICAgICAgICAgICAgICAgICAgICFzaGFsbG93RXF1YWwoY3Vyci5xdWVyeVBhcmFtcywgZnV0dXJlLnF1ZXJ5UGFyYW1zKTtcbiAgICAgICAgICAgIGNhc2UgJ3BhcmFtc0NoYW5nZSc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAhZXF1YWxQYXJhbXNBbmRVcmxTZWdtZW50cyhjdXJyLCBmdXR1cmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlYWN0aXZhdGVSb3V0ZUFuZEl0c0NoaWxkcmVuKHJvdXRlLCBjb250ZXh0LCBjaGVja3MpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZUNoaWxkcmVuQXNNYXAocm91dGUpO1xuICAgICAgICB2YXIgciA9IHJvdXRlLnZhbHVlO1xuICAgICAgICBmb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAobm9kZSwgY2hpbGROYW1lKSB7XG4gICAgICAgICAgICBpZiAoIXIuY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgZGVhY3RpdmF0ZVJvdXRlQW5kSXRzQ2hpbGRyZW4obm9kZSwgY29udGV4dCwgY2hlY2tzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBkZWFjdGl2YXRlUm91dGVBbmRJdHNDaGlsZHJlbihub2RlLCBjb250ZXh0LmNoaWxkcmVuLmdldENvbnRleHQoY2hpbGROYW1lKSwgY2hlY2tzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlYWN0aXZhdGVSb3V0ZUFuZEl0c0NoaWxkcmVuKG5vZGUsIG51bGwsIGNoZWNrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXIuY29tcG9uZW50KSB7XG4gICAgICAgICAgICBjaGVja3MuY2FuRGVhY3RpdmF0ZUNoZWNrcy5wdXNoKG5ldyBDYW5EZWFjdGl2YXRlKG51bGwsIHIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250ZXh0ICYmIGNvbnRleHQub3V0bGV0ICYmIGNvbnRleHQub3V0bGV0LmlzQWN0aXZhdGVkKSB7XG4gICAgICAgICAgICBjaGVja3MuY2FuRGVhY3RpdmF0ZUNoZWNrcy5wdXNoKG5ldyBDYW5EZWFjdGl2YXRlKGNvbnRleHQub3V0bGV0LmNvbXBvbmVudCwgcikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2hlY2tzLmNhbkRlYWN0aXZhdGVDaGVja3MucHVzaChuZXcgQ2FuRGVhY3RpdmF0ZShudWxsLCByKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIElOSVRJQUxfVkFMVUUgPSBTeW1ib2woJ0lOSVRJQUxfVkFMVUUnKTtcbiAgICBmdW5jdGlvbiBwcmlvcml0aXplZEd1YXJkVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBvcGVyYXRvcnMuc3dpdGNoTWFwKGZ1bmN0aW9uIChvYnMpIHtcbiAgICAgICAgICAgIHJldHVybiByeGpzLmNvbWJpbmVMYXRlc3QuYXBwbHkodm9pZCAwLCBfX3NwcmVhZChvYnMubWFwKGZ1bmN0aW9uIChvKSB7IHJldHVybiBvLnBpcGUob3BlcmF0b3JzLnRha2UoMSksIG9wZXJhdG9ycy5zdGFydFdpdGgoSU5JVElBTF9WQUxVRSkpOyB9KSkpLnBpcGUob3BlcmF0b3JzLnNjYW4oZnVuY3Rpb24gKGFjYywgbGlzdCkge1xuICAgICAgICAgICAgICAgIHZhciBpc1BlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlzdC5yZWR1Y2UoZnVuY3Rpb24gKGlubmVyQWNjLCB2YWwsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyQWNjICE9PSBJTklUSUFMX1ZBTFVFKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlubmVyQWNjO1xuICAgICAgICAgICAgICAgICAgICAvLyBUb2dnbGUgcGVuZGluZyBmbGFnIGlmIGFueSB2YWx1ZXMgaGF2ZW4ndCBiZWVuIHNldCB5ZXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gSU5JVElBTF9WQUxVRSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUGVuZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFueSBvdGhlciByZXR1cm4gdmFsdWVzIGFyZSBvbmx5IHZhbGlkIGlmIHdlIGhhdmVuJ3QgeWV0IGhpdCBhIHBlbmRpbmcgY2FsbC5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBndWFyYW50ZWVzIHRoYXQgaW4gdGhlIGNhc2Ugb2YgYSBndWFyZCBhdCB0aGUgYm90dG9tIG9mIHRoZSB0cmVlIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBhIHJlZGlyZWN0LCB3ZSB3aWxsIHdhaXQgZm9yIHRoZSBoaWdoZXIgcHJpb3JpdHkgZ3VhcmQgYXQgdGhlIHRvcCB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBmaW5pc2ggYmVmb3JlIHBlcmZvcm1pbmcgdGhlIHJlZGlyZWN0LlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUGVuZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWFybHkgcmV0dXJuIHdoZW4gd2UgaGl0IGEgYGZhbHNlYCB2YWx1ZSBhcyB0aGF0IHNob3VsZCBhbHdheXMgY2FuY2VsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBuYXZpZ2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IGxpc3QubGVuZ3RoIC0gMSB8fCBpc1VybFRyZWUodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlubmVyQWNjO1xuICAgICAgICAgICAgICAgIH0sIGFjYyk7XG4gICAgICAgICAgICB9LCBJTklUSUFMX1ZBTFVFKSwgb3BlcmF0b3JzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbSAhPT0gSU5JVElBTF9WQUxVRTsgfSksIG9wZXJhdG9ycy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGlzVXJsVHJlZShpdGVtKSA/IGl0ZW0gOiBpdGVtID09PSB0cnVlOyB9KSwgLy9cbiAgICAgICAgICAgIG9wZXJhdG9ycy50YWtlKDEpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoZWNrR3VhcmRzKG1vZHVsZUluamVjdG9yLCBmb3J3YXJkRXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2UucGlwZShvcGVyYXRvcnMubWVyZ2VNYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0U25hcHNob3QgPSB0LnRhcmdldFNuYXBzaG90LCBjdXJyZW50U25hcHNob3QgPSB0LmN1cnJlbnRTbmFwc2hvdCwgX2EgPSB0Lmd1YXJkcywgY2FuQWN0aXZhdGVDaGVja3MgPSBfYS5jYW5BY3RpdmF0ZUNoZWNrcywgY2FuRGVhY3RpdmF0ZUNoZWNrcyA9IF9hLmNhbkRlYWN0aXZhdGVDaGVja3M7XG4gICAgICAgICAgICAgICAgaWYgKGNhbkRlYWN0aXZhdGVDaGVja3MubGVuZ3RoID09PSAwICYmIGNhbkFjdGl2YXRlQ2hlY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnhqcy5vZihfX2Fzc2lnbiQxKHt9LCB0LCB7IGd1YXJkc1Jlc3VsdDogdHJ1ZSB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBydW5DYW5EZWFjdGl2YXRlQ2hlY2tzKGNhbkRlYWN0aXZhdGVDaGVja3MsIHRhcmdldFNuYXBzaG90LCBjdXJyZW50U25hcHNob3QsIG1vZHVsZUluamVjdG9yKVxuICAgICAgICAgICAgICAgICAgICAucGlwZShvcGVyYXRvcnMubWVyZ2VNYXAoZnVuY3Rpb24gKGNhbkRlYWN0aXZhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbkRlYWN0aXZhdGUgJiYgaXNCb29sZWFuKGNhbkRlYWN0aXZhdGUpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bkNhbkFjdGl2YXRlQ2hlY2tzKHRhcmdldFNuYXBzaG90LCBjYW5BY3RpdmF0ZUNoZWNrcywgbW9kdWxlSW5qZWN0b3IsIGZvcndhcmRFdmVudCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgcnhqcy5vZihjYW5EZWFjdGl2YXRlKTtcbiAgICAgICAgICAgICAgICB9KSwgb3BlcmF0b3JzLm1hcChmdW5jdGlvbiAoZ3VhcmRzUmVzdWx0KSB7IHJldHVybiAoX19hc3NpZ24kMSh7fSwgdCwgeyBndWFyZHNSZXN1bHQ6IGd1YXJkc1Jlc3VsdCB9KSk7IH0pKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcnVuQ2FuRGVhY3RpdmF0ZUNoZWNrcyhjaGVja3MsIGZ1dHVyZVJTUywgY3VyclJTUywgbW9kdWxlSW5qZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHJ4anMuZnJvbShjaGVja3MpLnBpcGUob3BlcmF0b3JzLm1lcmdlTWFwKGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgICAgICAgcmV0dXJuIHJ1bkNhbkRlYWN0aXZhdGUoY2hlY2suY29tcG9uZW50LCBjaGVjay5yb3V0ZSwgY3VyclJTUywgZnV0dXJlUlNTLCBtb2R1bGVJbmplY3Rvcik7XG4gICAgICAgIH0pLCBvcGVyYXRvcnMuZmlyc3QoZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0ICE9PSB0cnVlOyB9LCB0cnVlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJ1bkNhbkFjdGl2YXRlQ2hlY2tzKGZ1dHVyZVNuYXBzaG90LCBjaGVja3MsIG1vZHVsZUluamVjdG9yLCBmb3J3YXJkRXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHJ4anMuZnJvbShjaGVja3MpLnBpcGUob3BlcmF0b3JzLmNvbmNhdE1hcChmdW5jdGlvbiAoY2hlY2spIHtcbiAgICAgICAgICAgIHJldHVybiByeGpzLmZyb20oW1xuICAgICAgICAgICAgICAgIGZpcmVDaGlsZEFjdGl2YXRpb25TdGFydChjaGVjay5yb3V0ZS5wYXJlbnQsIGZvcndhcmRFdmVudCksXG4gICAgICAgICAgICAgICAgZmlyZUFjdGl2YXRpb25TdGFydChjaGVjay5yb3V0ZSwgZm9yd2FyZEV2ZW50KSxcbiAgICAgICAgICAgICAgICBydW5DYW5BY3RpdmF0ZUNoaWxkKGZ1dHVyZVNuYXBzaG90LCBjaGVjay5wYXRoLCBtb2R1bGVJbmplY3RvciksXG4gICAgICAgICAgICAgICAgcnVuQ2FuQWN0aXZhdGUoZnV0dXJlU25hcHNob3QsIGNoZWNrLnJvdXRlLCBtb2R1bGVJbmplY3RvcilcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgLnBpcGUob3BlcmF0b3JzLmNvbmNhdEFsbCgpLCBvcGVyYXRvcnMuZmlyc3QoZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgIT09IHRydWU7XG4gICAgICAgICAgICB9LCB0cnVlKSk7XG4gICAgICAgIH0pLCBvcGVyYXRvcnMuZmlyc3QoZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0ICE9PSB0cnVlOyB9LCB0cnVlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgICogVGhpcyBzaG91bGQgZmlyZSBvZmYgYEFjdGl2YXRpb25TdGFydGAgZXZlbnRzIGZvciBlYWNoIHJvdXRlIGJlaW5nIGFjdGl2YXRlZCBhdCB0aGlzXG4gICAgICAgKiBsZXZlbC5cbiAgICAgICAqIEluIG90aGVyIHdvcmRzLCBpZiB5b3UncmUgYWN0aXZhdGluZyBgYWAgYW5kIGBiYCBiZWxvdywgYHBhdGhgIHdpbGwgY29udGFpbiB0aGVcbiAgICAgICAqIGBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90YHMgZm9yIGJvdGggYW5kIHdlIHdpbGwgZmlyZSBgQWN0aXZhdGlvblN0YXJ0YCBmb3IgYm90aC4gQWx3YXlzXG4gICAgICAgKiByZXR1cm5cbiAgICAgICAqIGB0cnVlYCBzbyBjaGVja3MgY29udGludWUgdG8gcnVuLlxuICAgICAgICovXG4gICAgZnVuY3Rpb24gZmlyZUFjdGl2YXRpb25TdGFydChzbmFwc2hvdCwgZm9yd2FyZEV2ZW50KSB7XG4gICAgICAgIGlmIChzbmFwc2hvdCAhPT0gbnVsbCAmJiBmb3J3YXJkRXZlbnQpIHtcbiAgICAgICAgICAgIGZvcndhcmRFdmVudChuZXcgQWN0aXZhdGlvblN0YXJ0KHNuYXBzaG90KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ4anMub2YodHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgICogVGhpcyBzaG91bGQgZmlyZSBvZmYgYENoaWxkQWN0aXZhdGlvblN0YXJ0YCBldmVudHMgZm9yIGVhY2ggcm91dGUgYmVpbmcgYWN0aXZhdGVkIGF0IHRoaXNcbiAgICAgICAqIGxldmVsLlxuICAgICAgICogSW4gb3RoZXIgd29yZHMsIGlmIHlvdSdyZSBhY3RpdmF0aW5nIGBhYCBhbmQgYGJgIGJlbG93LCBgcGF0aGAgd2lsbCBjb250YWluIHRoZVxuICAgICAgICogYEFjdGl2YXRlZFJvdXRlU25hcHNob3RgcyBmb3IgYm90aCBhbmQgd2Ugd2lsbCBmaXJlIGBDaGlsZEFjdGl2YXRpb25TdGFydGAgZm9yIGJvdGguIEFsd2F5c1xuICAgICAgICogcmV0dXJuXG4gICAgICAgKiBgdHJ1ZWAgc28gY2hlY2tzIGNvbnRpbnVlIHRvIHJ1bi5cbiAgICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpcmVDaGlsZEFjdGl2YXRpb25TdGFydChzbmFwc2hvdCwgZm9yd2FyZEV2ZW50KSB7XG4gICAgICAgIGlmIChzbmFwc2hvdCAhPT0gbnVsbCAmJiBmb3J3YXJkRXZlbnQpIHtcbiAgICAgICAgICAgIGZvcndhcmRFdmVudChuZXcgQ2hpbGRBY3RpdmF0aW9uU3RhcnQoc25hcHNob3QpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnhqcy5vZih0cnVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcnVuQ2FuQWN0aXZhdGUoZnV0dXJlUlNTLCBmdXR1cmVBUlMsIG1vZHVsZUluamVjdG9yKSB7XG4gICAgICAgIHZhciBjYW5BY3RpdmF0ZSA9IGZ1dHVyZUFSUy5yb3V0ZUNvbmZpZyA/IGZ1dHVyZUFSUy5yb3V0ZUNvbmZpZy5jYW5BY3RpdmF0ZSA6IG51bGw7XG4gICAgICAgIGlmICghY2FuQWN0aXZhdGUgfHwgY2FuQWN0aXZhdGUubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHJ4anMub2YodHJ1ZSk7XG4gICAgICAgIHZhciBjYW5BY3RpdmF0ZU9ic2VydmFibGVzID0gY2FuQWN0aXZhdGUubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4gcnhqcy5kZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGd1YXJkID0gZ2V0VG9rZW4oYywgZnV0dXJlQVJTLCBtb2R1bGVJbmplY3Rvcik7XG4gICAgICAgICAgICAgICAgdmFyIG9ic2VydmFibGU7XG4gICAgICAgICAgICAgICAgaWYgKGlzQ2FuQWN0aXZhdGUoZ3VhcmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmFibGUgPSB3cmFwSW50b09ic2VydmFibGUoZ3VhcmQuY2FuQWN0aXZhdGUoZnV0dXJlQVJTLCBmdXR1cmVSU1MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihndWFyZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2YWJsZSA9IHdyYXBJbnRvT2JzZXJ2YWJsZShndWFyZChmdXR1cmVBUlMsIGZ1dHVyZVJTUykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIENhbkFjdGl2YXRlIGd1YXJkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvYnNlcnZhYmxlLnBpcGUob3BlcmF0b3JzLmZpcnN0KCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcnhqcy5vZihjYW5BY3RpdmF0ZU9ic2VydmFibGVzKS5waXBlKHByaW9yaXRpemVkR3VhcmRWYWx1ZSgpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcnVuQ2FuQWN0aXZhdGVDaGlsZChmdXR1cmVSU1MsIHBhdGgsIG1vZHVsZUluamVjdG9yKSB7XG4gICAgICAgIHZhciBmdXR1cmVBUlMgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBjYW5BY3RpdmF0ZUNoaWxkR3VhcmRzID0gcGF0aC5zbGljZSgwLCBwYXRoLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBnZXRDYW5BY3RpdmF0ZUNoaWxkKHApOyB9KVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoXykgeyByZXR1cm4gXyAhPT0gbnVsbDsgfSk7XG4gICAgICAgIHZhciBjYW5BY3RpdmF0ZUNoaWxkR3VhcmRzTWFwcGVkID0gY2FuQWN0aXZhdGVDaGlsZEd1YXJkcy5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiByeGpzLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3VhcmRzTWFwcGVkID0gZC5ndWFyZHMubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBndWFyZCA9IGdldFRva2VuKGMsIGQubm9kZSwgbW9kdWxlSW5qZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2JzZXJ2YWJsZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2FuQWN0aXZhdGVDaGlsZChndWFyZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmFibGUgPSB3cmFwSW50b09ic2VydmFibGUoZ3VhcmQuY2FuQWN0aXZhdGVDaGlsZChmdXR1cmVBUlMsIGZ1dHVyZVJTUykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oZ3VhcmQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZhYmxlID0gd3JhcEludG9PYnNlcnZhYmxlKGd1YXJkKGZ1dHVyZUFSUywgZnV0dXJlUlNTKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgQ2FuQWN0aXZhdGVDaGlsZCBndWFyZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYnNlcnZhYmxlLnBpcGUob3BlcmF0b3JzLmZpcnN0KCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByeGpzLm9mKGd1YXJkc01hcHBlZCkucGlwZShwcmlvcml0aXplZEd1YXJkVmFsdWUoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByeGpzLm9mKGNhbkFjdGl2YXRlQ2hpbGRHdWFyZHNNYXBwZWQpLnBpcGUocHJpb3JpdGl6ZWRHdWFyZFZhbHVlKCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBydW5DYW5EZWFjdGl2YXRlKGNvbXBvbmVudCwgY3VyckFSUywgY3VyclJTUywgZnV0dXJlUlNTLCBtb2R1bGVJbmplY3Rvcikge1xuICAgICAgICB2YXIgY2FuRGVhY3RpdmF0ZSA9IGN1cnJBUlMgJiYgY3VyckFSUy5yb3V0ZUNvbmZpZyA/IGN1cnJBUlMucm91dGVDb25maWcuY2FuRGVhY3RpdmF0ZSA6IG51bGw7XG4gICAgICAgIGlmICghY2FuRGVhY3RpdmF0ZSB8fCBjYW5EZWFjdGl2YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiByeGpzLm9mKHRydWUpO1xuICAgICAgICB2YXIgY2FuRGVhY3RpdmF0ZU9ic2VydmFibGVzID0gY2FuRGVhY3RpdmF0ZS5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHZhciBndWFyZCA9IGdldFRva2VuKGMsIGN1cnJBUlMsIG1vZHVsZUluamVjdG9yKTtcbiAgICAgICAgICAgIHZhciBvYnNlcnZhYmxlO1xuICAgICAgICAgICAgaWYgKGlzQ2FuRGVhY3RpdmF0ZShndWFyZCkpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZhYmxlID1cbiAgICAgICAgICAgICAgICAgICAgd3JhcEludG9PYnNlcnZhYmxlKGd1YXJkLmNhbkRlYWN0aXZhdGUoY29tcG9uZW50LCBjdXJyQVJTLCBjdXJyUlNTLCBmdXR1cmVSU1MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oZ3VhcmQpKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2YWJsZSA9IHdyYXBJbnRvT2JzZXJ2YWJsZShndWFyZChjb21wb25lbnQsIGN1cnJBUlMsIGN1cnJSU1MsIGZ1dHVyZVJTUykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIENhbkRlYWN0aXZhdGUgZ3VhcmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYnNlcnZhYmxlLnBpcGUob3BlcmF0b3JzLmZpcnN0KCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJ4anMub2YoY2FuRGVhY3RpdmF0ZU9ic2VydmFibGVzKS5waXBlKHByaW9yaXRpemVkR3VhcmRWYWx1ZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIE5vTWF0Y2gkMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTm9NYXRjaCgpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTm9NYXRjaDtcbiAgICB9KCkpO1xuICAgIGZ1bmN0aW9uIHJlY29nbml6ZShyb290Q29tcG9uZW50VHlwZSwgY29uZmlnLCB1cmxUcmVlLCB1cmwsIHBhcmFtc0luaGVyaXRhbmNlU3RyYXRlZ3ksIHJlbGF0aXZlTGlua1Jlc29sdXRpb24pIHtcbiAgICAgICAgaWYgKHBhcmFtc0luaGVyaXRhbmNlU3RyYXRlZ3kgPT09IHZvaWQgMCkgeyBwYXJhbXNJbmhlcml0YW5jZVN0cmF0ZWd5ID0gJ2VtcHR5T25seSc7IH1cbiAgICAgICAgaWYgKHJlbGF0aXZlTGlua1Jlc29sdXRpb24gPT09IHZvaWQgMCkgeyByZWxhdGl2ZUxpbmtSZXNvbHV0aW9uID0gJ2xlZ2FjeSc7IH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZWNvZ25pemVyKHJvb3RDb21wb25lbnRUeXBlLCBjb25maWcsIHVybFRyZWUsIHVybCwgcGFyYW1zSW5oZXJpdGFuY2VTdHJhdGVneSwgcmVsYXRpdmVMaW5rUmVzb2x1dGlvbilcbiAgICAgICAgICAgIC5yZWNvZ25pemUoKTtcbiAgICB9XG4gICAgdmFyIFJlY29nbml6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlY29nbml6ZXIocm9vdENvbXBvbmVudFR5cGUsIGNvbmZpZywgdXJsVHJlZSwgdXJsLCBwYXJhbXNJbmhlcml0YW5jZVN0cmF0ZWd5LCByZWxhdGl2ZUxpbmtSZXNvbHV0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3RDb21wb25lbnRUeXBlID0gcm9vdENvbXBvbmVudFR5cGU7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgICAgIHRoaXMudXJsVHJlZSA9IHVybFRyZWU7XG4gICAgICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zSW5oZXJpdGFuY2VTdHJhdGVneSA9IHBhcmFtc0luaGVyaXRhbmNlU3RyYXRlZ3k7XG4gICAgICAgICAgICB0aGlzLnJlbGF0aXZlTGlua1Jlc29sdXRpb24gPSByZWxhdGl2ZUxpbmtSZXNvbHV0aW9uO1xuICAgICAgICB9XG4gICAgICAgIFJlY29nbml6ZXIucHJvdG90eXBlLnJlY29nbml6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvb3RTZWdtZW50R3JvdXAgPSBzcGxpdCQxKHRoaXMudXJsVHJlZS5yb290LCBbXSwgW10sIHRoaXMuY29uZmlnLCB0aGlzLnJlbGF0aXZlTGlua1Jlc29sdXRpb24pLnNlZ21lbnRHcm91cDtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByb2Nlc3NTZWdtZW50R3JvdXAodGhpcy5jb25maWcsIHJvb3RTZWdtZW50R3JvdXAsIFBSSU1BUllfT1VUTEVUKTtcbiAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IG5ldyBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90KFtdLCBPYmplY3QuZnJlZXplKHt9KSwgT2JqZWN0LmZyZWV6ZShfX2Fzc2lnbiQxKHt9LCB0aGlzLnVybFRyZWUucXVlcnlQYXJhbXMpKSwgdGhpcy51cmxUcmVlLmZyYWdtZW50LCB7fSwgUFJJTUFSWV9PVVRMRVQsIHRoaXMucm9vdENvbXBvbmVudFR5cGUsIG51bGwsIHRoaXMudXJsVHJlZS5yb290LCAtMSwge30pO1xuICAgICAgICAgICAgICAgIHZhciByb290Tm9kZSA9IG5ldyBUcmVlTm9kZShyb290LCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgdmFyIHJvdXRlU3RhdGUgPSBuZXcgUm91dGVyU3RhdGVTbmFwc2hvdCh0aGlzLnVybCwgcm9vdE5vZGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5oZXJpdFBhcmFtc0FuZERhdGEocm91dGVTdGF0ZS5fcm9vdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ4anMub2Yocm91dGVTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcnhqcy5PYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnMpIHsgcmV0dXJuIG9icy5lcnJvcihlKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFJlY29nbml6ZXIucHJvdG90eXBlLmluaGVyaXRQYXJhbXNBbmREYXRhID0gZnVuY3Rpb24gKHJvdXRlTm9kZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciByb3V0ZSA9IHJvdXRlTm9kZS52YWx1ZTtcbiAgICAgICAgICAgIHZhciBpID0gaW5oZXJpdGVkUGFyYW1zRGF0YVJlc29sdmUocm91dGUsIHRoaXMucGFyYW1zSW5oZXJpdGFuY2VTdHJhdGVneSk7XG4gICAgICAgICAgICByb3V0ZS5wYXJhbXMgPSBPYmplY3QuZnJlZXplKGkucGFyYW1zKTtcbiAgICAgICAgICAgIHJvdXRlLmRhdGEgPSBPYmplY3QuZnJlZXplKGkuZGF0YSk7XG4gICAgICAgICAgICByb3V0ZU5vZGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAobikgeyByZXR1cm4gX3RoaXMuaW5oZXJpdFBhcmFtc0FuZERhdGEobik7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBSZWNvZ25pemVyLnByb3RvdHlwZS5wcm9jZXNzU2VnbWVudEdyb3VwID0gZnVuY3Rpb24gKGNvbmZpZywgc2VnbWVudEdyb3VwLCBvdXRsZXQpIHtcbiAgICAgICAgICAgIGlmIChzZWdtZW50R3JvdXAuc2VnbWVudHMubGVuZ3RoID09PSAwICYmIHNlZ21lbnRHcm91cC5oYXNDaGlsZHJlbigpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc0NoaWxkcmVuKGNvbmZpZywgc2VnbWVudEdyb3VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NTZWdtZW50KGNvbmZpZywgc2VnbWVudEdyb3VwLCBzZWdtZW50R3JvdXAuc2VnbWVudHMsIG91dGxldCk7XG4gICAgICAgIH07XG4gICAgICAgIFJlY29nbml6ZXIucHJvdG90eXBlLnByb2Nlc3NDaGlsZHJlbiA9IGZ1bmN0aW9uIChjb25maWcsIHNlZ21lbnRHcm91cCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IG1hcENoaWxkcmVuSW50b0FycmF5KHNlZ21lbnRHcm91cCwgZnVuY3Rpb24gKGNoaWxkLCBjaGlsZE91dGxldCkgeyByZXR1cm4gX3RoaXMucHJvY2Vzc1NlZ21lbnRHcm91cChjb25maWcsIGNoaWxkLCBjaGlsZE91dGxldCk7IH0pO1xuICAgICAgICAgICAgY2hlY2tPdXRsZXROYW1lVW5pcXVlbmVzcyhjaGlsZHJlbik7XG4gICAgICAgICAgICBzb3J0QWN0aXZhdGVkUm91dGVTbmFwc2hvdHMoY2hpbGRyZW4pO1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgICB9O1xuICAgICAgICBSZWNvZ25pemVyLnByb3RvdHlwZS5wcm9jZXNzU2VnbWVudCA9IGZ1bmN0aW9uIChjb25maWcsIHNlZ21lbnRHcm91cCwgc2VnbWVudHMsIG91dGxldCkge1xuICAgICAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGNvbmZpZ18xID0gX192YWx1ZXMoY29uZmlnKSwgY29uZmlnXzFfMSA9IGNvbmZpZ18xLm5leHQoKTsgIWNvbmZpZ18xXzEuZG9uZTsgY29uZmlnXzFfMSA9IGNvbmZpZ18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGNvbmZpZ18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzU2VnbWVudEFnYWluc3RSb3V0ZShyLCBzZWdtZW50R3JvdXAsIHNlZ21lbnRzLCBvdXRsZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgTm9NYXRjaCQxKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maWdfMV8xICYmICFjb25maWdfMV8xLmRvbmUgJiYgKF9hID0gY29uZmlnXzEucmV0dXJuKSkgX2EuY2FsbChjb25maWdfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm5vTGVmdG92ZXJzSW5Vcmwoc2VnbWVudEdyb3VwLCBzZWdtZW50cywgb3V0bGV0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb01hdGNoJDEoKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVjb2duaXplci5wcm90b3R5cGUubm9MZWZ0b3ZlcnNJblVybCA9IGZ1bmN0aW9uIChzZWdtZW50R3JvdXAsIHNlZ21lbnRzLCBvdXRsZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWdtZW50cy5sZW5ndGggPT09IDAgJiYgIXNlZ21lbnRHcm91cC5jaGlsZHJlbltvdXRsZXRdO1xuICAgICAgICB9O1xuICAgICAgICBSZWNvZ25pemVyLnByb3RvdHlwZS5wcm9jZXNzU2VnbWVudEFnYWluc3RSb3V0ZSA9IGZ1bmN0aW9uIChyb3V0ZSwgcmF3U2VnbWVudCwgc2VnbWVudHMsIG91dGxldCkge1xuICAgICAgICAgICAgaWYgKHJvdXRlLnJlZGlyZWN0VG8pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vTWF0Y2gkMSgpO1xuICAgICAgICAgICAgaWYgKChyb3V0ZS5vdXRsZXQgfHwgUFJJTUFSWV9PVVRMRVQpICE9PSBvdXRsZXQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vTWF0Y2gkMSgpO1xuICAgICAgICAgICAgdmFyIHNuYXBzaG90O1xuICAgICAgICAgICAgdmFyIGNvbnN1bWVkU2VnbWVudHMgPSBbXTtcbiAgICAgICAgICAgIHZhciByYXdTbGljZWRTZWdtZW50cyA9IFtdO1xuICAgICAgICAgICAgaWYgKHJvdXRlLnBhdGggPT09ICcqKicpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gc2VnbWVudHMubGVuZ3RoID4gMCA/IGxhc3Qoc2VnbWVudHMpLnBhcmFtZXRlcnMgOiB7fTtcbiAgICAgICAgICAgICAgICBzbmFwc2hvdCA9IG5ldyBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90KHNlZ21lbnRzLCBwYXJhbXMsIE9iamVjdC5mcmVlemUoX19hc3NpZ24kMSh7fSwgdGhpcy51cmxUcmVlLnF1ZXJ5UGFyYW1zKSksIHRoaXMudXJsVHJlZS5mcmFnbWVudCwgZ2V0RGF0YShyb3V0ZSksIG91dGxldCwgcm91dGUuY29tcG9uZW50LCByb3V0ZSwgZ2V0U291cmNlU2VnbWVudEdyb3VwKHJhd1NlZ21lbnQpLCBnZXRQYXRoSW5kZXhTaGlmdChyYXdTZWdtZW50KSArIHNlZ21lbnRzLmxlbmd0aCwgZ2V0UmVzb2x2ZShyb3V0ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1hdGNoJDEocmF3U2VnbWVudCwgcm91dGUsIHNlZ21lbnRzKTtcbiAgICAgICAgICAgICAgICBjb25zdW1lZFNlZ21lbnRzID0gcmVzdWx0LmNvbnN1bWVkU2VnbWVudHM7XG4gICAgICAgICAgICAgICAgcmF3U2xpY2VkU2VnbWVudHMgPSBzZWdtZW50cy5zbGljZShyZXN1bHQubGFzdENoaWxkKTtcbiAgICAgICAgICAgICAgICBzbmFwc2hvdCA9IG5ldyBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90KGNvbnN1bWVkU2VnbWVudHMsIHJlc3VsdC5wYXJhbWV0ZXJzLCBPYmplY3QuZnJlZXplKF9fYXNzaWduJDEoe30sIHRoaXMudXJsVHJlZS5xdWVyeVBhcmFtcykpLCB0aGlzLnVybFRyZWUuZnJhZ21lbnQsIGdldERhdGEocm91dGUpLCBvdXRsZXQsIHJvdXRlLmNvbXBvbmVudCwgcm91dGUsIGdldFNvdXJjZVNlZ21lbnRHcm91cChyYXdTZWdtZW50KSwgZ2V0UGF0aEluZGV4U2hpZnQocmF3U2VnbWVudCkgKyBjb25zdW1lZFNlZ21lbnRzLmxlbmd0aCwgZ2V0UmVzb2x2ZShyb3V0ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoaWxkQ29uZmlnID0gZ2V0Q2hpbGRDb25maWcocm91dGUpO1xuICAgICAgICAgICAgdmFyIF9hID0gc3BsaXQkMShyYXdTZWdtZW50LCBjb25zdW1lZFNlZ21lbnRzLCByYXdTbGljZWRTZWdtZW50cywgY2hpbGRDb25maWcsIHRoaXMucmVsYXRpdmVMaW5rUmVzb2x1dGlvbiksIHNlZ21lbnRHcm91cCA9IF9hLnNlZ21lbnRHcm91cCwgc2xpY2VkU2VnbWVudHMgPSBfYS5zbGljZWRTZWdtZW50cztcbiAgICAgICAgICAgIGlmIChzbGljZWRTZWdtZW50cy5sZW5ndGggPT09IDAgJiYgc2VnbWVudEdyb3VwLmhhc0NoaWxkcmVuKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW5fMSA9IHRoaXMucHJvY2Vzc0NoaWxkcmVuKGNoaWxkQ29uZmlnLCBzZWdtZW50R3JvdXApO1xuICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IFRyZWVOb2RlKHNuYXBzaG90LCBjaGlsZHJlbl8xKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hpbGRDb25maWcubGVuZ3RoID09PSAwICYmIHNsaWNlZFNlZ21lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IFRyZWVOb2RlKHNuYXBzaG90LCBbXSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcm9jZXNzU2VnbWVudChjaGlsZENvbmZpZywgc2VnbWVudEdyb3VwLCBzbGljZWRTZWdtZW50cywgUFJJTUFSWV9PVVRMRVQpO1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgVHJlZU5vZGUoc25hcHNob3QsIGNoaWxkcmVuKV07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSZWNvZ25pemVyO1xuICAgIH0oKSk7XG4gICAgZnVuY3Rpb24gc29ydEFjdGl2YXRlZFJvdXRlU25hcHNob3RzKG5vZGVzKSB7XG4gICAgICAgIG5vZGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIGlmIChhLnZhbHVlLm91dGxldCA9PT0gUFJJTUFSWV9PVVRMRVQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgaWYgKGIudmFsdWUub3V0bGV0ID09PSBQUklNQVJZX09VVExFVClcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIHJldHVybiBhLnZhbHVlLm91dGxldC5sb2NhbGVDb21wYXJlKGIudmFsdWUub3V0bGV0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENoaWxkQ29uZmlnKHJvdXRlKSB7XG4gICAgICAgIGlmIChyb3V0ZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgcmV0dXJuIHJvdXRlLmNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3V0ZS5sb2FkQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHJldHVybiByb3V0ZS5fbG9hZGVkQ29uZmlnLnJvdXRlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hdGNoJDEoc2VnbWVudEdyb3VwLCByb3V0ZSwgc2VnbWVudHMpIHtcbiAgICAgICAgaWYgKHJvdXRlLnBhdGggPT09ICcnKSB7XG4gICAgICAgICAgICBpZiAocm91dGUucGF0aE1hdGNoID09PSAnZnVsbCcgJiYgKHNlZ21lbnRHcm91cC5oYXNDaGlsZHJlbigpIHx8IHNlZ21lbnRzLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vTWF0Y2gkMSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgY29uc3VtZWRTZWdtZW50czogW10sIGxhc3RDaGlsZDogMCwgcGFyYW1ldGVyczoge30gfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF0Y2hlciA9IHJvdXRlLm1hdGNoZXIgfHwgZGVmYXVsdFVybE1hdGNoZXI7XG4gICAgICAgIHZhciByZXMgPSBtYXRjaGVyKHNlZ21lbnRzLCBzZWdtZW50R3JvdXAsIHJvdXRlKTtcbiAgICAgICAgaWYgKCFyZXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm9NYXRjaCQxKCk7XG4gICAgICAgIHZhciBwb3NQYXJhbXMgPSB7fTtcbiAgICAgICAgZm9yRWFjaChyZXMucG9zUGFyYW1zLCBmdW5jdGlvbiAodiwgaykgeyBwb3NQYXJhbXNba10gPSB2LnBhdGg7IH0pO1xuICAgICAgICB2YXIgcGFyYW1ldGVycyA9IHJlcy5jb25zdW1lZC5sZW5ndGggPiAwID8gX19hc3NpZ24kMSh7fSwgcG9zUGFyYW1zLCByZXMuY29uc3VtZWRbcmVzLmNvbnN1bWVkLmxlbmd0aCAtIDFdLnBhcmFtZXRlcnMpIDpcbiAgICAgICAgICAgIHBvc1BhcmFtcztcbiAgICAgICAgcmV0dXJuIHsgY29uc3VtZWRTZWdtZW50czogcmVzLmNvbnN1bWVkLCBsYXN0Q2hpbGQ6IHJlcy5jb25zdW1lZC5sZW5ndGgsIHBhcmFtZXRlcnM6IHBhcmFtZXRlcnMgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tPdXRsZXROYW1lVW5pcXVlbmVzcyhub2Rlcykge1xuICAgICAgICB2YXIgbmFtZXMgPSB7fTtcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgdmFyIHJvdXRlV2l0aFNhbWVPdXRsZXROYW1lID0gbmFtZXNbbi52YWx1ZS5vdXRsZXRdO1xuICAgICAgICAgICAgaWYgKHJvdXRlV2l0aFNhbWVPdXRsZXROYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSByb3V0ZVdpdGhTYW1lT3V0bGV0TmFtZS51cmwubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnRvU3RyaW5nKCk7IH0pLmpvaW4oJy8nKTtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IG4udmFsdWUudXJsLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gcy50b1N0cmluZygpOyB9KS5qb2luKCcvJyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHdvIHNlZ21lbnRzIGNhbm5vdCBoYXZlIHRoZSBzYW1lIG91dGxldCBuYW1lOiAnXCIgKyBwICsgXCInIGFuZCAnXCIgKyBjICsgXCInLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5hbWVzW24udmFsdWUub3V0bGV0XSA9IG4udmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTb3VyY2VTZWdtZW50R3JvdXAoc2VnbWVudEdyb3VwKSB7XG4gICAgICAgIHZhciBzID0gc2VnbWVudEdyb3VwO1xuICAgICAgICB3aGlsZSAocy5fc291cmNlU2VnbWVudCkge1xuICAgICAgICAgICAgcyA9IHMuX3NvdXJjZVNlZ21lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFBhdGhJbmRleFNoaWZ0KHNlZ21lbnRHcm91cCkge1xuICAgICAgICB2YXIgcyA9IHNlZ21lbnRHcm91cDtcbiAgICAgICAgdmFyIHJlcyA9IChzLl9zZWdtZW50SW5kZXhTaGlmdCA/IHMuX3NlZ21lbnRJbmRleFNoaWZ0IDogMCk7XG4gICAgICAgIHdoaWxlIChzLl9zb3VyY2VTZWdtZW50KSB7XG4gICAgICAgICAgICBzID0gcy5fc291cmNlU2VnbWVudDtcbiAgICAgICAgICAgIHJlcyArPSAocy5fc2VnbWVudEluZGV4U2hpZnQgPyBzLl9zZWdtZW50SW5kZXhTaGlmdCA6IDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXMgLSAxO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzcGxpdCQxKHNlZ21lbnRHcm91cCwgY29uc3VtZWRTZWdtZW50cywgc2xpY2VkU2VnbWVudHMsIGNvbmZpZywgcmVsYXRpdmVMaW5rUmVzb2x1dGlvbikge1xuICAgICAgICBpZiAoc2xpY2VkU2VnbWVudHMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgY29udGFpbnNFbXB0eVBhdGhNYXRjaGVzV2l0aE5hbWVkT3V0bGV0cyhzZWdtZW50R3JvdXAsIHNsaWNlZFNlZ21lbnRzLCBjb25maWcpKSB7XG4gICAgICAgICAgICB2YXIgc18xID0gbmV3IFVybFNlZ21lbnRHcm91cChjb25zdW1lZFNlZ21lbnRzLCBjcmVhdGVDaGlsZHJlbkZvckVtcHR5UGF0aHMoc2VnbWVudEdyb3VwLCBjb25zdW1lZFNlZ21lbnRzLCBjb25maWcsIG5ldyBVcmxTZWdtZW50R3JvdXAoc2xpY2VkU2VnbWVudHMsIHNlZ21lbnRHcm91cC5jaGlsZHJlbikpKTtcbiAgICAgICAgICAgIHNfMS5fc291cmNlU2VnbWVudCA9IHNlZ21lbnRHcm91cDtcbiAgICAgICAgICAgIHNfMS5fc2VnbWVudEluZGV4U2hpZnQgPSBjb25zdW1lZFNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiB7IHNlZ21lbnRHcm91cDogc18xLCBzbGljZWRTZWdtZW50czogW10gfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2xpY2VkU2VnbWVudHMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICBjb250YWluc0VtcHR5UGF0aE1hdGNoZXMoc2VnbWVudEdyb3VwLCBzbGljZWRTZWdtZW50cywgY29uZmlnKSkge1xuICAgICAgICAgICAgdmFyIHNfMiA9IG5ldyBVcmxTZWdtZW50R3JvdXAoc2VnbWVudEdyb3VwLnNlZ21lbnRzLCBhZGRFbXB0eVBhdGhzVG9DaGlsZHJlbklmTmVlZGVkKHNlZ21lbnRHcm91cCwgY29uc3VtZWRTZWdtZW50cywgc2xpY2VkU2VnbWVudHMsIGNvbmZpZywgc2VnbWVudEdyb3VwLmNoaWxkcmVuLCByZWxhdGl2ZUxpbmtSZXNvbHV0aW9uKSk7XG4gICAgICAgICAgICBzXzIuX3NvdXJjZVNlZ21lbnQgPSBzZWdtZW50R3JvdXA7XG4gICAgICAgICAgICBzXzIuX3NlZ21lbnRJbmRleFNoaWZ0ID0gY29uc3VtZWRTZWdtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4geyBzZWdtZW50R3JvdXA6IHNfMiwgc2xpY2VkU2VnbWVudHM6IHNsaWNlZFNlZ21lbnRzIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHMgPSBuZXcgVXJsU2VnbWVudEdyb3VwKHNlZ21lbnRHcm91cC5zZWdtZW50cywgc2VnbWVudEdyb3VwLmNoaWxkcmVuKTtcbiAgICAgICAgcy5fc291cmNlU2VnbWVudCA9IHNlZ21lbnRHcm91cDtcbiAgICAgICAgcy5fc2VnbWVudEluZGV4U2hpZnQgPSBjb25zdW1lZFNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHsgc2VnbWVudEdyb3VwOiBzLCBzbGljZWRTZWdtZW50czogc2xpY2VkU2VnbWVudHMgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkRW1wdHlQYXRoc1RvQ2hpbGRyZW5JZk5lZWRlZChzZWdtZW50R3JvdXAsIGNvbnN1bWVkU2VnbWVudHMsIHNsaWNlZFNlZ21lbnRzLCByb3V0ZXMsIGNoaWxkcmVuLCByZWxhdGl2ZUxpbmtSZXNvbHV0aW9uKSB7XG4gICAgICAgIHZhciBlXzIsIF9hO1xuICAgICAgICB2YXIgcmVzID0ge307XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciByb3V0ZXNfMSA9IF9fdmFsdWVzKHJvdXRlcyksIHJvdXRlc18xXzEgPSByb3V0ZXNfMS5uZXh0KCk7ICFyb3V0ZXNfMV8xLmRvbmU7IHJvdXRlc18xXzEgPSByb3V0ZXNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IHJvdXRlc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGVtcHR5UGF0aE1hdGNoKHNlZ21lbnRHcm91cCwgc2xpY2VkU2VnbWVudHMsIHIpICYmICFjaGlsZHJlbltnZXRPdXRsZXQkMShyKV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBuZXcgVXJsU2VnbWVudEdyb3VwKFtdLCB7fSk7XG4gICAgICAgICAgICAgICAgICAgIHMuX3NvdXJjZVNlZ21lbnQgPSBzZWdtZW50R3JvdXA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWxhdGl2ZUxpbmtSZXNvbHV0aW9uID09PSAnbGVnYWN5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcy5fc2VnbWVudEluZGV4U2hpZnQgPSBzZWdtZW50R3JvdXAuc2VnbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcy5fc2VnbWVudEluZGV4U2hpZnQgPSBjb25zdW1lZFNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNbZ2V0T3V0bGV0JDEocildID0gcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChyb3V0ZXNfMV8xICYmICFyb3V0ZXNfMV8xLmRvbmUgJiYgKF9hID0gcm91dGVzXzEucmV0dXJuKSkgX2EuY2FsbChyb3V0ZXNfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9fYXNzaWduJDEoe30sIGNoaWxkcmVuLCByZXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVDaGlsZHJlbkZvckVtcHR5UGF0aHMoc2VnbWVudEdyb3VwLCBjb25zdW1lZFNlZ21lbnRzLCByb3V0ZXMsIHByaW1hcnlTZWdtZW50KSB7XG4gICAgICAgIHZhciBlXzMsIF9hO1xuICAgICAgICB2YXIgcmVzID0ge307XG4gICAgICAgIHJlc1tQUklNQVJZX09VVExFVF0gPSBwcmltYXJ5U2VnbWVudDtcbiAgICAgICAgcHJpbWFyeVNlZ21lbnQuX3NvdXJjZVNlZ21lbnQgPSBzZWdtZW50R3JvdXA7XG4gICAgICAgIHByaW1hcnlTZWdtZW50Ll9zZWdtZW50SW5kZXhTaGlmdCA9IGNvbnN1bWVkU2VnbWVudHMubGVuZ3RoO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgcm91dGVzXzIgPSBfX3ZhbHVlcyhyb3V0ZXMpLCByb3V0ZXNfMl8xID0gcm91dGVzXzIubmV4dCgpOyAhcm91dGVzXzJfMS5kb25lOyByb3V0ZXNfMl8xID0gcm91dGVzXzIubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSByb3V0ZXNfMl8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChyLnBhdGggPT09ICcnICYmIGdldE91dGxldCQxKHIpICE9PSBQUklNQVJZX09VVExFVCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IG5ldyBVcmxTZWdtZW50R3JvdXAoW10sIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgcy5fc291cmNlU2VnbWVudCA9IHNlZ21lbnRHcm91cDtcbiAgICAgICAgICAgICAgICAgICAgcy5fc2VnbWVudEluZGV4U2hpZnQgPSBjb25zdW1lZFNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcmVzW2dldE91dGxldCQxKHIpXSA9IHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAocm91dGVzXzJfMSAmJiAhcm91dGVzXzJfMS5kb25lICYmIChfYSA9IHJvdXRlc18yLnJldHVybikpIF9hLmNhbGwocm91dGVzXzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnRhaW5zRW1wdHlQYXRoTWF0Y2hlc1dpdGhOYW1lZE91dGxldHMoc2VnbWVudEdyb3VwLCBzbGljZWRTZWdtZW50cywgcm91dGVzKSB7XG4gICAgICAgIHJldHVybiByb3V0ZXMuc29tZShmdW5jdGlvbiAocikgeyByZXR1cm4gZW1wdHlQYXRoTWF0Y2goc2VnbWVudEdyb3VwLCBzbGljZWRTZWdtZW50cywgcikgJiYgZ2V0T3V0bGV0JDEocikgIT09IFBSSU1BUllfT1VUTEVUOyB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udGFpbnNFbXB0eVBhdGhNYXRjaGVzKHNlZ21lbnRHcm91cCwgc2xpY2VkU2VnbWVudHMsIHJvdXRlcykge1xuICAgICAgICByZXR1cm4gcm91dGVzLnNvbWUoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIGVtcHR5UGF0aE1hdGNoKHNlZ21lbnRHcm91cCwgc2xpY2VkU2VnbWVudHMsIHIpOyB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW1wdHlQYXRoTWF0Y2goc2VnbWVudEdyb3VwLCBzbGljZWRTZWdtZW50cywgcikge1xuICAgICAgICBpZiAoKHNlZ21lbnRHcm91cC5oYXNDaGlsZHJlbigpIHx8IHNsaWNlZFNlZ21lbnRzLmxlbmd0aCA+IDApICYmIHIucGF0aE1hdGNoID09PSAnZnVsbCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gci5wYXRoID09PSAnJyAmJiByLnJlZGlyZWN0VG8gPT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0T3V0bGV0JDEocm91dGUpIHtcbiAgICAgICAgcmV0dXJuIHJvdXRlLm91dGxldCB8fCBQUklNQVJZX09VVExFVDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0RGF0YShyb3V0ZSkge1xuICAgICAgICByZXR1cm4gcm91dGUuZGF0YSB8fCB7fTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0UmVzb2x2ZShyb3V0ZSkge1xuICAgICAgICByZXR1cm4gcm91dGUucmVzb2x2ZSB8fCB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVjb2duaXplJDEocm9vdENvbXBvbmVudFR5cGUsIGNvbmZpZywgc2VyaWFsaXplciwgcGFyYW1zSW5oZXJpdGFuY2VTdHJhdGVneSwgcmVsYXRpdmVMaW5rUmVzb2x1dGlvbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5waXBlKG9wZXJhdG9ycy5tZXJnZU1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gcmVjb2duaXplKHJvb3RDb21wb25lbnRUeXBlLCBjb25maWcsIHQudXJsQWZ0ZXJSZWRpcmVjdHMsIHNlcmlhbGl6ZXIodC51cmxBZnRlclJlZGlyZWN0cyksIHBhcmFtc0luaGVyaXRhbmNlU3RyYXRlZ3ksIHJlbGF0aXZlTGlua1Jlc29sdXRpb24pXG4gICAgICAgICAgICAgICAgLnBpcGUob3BlcmF0b3JzLm1hcChmdW5jdGlvbiAodGFyZ2V0U25hcHNob3QpIHsgcmV0dXJuIChfX2Fzc2lnbiQxKHt9LCB0LCB7IHRhcmdldFNuYXBzaG90OiB0YXJnZXRTbmFwc2hvdCB9KSk7IH0pKTsgfSkpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXNvbHZlRGF0YShwYXJhbXNJbmhlcml0YW5jZVN0cmF0ZWd5LCBtb2R1bGVJbmplY3Rvcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5waXBlKG9wZXJhdG9ycy5tZXJnZU1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRTbmFwc2hvdCA9IHQudGFyZ2V0U25hcHNob3QsIGNhbkFjdGl2YXRlQ2hlY2tzID0gdC5ndWFyZHMuY2FuQWN0aXZhdGVDaGVja3M7XG4gICAgICAgICAgICAgICAgaWYgKCFjYW5BY3RpdmF0ZUNoZWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ4anMub2YodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByeGpzLmZyb20oY2FuQWN0aXZhdGVDaGVja3MpXG4gICAgICAgICAgICAgICAgICAgIC5waXBlKG9wZXJhdG9ycy5jb25jYXRNYXAoZnVuY3Rpb24gKGNoZWNrKSB7IHJldHVybiBydW5SZXNvbHZlKGNoZWNrLnJvdXRlLCB0YXJnZXRTbmFwc2hvdCwgcGFyYW1zSW5oZXJpdGFuY2VTdHJhdGVneSwgbW9kdWxlSW5qZWN0b3IpOyB9KSwgb3BlcmF0b3JzLnJlZHVjZShmdW5jdGlvbiAoXywgX18pIHsgcmV0dXJuIF87IH0pLCBvcGVyYXRvcnMubWFwKGZ1bmN0aW9uIChfKSB7IHJldHVybiB0OyB9KSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJ1blJlc29sdmUoZnV0dXJlQVJTLCBmdXR1cmVSU1MsIHBhcmFtc0luaGVyaXRhbmNlU3RyYXRlZ3ksIG1vZHVsZUluamVjdG9yKSB7XG4gICAgICAgIHZhciByZXNvbHZlID0gZnV0dXJlQVJTLl9yZXNvbHZlO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZU5vZGUocmVzb2x2ZSwgZnV0dXJlQVJTLCBmdXR1cmVSU1MsIG1vZHVsZUluamVjdG9yKVxuICAgICAgICAgICAgLnBpcGUob3BlcmF0b3JzLm1hcChmdW5jdGlvbiAocmVzb2x2ZWREYXRhKSB7XG4gICAgICAgICAgICBmdXR1cmVBUlMuX3Jlc29sdmVkRGF0YSA9IHJlc29sdmVkRGF0YTtcbiAgICAgICAgICAgIGZ1dHVyZUFSUy5kYXRhID0gX19hc3NpZ24kMSh7fSwgZnV0dXJlQVJTLmRhdGEsIGluaGVyaXRlZFBhcmFtc0RhdGFSZXNvbHZlKGZ1dHVyZUFSUywgcGFyYW1zSW5oZXJpdGFuY2VTdHJhdGVneSkucmVzb2x2ZSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlTm9kZShyZXNvbHZlLCBmdXR1cmVBUlMsIGZ1dHVyZVJTUywgbW9kdWxlSW5qZWN0b3IpIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZXNvbHZlKTtcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcnhqcy5vZih7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB2YXIga2V5XzEgPSBrZXlzWzBdO1xuICAgICAgICAgICAgcmV0dXJuIGdldFJlc29sdmVyKHJlc29sdmVba2V5XzFdLCBmdXR1cmVBUlMsIGZ1dHVyZVJTUywgbW9kdWxlSW5qZWN0b3IpXG4gICAgICAgICAgICAgICAgLnBpcGUob3BlcmF0b3JzLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9hID0ge30sIF9hW2tleV8xXSA9IHZhbHVlLCBfYTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICB2YXIgcnVubmluZ1Jlc29sdmVycyQgPSByeGpzLmZyb20oa2V5cykucGlwZShvcGVyYXRvcnMubWVyZ2VNYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFJlc29sdmVyKHJlc29sdmVba2V5XSwgZnV0dXJlQVJTLCBmdXR1cmVSU1MsIG1vZHVsZUluamVjdG9yKVxuICAgICAgICAgICAgICAgIC5waXBlKG9wZXJhdG9ycy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBydW5uaW5nUmVzb2x2ZXJzJC5waXBlKG9wZXJhdG9ycy5sYXN0KCksIG9wZXJhdG9ycy5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gZGF0YTsgfSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRSZXNvbHZlcihpbmplY3Rpb25Ub2tlbiwgZnV0dXJlQVJTLCBmdXR1cmVSU1MsIG1vZHVsZUluamVjdG9yKSB7XG4gICAgICAgIHZhciByZXNvbHZlciA9IGdldFRva2VuKGluamVjdGlvblRva2VuLCBmdXR1cmVBUlMsIG1vZHVsZUluamVjdG9yKTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVyLnJlc29sdmUgPyB3cmFwSW50b09ic2VydmFibGUocmVzb2x2ZXIucmVzb2x2ZShmdXR1cmVBUlMsIGZ1dHVyZVJTUykpIDpcbiAgICAgICAgICAgIHdyYXBJbnRvT2JzZXJ2YWJsZShyZXNvbHZlcihmdXR1cmVBUlMsIGZ1dHVyZVJTUykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgc2lkZSBlZmZlY3QgdGhyb3VnaCBhIHN3aXRjaE1hcCBmb3IgZXZlcnkgZW1pc3Npb24gb24gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLFxuICAgICAqIGJ1dCByZXR1cm4gYW4gT2JzZXJ2YWJsZSB0aGF0IGlzIGlkZW50aWNhbCB0byB0aGUgc291cmNlLiBJdCdzIGVzc2VudGlhbGx5IHRoZSBzYW1lIGFzXG4gICAgICogdGhlIGB0YXBgIG9wZXJhdG9yLCBidXQgaWYgdGhlIHNpZGUgZWZmZWN0ZnVsIGBuZXh0YCBmdW5jdGlvbiByZXR1cm5zIGFuIE9ic2VydmFibGVJbnB1dCxcbiAgICAgKiBpdCB3aWxsIHdhaXQgYmVmb3JlIGNvbnRpbnVpbmcgd2l0aCB0aGUgb3JpZ2luYWwgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3dpdGNoVGFwKG5leHQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2UucGlwZShvcGVyYXRvcnMuc3dpdGNoTWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRSZXN1bHQgPSBuZXh0KHYpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0UmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByeGpzLmZyb20obmV4dFJlc3VsdCkucGlwZShvcGVyYXRvcnMubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHY7IH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ4anMuZnJvbShbdl0pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFByb3ZpZGVzIGEgd2F5IHRvIGN1c3RvbWl6ZSB3aGVuIGFjdGl2YXRlZCByb3V0ZXMgZ2V0IHJldXNlZC5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgUm91dGVSZXVzZVN0cmF0ZWd5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSb3V0ZVJldXNlU3RyYXRlZ3koKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJvdXRlUmV1c2VTdHJhdGVneTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIERvZXMgbm90IGRldGFjaCBhbnkgc3VidHJlZXMuIFJldXNlcyByb3V0ZXMgYXMgbG9uZyBhcyB0aGVpciByb3V0ZSBjb25maWcgaXMgdGhlIHNhbWUuXG4gICAgICovXG4gICAgdmFyIERlZmF1bHRSb3V0ZVJldXNlU3RyYXRlZ3kgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIERlZmF1bHRSb3V0ZVJldXNlU3RyYXRlZ3koKSB7XG4gICAgICAgIH1cbiAgICAgICAgRGVmYXVsdFJvdXRlUmV1c2VTdHJhdGVneS5wcm90b3R5cGUuc2hvdWxkRGV0YWNoID0gZnVuY3Rpb24gKHJvdXRlKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICAgICAgRGVmYXVsdFJvdXRlUmV1c2VTdHJhdGVneS5wcm90b3R5cGUuc3RvcmUgPSBmdW5jdGlvbiAocm91dGUsIGRldGFjaGVkVHJlZSkgeyB9O1xuICAgICAgICBEZWZhdWx0Um91dGVSZXVzZVN0cmF0ZWd5LnByb3RvdHlwZS5zaG91bGRBdHRhY2ggPSBmdW5jdGlvbiAocm91dGUpIHsgcmV0dXJuIGZhbHNlOyB9O1xuICAgICAgICBEZWZhdWx0Um91dGVSZXVzZVN0cmF0ZWd5LnByb3RvdHlwZS5yZXRyaWV2ZSA9IGZ1bmN0aW9uIChyb3V0ZSkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgICAgRGVmYXVsdFJvdXRlUmV1c2VTdHJhdGVneS5wcm90b3R5cGUuc2hvdWxkUmV1c2VSb3V0ZSA9IGZ1bmN0aW9uIChmdXR1cmUsIGN1cnIpIHtcbiAgICAgICAgICAgIHJldHVybiBmdXR1cmUucm91dGVDb25maWcgPT09IGN1cnIucm91dGVDb25maWc7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBEZWZhdWx0Um91dGVSZXVzZVN0cmF0ZWd5O1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGRvY3NOb3RSZXF1aXJlZFxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgUk9VVEVTID0gbmV3IGNvcmUuSW5qZWN0aW9uVG9rZW4oJ1JPVVRFUycpO1xuICAgIHZhciBSb3V0ZXJDb25maWdMb2FkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJvdXRlckNvbmZpZ0xvYWRlcihsb2FkZXIsIGNvbXBpbGVyLCBvbkxvYWRTdGFydExpc3RlbmVyLCBvbkxvYWRFbmRMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBsb2FkZXI7XG4gICAgICAgICAgICB0aGlzLmNvbXBpbGVyID0gY29tcGlsZXI7XG4gICAgICAgICAgICB0aGlzLm9uTG9hZFN0YXJ0TGlzdGVuZXIgPSBvbkxvYWRTdGFydExpc3RlbmVyO1xuICAgICAgICAgICAgdGhpcy5vbkxvYWRFbmRMaXN0ZW5lciA9IG9uTG9hZEVuZExpc3RlbmVyO1xuICAgICAgICB9XG4gICAgICAgIFJvdXRlckNvbmZpZ0xvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChwYXJlbnRJbmplY3Rvciwgcm91dGUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodGhpcy5vbkxvYWRTdGFydExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkxvYWRTdGFydExpc3RlbmVyKHJvdXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtb2R1bGVGYWN0b3J5JCA9IHRoaXMubG9hZE1vZHVsZUZhY3Rvcnkocm91dGUubG9hZENoaWxkcmVuKTtcbiAgICAgICAgICAgIHJldHVybiBtb2R1bGVGYWN0b3J5JC5waXBlKG9wZXJhdG9ycy5tYXAoZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMub25Mb2FkRW5kTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25Mb2FkRW5kTGlzdGVuZXIocm91dGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbW9kdWxlID0gZmFjdG9yeS5jcmVhdGUocGFyZW50SW5qZWN0b3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTG9hZGVkUm91dGVyQ29uZmlnKGZsYXR0ZW4obW9kdWxlLmluamVjdG9yLmdldChST1VURVMpKS5tYXAoc3RhbmRhcmRpemVDb25maWcpLCBtb2R1bGUpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICBSb3V0ZXJDb25maWdMb2FkZXIucHJvdG90eXBlLmxvYWRNb2R1bGVGYWN0b3J5ID0gZnVuY3Rpb24gKGxvYWRDaGlsZHJlbikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbG9hZENoaWxkcmVuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiByeGpzLmZyb20odGhpcy5sb2FkZXIubG9hZChsb2FkQ2hpbGRyZW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwSW50b09ic2VydmFibGUobG9hZENoaWxkcmVuKCkpLnBpcGUob3BlcmF0b3JzLm1lcmdlTWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0IGluc3RhbmNlb2YgY29yZS5OZ01vZHVsZUZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByeGpzLm9mKHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ4anMuZnJvbShfdGhpcy5jb21waWxlci5jb21waWxlTW9kdWxlQXN5bmModCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUm91dGVyQ29uZmlnTG9hZGVyO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBQcm92aWRlcyBhIHdheSB0byBtaWdyYXRlIEFuZ3VsYXJKUyBhcHBsaWNhdGlvbnMgdG8gQW5ndWxhci5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgVXJsSGFuZGxpbmdTdHJhdGVneSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVXJsSGFuZGxpbmdTdHJhdGVneSgpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVXJsSGFuZGxpbmdTdHJhdGVneTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgRGVmYXVsdFVybEhhbmRsaW5nU3RyYXRlZ3kgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIERlZmF1bHRVcmxIYW5kbGluZ1N0cmF0ZWd5KCkge1xuICAgICAgICB9XG4gICAgICAgIERlZmF1bHRVcmxIYW5kbGluZ1N0cmF0ZWd5LnByb3RvdHlwZS5zaG91bGRQcm9jZXNzVXJsID0gZnVuY3Rpb24gKHVybCkgeyByZXR1cm4gdHJ1ZTsgfTtcbiAgICAgICAgRGVmYXVsdFVybEhhbmRsaW5nU3RyYXRlZ3kucHJvdG90eXBlLmV4dHJhY3QgPSBmdW5jdGlvbiAodXJsKSB7IHJldHVybiB1cmw7IH07XG4gICAgICAgIERlZmF1bHRVcmxIYW5kbGluZ1N0cmF0ZWd5LnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChuZXdVcmxQYXJ0LCB3aG9sZVVybCkgeyByZXR1cm4gbmV3VXJsUGFydDsgfTtcbiAgICAgICAgcmV0dXJuIERlZmF1bHRVcmxIYW5kbGluZ1N0cmF0ZWd5O1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVmYXVsdEVycm9ySGFuZGxlcihlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdE1hbGZvcm1lZFVyaUVycm9ySGFuZGxlcihlcnJvciwgdXJsU2VyaWFsaXplciwgdXJsKSB7XG4gICAgICAgIHJldHVybiB1cmxTZXJpYWxpemVyLnBhcnNlKCcvJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZmF1bHRSb3V0ZXJIb29rKHNuYXBzaG90LCBydW5FeHRyYXMpIHtcbiAgICAgICAgcmV0dXJuIHJ4anMub2YobnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogQW4gTmdNb2R1bGUgdGhhdCBwcm92aWRlcyBuYXZpZ2F0aW9uIGFuZCBVUkwgbWFuaXB1bGF0aW9uIGNhcGFiaWxpdGllcy5cbiAgICAgKlxuICAgICAqIEBzZWUgYFJvdXRlYC5cbiAgICAgKiBAc2VlIFtSb3V0aW5nIGFuZCBOYXZpZ2F0aW9uIEd1aWRlXShndWlkZS9yb3V0ZXIpLlxuICAgICAqXG4gICAgICogQG5nTW9kdWxlIFJvdXRlck1vZHVsZVxuICAgICAqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBSb3V0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIHRoZSByb3V0ZXIgc2VydmljZS5cbiAgICAgICAgICovXG4gICAgICAgIC8vIFRPRE86IHZzYXZraW4gbWFrZSBpbnRlcm5hbCBhZnRlciB0aGUgZmluYWwgaXMgb3V0LlxuICAgICAgICBmdW5jdGlvbiBSb3V0ZXIocm9vdENvbXBvbmVudFR5cGUsIHVybFNlcmlhbGl6ZXIsIHJvb3RDb250ZXh0cywgbG9jYXRpb24sIGluamVjdG9yLCBsb2FkZXIsIGNvbXBpbGVyLCBjb25maWcpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLnJvb3RDb21wb25lbnRUeXBlID0gcm9vdENvbXBvbmVudFR5cGU7XG4gICAgICAgICAgICB0aGlzLnVybFNlcmlhbGl6ZXIgPSB1cmxTZXJpYWxpemVyO1xuICAgICAgICAgICAgdGhpcy5yb290Q29udGV4dHMgPSByb290Q29udGV4dHM7XG4gICAgICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgICAgIHRoaXMubGFzdFN1Y2Nlc3NmdWxOYXZpZ2F0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE5hdmlnYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uSWQgPSAwO1xuICAgICAgICAgICAgdGhpcy5pc05nWm9uZUVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQW4gZXZlbnQgc3RyZWFtIGZvciByb3V0aW5nIGV2ZW50cyBpbiB0aGlzIE5nTW9kdWxlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmV2ZW50cyA9IG5ldyByeGpzLlN1YmplY3QoKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBoYW5kbGVyIGZvciBuYXZpZ2F0aW9uIGVycm9ycyBpbiB0aGlzIE5nTW9kdWxlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmVycm9ySGFuZGxlciA9IGRlZmF1bHRFcnJvckhhbmRsZXI7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE1hbGZvcm1lZCB1cmkgZXJyb3IgaGFuZGxlciBpcyBpbnZva2VkIHdoZW4gYFJvdXRlci5wYXJzZVVybCh1cmwpYCB0aHJvd3MgYW5cbiAgICAgICAgICAgICAqIGVycm9yIGR1ZSB0byBjb250YWluaW5nIGFuIGludmFsaWQgY2hhcmFjdGVyLiBUaGUgbW9zdCBjb21tb24gY2FzZSB3b3VsZCBiZSBhIGAlYCBzaWduXG4gICAgICAgICAgICAgKiB0aGF0J3Mgbm90IGVuY29kZWQgYW5kIGlzIG5vdCBwYXJ0IG9mIGEgcGVyY2VudCBlbmNvZGVkIHNlcXVlbmNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm1hbGZvcm1lZFVyaUVycm9ySGFuZGxlciA9IGRlZmF1bHRNYWxmb3JtZWRVcmlFcnJvckhhbmRsZXI7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRydWUgaWYgYXQgbGVhc3Qgb25lIG5hdmlnYXRpb24gZXZlbnQgaGFzIG9jY3VycmVkLFxuICAgICAgICAgICAgICogZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5sYXN0U3VjY2Vzc2Z1bElkID0gLTE7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEhvb2tzIHRoYXQgZW5hYmxlIHlvdSB0byBwYXVzZSBuYXZpZ2F0aW9uLFxuICAgICAgICAgICAgICogZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgcHJlYWN0aXZhdGlvbiBwaGFzZS5cbiAgICAgICAgICAgICAqIFVzZWQgYnkgYFJvdXRlck1vZHVsZWAuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaG9va3MgPSB7XG4gICAgICAgICAgICAgICAgYmVmb3JlUHJlYWN0aXZhdGlvbjogZGVmYXVsdFJvdXRlckhvb2ssXG4gICAgICAgICAgICAgICAgYWZ0ZXJQcmVhY3RpdmF0aW9uOiBkZWZhdWx0Um91dGVySG9va1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRXh0cmFjdHMgYW5kIG1lcmdlcyBVUkxzLiBVc2VkIGZvciBBbmd1bGFySlMgdG8gQW5ndWxhciBtaWdyYXRpb25zLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnVybEhhbmRsaW5nU3RyYXRlZ3kgPSBuZXcgRGVmYXVsdFVybEhhbmRsaW5nU3RyYXRlZ3koKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHN0cmF0ZWd5IGZvciByZS11c2luZyByb3V0ZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucm91dGVSZXVzZVN0cmF0ZWd5ID0gbmV3IERlZmF1bHRSb3V0ZVJldXNlU3RyYXRlZ3koKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSG93IHRvIGhhbmRsZSBhIG5hdmlnYXRpb24gcmVxdWVzdCB0byB0aGUgY3VycmVudCBVUkwuIE9uZSBvZjpcbiAgICAgICAgICAgICAqIC0gYCdpZ25vcmUnYCA6ICBUaGUgcm91dGVyIGlnbm9yZXMgdGhlIHJlcXVlc3QuXG4gICAgICAgICAgICAgKiAtIGAncmVsb2FkJ2AgOiBUaGUgcm91dGVyIHJlbG9hZHMgdGhlIFVSTC4gVXNlIHRvIGltcGxlbWVudCBhIFwicmVmcmVzaFwiIGZlYXR1cmUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMub25TYW1lVXJsTmF2aWdhdGlvbiA9ICdpZ25vcmUnO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBIb3cgdG8gbWVyZ2UgcGFyYW1ldGVycywgZGF0YSwgYW5kIHJlc29sdmVkIGRhdGEgZnJvbSBwYXJlbnQgdG8gY2hpbGRcbiAgICAgICAgICAgICAqIHJvdXRlcy4gT25lIG9mOlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIC0gYCdlbXB0eU9ubHknYCA6IEluaGVyaXQgcGFyZW50IHBhcmFtZXRlcnMsIGRhdGEsIGFuZCByZXNvbHZlZCBkYXRhXG4gICAgICAgICAgICAgKiBmb3IgcGF0aC1sZXNzIG9yIGNvbXBvbmVudC1sZXNzIHJvdXRlcy5cbiAgICAgICAgICAgICAqIC0gYCdhbHdheXMnYCA6IEluaGVyaXQgcGFyZW50IHBhcmFtZXRlcnMsIGRhdGEsIGFuZCByZXNvbHZlZCBkYXRhXG4gICAgICAgICAgICAgKiBmb3IgYWxsIGNoaWxkIHJvdXRlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wYXJhbXNJbmhlcml0YW5jZVN0cmF0ZWd5ID0gJ2VtcHR5T25seSc7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERlZmluZXMgd2hlbiB0aGUgcm91dGVyIHVwZGF0ZXMgdGhlIGJyb3dzZXIgVVJMLiBUaGUgZGVmYXVsdCBiZWhhdmlvciBpcyB0byB1cGRhdGUgYWZ0ZXJcbiAgICAgICAgICAgICAqIHN1Y2Nlc3NmdWwgbmF2aWdhdGlvbi4gSG93ZXZlciwgc29tZSBhcHBsaWNhdGlvbnMgbWF5IHByZWZlciBhIG1vZGUgd2hlcmUgdGhlIFVSTCBnZXRzXG4gICAgICAgICAgICAgKiB1cGRhdGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgbmF2aWdhdGlvbi4gVGhlIG1vc3QgY29tbW9uIHVzZSBjYXNlIHdvdWxkIGJlIHVwZGF0aW5nIHRoZVxuICAgICAgICAgICAgICogVVJMIGVhcmx5IHNvIGlmIG5hdmlnYXRpb24gZmFpbHMsIHlvdSBjYW4gc2hvdyBhbiBlcnJvciBtZXNzYWdlIHdpdGggdGhlIFVSTCB0aGF0IGZhaWxlZC5cbiAgICAgICAgICAgICAqIEF2YWlsYWJsZSBvcHRpb25zIGFyZTpcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAtIGAnZGVmZXJyZWQnYCwgdGhlIGRlZmF1bHQsIHVwZGF0ZXMgdGhlIGJyb3dzZXIgVVJMIGFmdGVyIG5hdmlnYXRpb24gaGFzIGZpbmlzaGVkLlxuICAgICAgICAgICAgICogLSBgJ2VhZ2VyJ2AsIHVwZGF0ZXMgYnJvd3NlciBVUkwgYXQgdGhlIGJlZ2lubmluZyBvZiBuYXZpZ2F0aW9uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnVybFVwZGF0ZVN0cmF0ZWd5ID0gJ2RlZmVycmVkJztcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2VlIHtAbGluayBSb3V0ZXJNb2R1bGV9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnJlbGF0aXZlTGlua1Jlc29sdXRpb24gPSAnbGVnYWN5JztcbiAgICAgICAgICAgIHZhciBvbkxvYWRTdGFydCA9IGZ1bmN0aW9uIChyKSB7IHJldHVybiBfdGhpcy50cmlnZ2VyRXZlbnQobmV3IFJvdXRlQ29uZmlnTG9hZFN0YXJ0KHIpKTsgfTtcbiAgICAgICAgICAgIHZhciBvbkxvYWRFbmQgPSBmdW5jdGlvbiAocikgeyByZXR1cm4gX3RoaXMudHJpZ2dlckV2ZW50KG5ldyBSb3V0ZUNvbmZpZ0xvYWRFbmQocikpOyB9O1xuICAgICAgICAgICAgdGhpcy5uZ01vZHVsZSA9IGluamVjdG9yLmdldChjb3JlLk5nTW9kdWxlUmVmKTtcbiAgICAgICAgICAgIHRoaXMuY29uc29sZSA9IGluamVjdG9yLmdldChjb3JlLsm1Q29uc29sZSk7XG4gICAgICAgICAgICB2YXIgbmdab25lID0gaW5qZWN0b3IuZ2V0KGNvcmUuTmdab25lKTtcbiAgICAgICAgICAgIHRoaXMuaXNOZ1pvbmVFbmFibGVkID0gbmdab25lIGluc3RhbmNlb2YgY29yZS5OZ1pvbmU7XG4gICAgICAgICAgICB0aGlzLnJlc2V0Q29uZmlnKGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRVcmxUcmVlID0gY3JlYXRlRW1wdHlVcmxUcmVlKCk7XG4gICAgICAgICAgICB0aGlzLnJhd1VybFRyZWUgPSB0aGlzLmN1cnJlbnRVcmxUcmVlO1xuICAgICAgICAgICAgdGhpcy5icm93c2VyVXJsVHJlZSA9IHRoaXMuY3VycmVudFVybFRyZWU7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ0xvYWRlciA9IG5ldyBSb3V0ZXJDb25maWdMb2FkZXIobG9hZGVyLCBjb21waWxlciwgb25Mb2FkU3RhcnQsIG9uTG9hZEVuZCk7XG4gICAgICAgICAgICB0aGlzLnJvdXRlclN0YXRlID0gY3JlYXRlRW1wdHlTdGF0ZSh0aGlzLmN1cnJlbnRVcmxUcmVlLCB0aGlzLnJvb3RDb21wb25lbnRUeXBlKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbnMgPSBuZXcgcnhqcy5CZWhhdmlvclN1YmplY3Qoe1xuICAgICAgICAgICAgICAgIGlkOiAwLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRVcmxUcmVlOiB0aGlzLmN1cnJlbnRVcmxUcmVlLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRSYXdVcmw6IHRoaXMuY3VycmVudFVybFRyZWUsXG4gICAgICAgICAgICAgICAgZXh0cmFjdGVkVXJsOiB0aGlzLnVybEhhbmRsaW5nU3RyYXRlZ3kuZXh0cmFjdCh0aGlzLmN1cnJlbnRVcmxUcmVlKSxcbiAgICAgICAgICAgICAgICB1cmxBZnRlclJlZGlyZWN0czogdGhpcy51cmxIYW5kbGluZ1N0cmF0ZWd5LmV4dHJhY3QodGhpcy5jdXJyZW50VXJsVHJlZSksXG4gICAgICAgICAgICAgICAgcmF3VXJsOiB0aGlzLmN1cnJlbnRVcmxUcmVlLFxuICAgICAgICAgICAgICAgIGV4dHJhczoge30sXG4gICAgICAgICAgICAgICAgcmVzb2x2ZTogbnVsbCxcbiAgICAgICAgICAgICAgICByZWplY3Q6IG51bGwsXG4gICAgICAgICAgICAgICAgcHJvbWlzZTogUHJvbWlzZS5yZXNvbHZlKHRydWUpLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogJ2ltcGVyYXRpdmUnLFxuICAgICAgICAgICAgICAgIHJlc3RvcmVkU3RhdGU6IG51bGwsXG4gICAgICAgICAgICAgICAgY3VycmVudFNuYXBzaG90OiB0aGlzLnJvdXRlclN0YXRlLnNuYXBzaG90LFxuICAgICAgICAgICAgICAgIHRhcmdldFNuYXBzaG90OiBudWxsLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRSb3V0ZXJTdGF0ZTogdGhpcy5yb3V0ZXJTdGF0ZSxcbiAgICAgICAgICAgICAgICB0YXJnZXRSb3V0ZXJTdGF0ZTogbnVsbCxcbiAgICAgICAgICAgICAgICBndWFyZHM6IHsgY2FuQWN0aXZhdGVDaGVja3M6IFtdLCBjYW5EZWFjdGl2YXRlQ2hlY2tzOiBbXSB9LFxuICAgICAgICAgICAgICAgIGd1YXJkc1Jlc3VsdDogbnVsbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9ucyA9IHRoaXMuc2V0dXBOYXZpZ2F0aW9ucyh0aGlzLnRyYW5zaXRpb25zKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc05hdmlnYXRpb25zKCk7XG4gICAgICAgIH1cbiAgICAgICAgUm91dGVyLnByb3RvdHlwZS5zZXR1cE5hdmlnYXRpb25zID0gZnVuY3Rpb24gKHRyYW5zaXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGV2ZW50c1N1YmplY3QgPSB0aGlzLmV2ZW50cztcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2l0aW9ucy5waXBlKG9wZXJhdG9ycy5maWx0ZXIoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuaWQgIT09IDA7IH0pLCBcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgVVJMXG4gICAgICAgICAgICBvcGVyYXRvcnMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiAoX19hc3NpZ24kMSh7fSwgdCwgeyBleHRyYWN0ZWRVcmw6IF90aGlzLnVybEhhbmRsaW5nU3RyYXRlZ3kuZXh0cmFjdCh0LnJhd1VybCkgfSkpOyB9KSwgXG4gICAgICAgICAgICAvLyBVc2luZyBzd2l0Y2hNYXAgc28gd2UgY2FuY2VsIGV4ZWN1dGluZyBuYXZpZ2F0aW9ucyB3aGVuIGEgbmV3IG9uZSBjb21lcyBpblxuICAgICAgICAgICAgb3BlcmF0b3JzLnN3aXRjaE1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHZhciBjb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiByeGpzLm9mKHQpLnBpcGUoXG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIE5hdmlnYXRpb24gb2JqZWN0XG4gICAgICAgICAgICAgICAgb3BlcmF0b3JzLnRhcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50TmF2aWdhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFVybDogdC5jdXJyZW50UmF3VXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdGVkVXJsOiB0LmV4dHJhY3RlZFVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZXI6IHQuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFzOiB0LmV4dHJhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzTmF2aWdhdGlvbjogX3RoaXMubGFzdFN1Y2Nlc3NmdWxOYXZpZ2F0aW9uID8gX19hc3NpZ24kMSh7fSwgX3RoaXMubGFzdFN1Y2Nlc3NmdWxOYXZpZ2F0aW9uLCB7IHByZXZpb3VzTmF2aWdhdGlvbjogbnVsbCB9KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pLCBvcGVyYXRvcnMuc3dpdGNoTWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1cmxUcmFuc2l0aW9uID0gIV90aGlzLm5hdmlnYXRlZCB8fCB0LmV4dHJhY3RlZFVybC50b1N0cmluZygpICE9PSBfdGhpcy5icm93c2VyVXJsVHJlZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvY2Vzc0N1cnJlbnRVcmwgPSAoX3RoaXMub25TYW1lVXJsTmF2aWdhdGlvbiA9PT0gJ3JlbG9hZCcgPyB0cnVlIDogdXJsVHJhbnNpdGlvbikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnVybEhhbmRsaW5nU3RyYXRlZ3kuc2hvdWxkUHJvY2Vzc1VybCh0LnJhd1VybCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzQ3VycmVudFVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ4anMub2YodCkucGlwZShcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcmUgTmF2aWdhdGlvblN0YXJ0IGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcnMuc3dpdGNoTWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zaXRpb24gPSBfdGhpcy50cmFuc2l0aW9ucy5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50c1N1YmplY3QubmV4dChuZXcgTmF2aWdhdGlvblN0YXJ0KHQuaWQsIF90aGlzLnNlcmlhbGl6ZVVybCh0LmV4dHJhY3RlZFVybCksIHQuc291cmNlLCB0LnJlc3RvcmVkU3RhdGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNpdGlvbiAhPT0gX3RoaXMudHJhbnNpdGlvbnMuZ2V0VmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnhqcy5FTVBUWTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZGVsYXkgaXMgcmVxdWlyZWQgdG8gbWF0Y2ggb2xkIGJlaGF2aW9yIHRoYXQgZm9yY2VkIG5hdmlnYXRpb24gdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsd2F5cyBiZSBhc3luY1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3JzLnN3aXRjaE1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHQpOyB9KSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseVJlZGlyZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlSZWRpcmVjdHMkMShfdGhpcy5uZ01vZHVsZS5pbmplY3RvciwgX3RoaXMuY29uZmlnTG9hZGVyLCBfdGhpcy51cmxTZXJpYWxpemVyLCBfdGhpcy5jb25maWcpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgY3VycmVudE5hdmlnYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9ycy50YXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50TmF2aWdhdGlvbiA9IF9fYXNzaWduJDEoe30sIF90aGlzLmN1cnJlbnROYXZpZ2F0aW9uLCB7IGZpbmFsVXJsOiB0LnVybEFmdGVyUmVkaXJlY3RzIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVjb2duaXplXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvZ25pemUkMShfdGhpcy5yb290Q29tcG9uZW50VHlwZSwgX3RoaXMuY29uZmlnLCBmdW5jdGlvbiAodXJsKSB7IHJldHVybiBfdGhpcy5zZXJpYWxpemVVcmwodXJsKTsgfSwgX3RoaXMucGFyYW1zSW5oZXJpdGFuY2VTdHJhdGVneSwgX3RoaXMucmVsYXRpdmVMaW5rUmVzb2x1dGlvbiksIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIFVSTCBpZiBpbiBgZWFnZXJgIHVwZGF0ZSBtb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcnMudGFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnVybFVwZGF0ZVN0cmF0ZWd5ID09PSAnZWFnZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdC5leHRyYXMuc2tpcExvY2F0aW9uQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRCcm93c2VyVXJsKHQudXJsQWZ0ZXJSZWRpcmVjdHMsICEhdC5leHRyYXMucmVwbGFjZVVybCwgdC5pZCwgdC5leHRyYXMuc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmJyb3dzZXJVcmxUcmVlID0gdC51cmxBZnRlclJlZGlyZWN0cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJlIFJvdXRlc1JlY29nbml6ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9ycy50YXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm91dGVzUmVjb2duaXplZCA9IG5ldyBSb3V0ZXNSZWNvZ25pemVkKHQuaWQsIF90aGlzLnNlcmlhbGl6ZVVybCh0LmV4dHJhY3RlZFVybCksIF90aGlzLnNlcmlhbGl6ZVVybCh0LnVybEFmdGVyUmVkaXJlY3RzKSwgdC50YXJnZXRTbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzU3ViamVjdC5uZXh0KHJvdXRlc1JlY29nbml6ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb2Nlc3NQcmV2aW91c1VybCA9IHVybFRyYW5zaXRpb24gJiYgX3RoaXMucmF3VXJsVHJlZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnVybEhhbmRsaW5nU3RyYXRlZ3kuc2hvdWxkUHJvY2Vzc1VybChfdGhpcy5yYXdVcmxUcmVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIFdoZW4gdGhlIGN1cnJlbnQgVVJMIHNob3VsZG4ndCBiZSBwcm9jZXNzZWQsIGJ1dCB0aGUgcHJldmlvdXMgb25lIHdhcywgd2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGhhbmRsZSB0aGlzIFwiZXJyb3IgY29uZGl0aW9uXCIgYnkgbmF2aWdhdGluZyB0byB0aGUgcHJldmlvdXNseSBzdWNjZXNzZnVsIFVSTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGJ1dCBsZWF2aW5nIHRoZSBVUkwgaW50YWN0LiovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc1ByZXZpb3VzVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gdC5pZCwgZXh0cmFjdGVkVXJsID0gdC5leHRyYWN0ZWRVcmwsIHNvdXJjZSA9IHQuc291cmNlLCByZXN0b3JlZFN0YXRlID0gdC5yZXN0b3JlZFN0YXRlLCBleHRyYXMgPSB0LmV4dHJhcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmF2U3RhcnQgPSBuZXcgTmF2aWdhdGlvblN0YXJ0KGlkLCBfdGhpcy5zZXJpYWxpemVVcmwoZXh0cmFjdGVkVXJsKSwgc291cmNlLCByZXN0b3JlZFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHNTdWJqZWN0Lm5leHQobmF2U3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRTbmFwc2hvdCA9IGNyZWF0ZUVtcHR5U3RhdGUoZXh0cmFjdGVkVXJsLCBfdGhpcy5yb290Q29tcG9uZW50VHlwZSkuc25hcHNob3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ4anMub2YoX19hc3NpZ24kMSh7fSwgdCwgeyB0YXJnZXRTbmFwc2hvdDogdGFyZ2V0U25hcHNob3QsIHVybEFmdGVyUmVkaXJlY3RzOiBleHRyYWN0ZWRVcmwsIGV4dHJhczogX19hc3NpZ24kMSh7fSwgZXh0cmFzLCB7IHNraXBMb2NhdGlvbkNoYW5nZTogZmFsc2UsIHJlcGxhY2VVcmw6IGZhbHNlIH0pIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIFdoZW4gbmVpdGhlciB0aGUgY3VycmVudCBvciBwcmV2aW91cyBVUkwgY2FuIGJlIHByb2Nlc3NlZCwgZG8gbm90aGluZyBvdGhlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHRoYW4gdXBkYXRlIHJvdXRlcidzIGludGVybmFsIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBcInNldHRsZWRcIiBVUkwuIFRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB3YXkgdGhlIG5leHQgbmF2aWdhdGlvbiB3aWxsIGJlIGNvbWluZyBmcm9tIHRoZSBjdXJyZW50IFVSTCBpbiB0aGUgYnJvd3Nlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yYXdVcmxUcmVlID0gdC5yYXdVcmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYnJvd3NlclVybFRyZWUgPSB0LnVybEFmdGVyUmVkaXJlY3RzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQucmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnhqcy5FTVBUWTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLCBcbiAgICAgICAgICAgICAgICAvLyBCZWZvcmUgUHJlYWN0aXZhdGlvblxuICAgICAgICAgICAgICAgIHN3aXRjaFRhcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0U25hcHNob3QgPSB0LnRhcmdldFNuYXBzaG90LCBuYXZpZ2F0aW9uSWQgPSB0LmlkLCBhcHBsaWVkVXJsVHJlZSA9IHQuZXh0cmFjdGVkVXJsLCByYXdVcmxUcmVlID0gdC5yYXdVcmwsIF9hID0gdC5leHRyYXMsIHNraXBMb2NhdGlvbkNoYW5nZSA9IF9hLnNraXBMb2NhdGlvbkNoYW5nZSwgcmVwbGFjZVVybCA9IF9hLnJlcGxhY2VVcmw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5ob29rcy5iZWZvcmVQcmVhY3RpdmF0aW9uKHRhcmdldFNuYXBzaG90LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uSWQ6IG5hdmlnYXRpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpZWRVcmxUcmVlOiBhcHBsaWVkVXJsVHJlZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd1VybFRyZWU6IHJhd1VybFRyZWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwTG9jYXRpb25DaGFuZ2U6ICEhc2tpcExvY2F0aW9uQ2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZVVybDogISFyZXBsYWNlVXJsLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSwgXG4gICAgICAgICAgICAgICAgLy8gLS0tIEdVQVJEUyAtLS1cbiAgICAgICAgICAgICAgICBvcGVyYXRvcnMudGFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBndWFyZHNTdGFydCA9IG5ldyBHdWFyZHNDaGVja1N0YXJ0KHQuaWQsIF90aGlzLnNlcmlhbGl6ZVVybCh0LmV4dHJhY3RlZFVybCksIF90aGlzLnNlcmlhbGl6ZVVybCh0LnVybEFmdGVyUmVkaXJlY3RzKSwgdC50YXJnZXRTbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRyaWdnZXJFdmVudChndWFyZHNTdGFydCk7XG4gICAgICAgICAgICAgICAgfSksIG9wZXJhdG9ycy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIChfX2Fzc2lnbiQxKHt9LCB0LCB7IGd1YXJkczogZ2V0QWxsUm91dGVHdWFyZHModC50YXJnZXRTbmFwc2hvdCwgdC5jdXJyZW50U25hcHNob3QsIF90aGlzLnJvb3RDb250ZXh0cykgfSkpOyB9KSwgY2hlY2tHdWFyZHMoX3RoaXMubmdNb2R1bGUuaW5qZWN0b3IsIGZ1bmN0aW9uIChldnQpIHsgcmV0dXJuIF90aGlzLnRyaWdnZXJFdmVudChldnQpOyB9KSwgb3BlcmF0b3JzLnRhcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNVcmxUcmVlKHQuZ3VhcmRzUmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gbmF2aWdhdGlvbkNhbmNlbGluZ0Vycm9yKFwiUmVkaXJlY3RpbmcgdG8gXFxcIlwiICsgX3RoaXMuc2VyaWFsaXplVXJsKHQuZ3VhcmRzUmVzdWx0KSArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLnVybCA9IHQuZ3VhcmRzUmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSwgb3BlcmF0b3JzLnRhcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ3VhcmRzRW5kID0gbmV3IEd1YXJkc0NoZWNrRW5kKHQuaWQsIF90aGlzLnNlcmlhbGl6ZVVybCh0LmV4dHJhY3RlZFVybCksIF90aGlzLnNlcmlhbGl6ZVVybCh0LnVybEFmdGVyUmVkaXJlY3RzKSwgdC50YXJnZXRTbmFwc2hvdCwgISF0Lmd1YXJkc1Jlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRyaWdnZXJFdmVudChndWFyZHNFbmQpO1xuICAgICAgICAgICAgICAgIH0pLCBvcGVyYXRvcnMuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdC5ndWFyZHNSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc2V0VXJsVG9DdXJyZW50VXJsVHJlZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hdkNhbmNlbCA9IG5ldyBOYXZpZ2F0aW9uQ2FuY2VsKHQuaWQsIF90aGlzLnNlcmlhbGl6ZVVybCh0LmV4dHJhY3RlZFVybCksICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50c1N1YmplY3QubmV4dChuYXZDYW5jZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdC5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KSwgXG4gICAgICAgICAgICAgICAgLy8gLS0tIFJFU09MVkUgLS0tXG4gICAgICAgICAgICAgICAgc3dpdGNoVGFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0Lmd1YXJkcy5jYW5BY3RpdmF0ZUNoZWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByeGpzLm9mKHQpLnBpcGUob3BlcmF0b3JzLnRhcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNvbHZlU3RhcnQgPSBuZXcgUmVzb2x2ZVN0YXJ0KHQuaWQsIF90aGlzLnNlcmlhbGl6ZVVybCh0LmV4dHJhY3RlZFVybCksIF90aGlzLnNlcmlhbGl6ZVVybCh0LnVybEFmdGVyUmVkaXJlY3RzKSwgdC50YXJnZXRTbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudHJpZ2dlckV2ZW50KHJlc29sdmVTdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgcmVzb2x2ZURhdGEoX3RoaXMucGFyYW1zSW5oZXJpdGFuY2VTdHJhdGVneSwgX3RoaXMubmdNb2R1bGUuaW5qZWN0b3IpLCAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3JzLnRhcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNvbHZlRW5kID0gbmV3IFJlc29sdmVFbmQodC5pZCwgX3RoaXMuc2VyaWFsaXplVXJsKHQuZXh0cmFjdGVkVXJsKSwgX3RoaXMuc2VyaWFsaXplVXJsKHQudXJsQWZ0ZXJSZWRpcmVjdHMpLCB0LnRhcmdldFNuYXBzaG90KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy50cmlnZ2VyRXZlbnQocmVzb2x2ZUVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9KSwgXG4gICAgICAgICAgICAgICAgLy8gLS0tIEFGVEVSIFBSRUFDVElWQVRJT04gLS0tXG4gICAgICAgICAgICAgICAgc3dpdGNoVGFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRTbmFwc2hvdCA9IHQudGFyZ2V0U25hcHNob3QsIG5hdmlnYXRpb25JZCA9IHQuaWQsIGFwcGxpZWRVcmxUcmVlID0gdC5leHRyYWN0ZWRVcmwsIHJhd1VybFRyZWUgPSB0LnJhd1VybCwgX2EgPSB0LmV4dHJhcywgc2tpcExvY2F0aW9uQ2hhbmdlID0gX2Euc2tpcExvY2F0aW9uQ2hhbmdlLCByZXBsYWNlVXJsID0gX2EucmVwbGFjZVVybDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmhvb2tzLmFmdGVyUHJlYWN0aXZhdGlvbih0YXJnZXRTbmFwc2hvdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGlvbklkOiBuYXZpZ2F0aW9uSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBsaWVkVXJsVHJlZTogYXBwbGllZFVybFRyZWUsXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdVcmxUcmVlOiByYXdVcmxUcmVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcExvY2F0aW9uQ2hhbmdlOiAhIXNraXBMb2NhdGlvbkNoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VVcmw6ICEhcmVwbGFjZVVybCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSksIG9wZXJhdG9ycy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldFJvdXRlclN0YXRlID0gY3JlYXRlUm91dGVyU3RhdGUoX3RoaXMucm91dGVSZXVzZVN0cmF0ZWd5LCB0LnRhcmdldFNuYXBzaG90LCB0LmN1cnJlbnRSb3V0ZXJTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoX19hc3NpZ24kMSh7fSwgdCwgeyB0YXJnZXRSb3V0ZXJTdGF0ZTogdGFyZ2V0Um91dGVyU3RhdGUgfSkpO1xuICAgICAgICAgICAgICAgIH0pLCBcbiAgICAgICAgICAgICAgICAvKiBPbmNlIGhlcmUsIHdlIGFyZSBhYm91dCB0byBhY3RpdmF0ZSBzeW5jcm9ub3VzbHkuIFRoZSBhc3N1bXB0aW9uIGlzIHRoaXMgd2lsbFxuICAgICAgICAgICAgICAgICAgIHN1Y2NlZWQsIGFuZCB1c2VyIGNvZGUgbWF5IHJlYWQgZnJvbSB0aGUgUm91dGVyIHNlcnZpY2UuIFRoZXJlZm9yZSBiZWZvcmVcbiAgICAgICAgICAgICAgICAgICBhY3RpdmF0aW9uLCB3ZSBuZWVkIHRvIHVwZGF0ZSByb3V0ZXIgcHJvcGVydGllcyBzdG9yaW5nIHRoZSBjdXJyZW50IFVSTCBhbmQgdGhlXG4gICAgICAgICAgICAgICAgICAgUm91dGVyU3RhdGUsIGFzIHdlbGwgYXMgdXBkYXRlZCB0aGUgYnJvd3NlciBVUkwuIEFsbCB0aGlzIHNob3VsZCBoYXBwZW4gKmJlZm9yZSpcbiAgICAgICAgICAgICAgICAgICBhY3RpdmF0aW5nLiAqL1xuICAgICAgICAgICAgICAgIG9wZXJhdG9ycy50YXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY3VycmVudFVybFRyZWUgPSB0LnVybEFmdGVyUmVkaXJlY3RzO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yYXdVcmxUcmVlID0gX3RoaXMudXJsSGFuZGxpbmdTdHJhdGVneS5tZXJnZShfdGhpcy5jdXJyZW50VXJsVHJlZSwgdC5yYXdVcmwpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yb3V0ZXJTdGF0ZSA9IHQudGFyZ2V0Um91dGVyU3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy51cmxVcGRhdGVTdHJhdGVneSA9PT0gJ2RlZmVycmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0LmV4dHJhcy5za2lwTG9jYXRpb25DaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRCcm93c2VyVXJsKF90aGlzLnJhd1VybFRyZWUsICEhdC5leHRyYXMucmVwbGFjZVVybCwgdC5pZCwgdC5leHRyYXMuc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYnJvd3NlclVybFRyZWUgPSB0LnVybEFmdGVyUmVkaXJlY3RzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksIGFjdGl2YXRlUm91dGVzKF90aGlzLnJvb3RDb250ZXh0cywgX3RoaXMucm91dGVSZXVzZVN0cmF0ZWd5LCBmdW5jdGlvbiAoZXZ0KSB7IHJldHVybiBfdGhpcy50cmlnZ2VyRXZlbnQoZXZ0KTsgfSksIG9wZXJhdG9ycy50YXAoeyBuZXh0OiBmdW5jdGlvbiAoKSB7IGNvbXBsZXRlZCA9IHRydWU7IH0sIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7IGNvbXBsZXRlZCA9IHRydWU7IH0gfSksIG9wZXJhdG9ycy5maW5hbGl6ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIFdoZW4gdGhlIG5hdmlnYXRpb24gc3RyZWFtIGZpbmlzaGVzIGVpdGhlciB0aHJvdWdoIGVycm9yIG9yIHN1Y2Nlc3MsIHdlIHNldCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICogYGNvbXBsZXRlZGAgb3IgYGVycm9yZWRgIGZsYWcuIEhvd2V2ZXIsIHRoZXJlIGFyZSBzb21lIHNpdHVhdGlvbnMgd2hlcmUgd2UgY291bGRcbiAgICAgICAgICAgICAgICAgICAgICogZ2V0IGhlcmUgd2l0aG91dCBlaXRoZXIgb2YgdGhvc2UgYmVpbmcgc2V0LiBGb3IgaW5zdGFuY2UsIGEgcmVkaXJlY3QgZHVyaW5nXG4gICAgICAgICAgICAgICAgICAgICAqIE5hdmlnYXRpb25TdGFydC4gVGhlcmVmb3JlLCB0aGlzIGlzIGEgY2F0Y2gtYWxsIHRvIG1ha2Ugc3VyZSB0aGUgTmF2aWdhdGlvbkNhbmNlbFxuICAgICAgICAgICAgICAgICAgICAgKiBldmVudCBpcyBmaXJlZCB3aGVuIGEgbmF2aWdhdGlvbiBnZXRzIGNhbmNlbGxlZCBidXQgbm90IGNhdWdodCBieSBvdGhlciBtZWFucy4gKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wbGV0ZWQgJiYgIWVycm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE11c3QgcmVzZXQgdG8gY3VycmVudCBVUkwgdHJlZSBoZXJlIHRvIGVuc3VyZSBoaXN0b3J5LnN0YXRlIGlzIHNldC4gT24gYSBmcmVzaFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFnZSBsb2FkLCBpZiBhIG5ldyBuYXZpZ2F0aW9uIGNvbWVzIGluIGJlZm9yZSBhIHN1Y2Nlc3NmdWwgbmF2aWdhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tcGxldGVzLCB0aGVyZSB3aWxsIGJlIG5vdGhpbmcgaW4gaGlzdG9yeS5zdGF0ZS5uYXZpZ2F0aW9uSWQuIFRoaXMgY2FuIGNhdXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzeW5jIHByb2JsZW1zIHdpdGggQW5ndWxhckpTIHN5bmMgY29kZSB3aGljaCBsb29rcyBmb3IgYSB2YWx1ZSBoZXJlIGluIG9yZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgdG8gaGFuZGxlIGEgZ2l2ZW4gcG9wc3RhdGUgZXZlbnQgb3IgdG8gbGVhdmUgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBBbmd1YWxyIHJvdXRlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc2V0VXJsVG9DdXJyZW50VXJsVHJlZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hdkNhbmNlbCA9IG5ldyBOYXZpZ2F0aW9uQ2FuY2VsKHQuaWQsIF90aGlzLnNlcmlhbGl6ZVVybCh0LmV4dHJhY3RlZFVybCksIFwiTmF2aWdhdGlvbiBJRCBcIiArIHQuaWQgKyBcIiBpcyBub3QgZXF1YWwgdG8gdGhlIGN1cnJlbnQgbmF2aWdhdGlvbiBpZCBcIiArIF90aGlzLm5hdmlnYXRpb25JZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudHNTdWJqZWN0Lm5leHQobmF2Q2FuY2VsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudE5hdmlnYXRpb24gc2hvdWxkIGFsd2F5cyBiZSByZXNldCB0byBudWxsIGhlcmUuIElmIG5hdmlnYXRpb24gd2FzXG4gICAgICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3NmdWwsIGxhc3RTdWNjZXNzZnVsVHJhbnNpdGlvbiB3aWxsIGhhdmUgYWxyZWFkeSBiZWVuIHNldC4gVGhlcmVmb3JlIHdlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbiBzYWZlbHkgc2V0IGN1cnJlbnROYXZpZ2F0aW9uIHRvIG51bGwgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY3VycmVudE5hdmlnYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIH0pLCBvcGVyYXRvcnMuY2F0Y2hFcnJvcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLyogVGhpcyBlcnJvciB0eXBlIGlzIGlzc3VlZCBkdXJpbmcgUmVkaXJlY3QsIGFuZCBpcyBoYW5kbGVkIGFzIGEgY2FuY2VsbGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAqIHJhdGhlciB0aGFuIGFuIGVycm9yLiAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYXZpZ2F0aW9uQ2FuY2VsaW5nRXJyb3IoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWRpcmVjdGluZyA9IGlzVXJsVHJlZShlLnVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlZGlyZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHByb3BlcnR5IG9ubHkgaWYgd2UncmUgbm90IHJlZGlyZWN0aW5nLiBJZiB3ZSBsYW5kZWQgb24gYSBwYWdlIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlZGlyZWN0IHRvIGAvYCByb3V0ZSwgdGhlIG5ldyBuYXZpZ2F0aW9uIGlzIGdvaW5nIHRvIHNlZSB0aGUgYC9gIGlzbid0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBjaGFuZ2UgZnJvbSB0aGUgZGVmYXVsdCBjdXJyZW50VXJsVHJlZSBhbmQgd29uJ3QgbmF2aWdhdGUuIFRoaXMgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGFwcGxpY2FibGUgd2l0aCBpbml0aWFsIG5hdmlnYXRpb24sIHNvIHNldHRpbmcgYG5hdmlnYXRlZGAgb25seSB3aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90IHJlZGlyZWN0aW5nIHJlc29sdmVzIHRoaXMgc2NlbmFyaW8uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubmF2aWdhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXNldFN0YXRlQW5kVXJsKHQuY3VycmVudFJvdXRlclN0YXRlLCB0LmN1cnJlbnRVcmxUcmVlLCB0LnJhd1VybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmF2Q2FuY2VsID0gbmV3IE5hdmlnYXRpb25DYW5jZWwodC5pZCwgX3RoaXMuc2VyaWFsaXplVXJsKHQuZXh0cmFjdGVkVXJsKSwgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50c1N1YmplY3QubmV4dChuYXZDYW5jZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdC5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWRpcmVjdGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm5hdmlnYXRlQnlVcmwoZS51cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLyogQWxsIG90aGVyIGVycm9ycyBzaG91bGQgcmVzZXQgdG8gdGhlIHJvdXRlcidzIGludGVybmFsIFVSTCByZWZlcmVuY2UgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBwcmUtZXJyb3Igc3RhdGUuICovXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXNldFN0YXRlQW5kVXJsKHQuY3VycmVudFJvdXRlclN0YXRlLCB0LmN1cnJlbnRVcmxUcmVlLCB0LnJhd1VybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmF2RXJyb3IgPSBuZXcgTmF2aWdhdGlvbkVycm9yKHQuaWQsIF90aGlzLnNlcmlhbGl6ZVVybCh0LmV4dHJhY3RlZFVybCksIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzU3ViamVjdC5uZXh0KG5hdkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5yZXNvbHZlKF90aGlzLmVycm9ySGFuZGxlcihlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LnJlamVjdChlZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ4anMuRU1QVFk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE8oamFzb25hZGVuKTogcmVtb3ZlIGNhc3Qgb25jZSBnMyBpcyBvbiB1cGRhdGVkIFR5cGVTY3JpcHRcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKiBUT0RPOiB0aGlzIHNob3VsZCBiZSByZW1vdmVkIG9uY2UgdGhlIGNvbnN0cnVjdG9yIG9mIHRoZSByb3V0ZXIgbWFkZSBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgUm91dGVyLnByb3RvdHlwZS5yZXNldFJvb3RDb21wb25lbnRUeXBlID0gZnVuY3Rpb24gKHJvb3RDb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3RDb21wb25lbnRUeXBlID0gcm9vdENvbXBvbmVudFR5cGU7XG4gICAgICAgICAgICAvLyBUT0RPOiB2c2F2a2luIHJvdXRlciA0LjAgc2hvdWxkIG1ha2UgdGhlIHJvb3QgY29tcG9uZW50IHNldCB0byBudWxsXG4gICAgICAgICAgICAvLyB0aGlzIHdpbGwgc2ltcGxpZnkgdGhlIGxpZmVjeWNsZSBvZiB0aGUgcm91dGVyLlxuICAgICAgICAgICAgdGhpcy5yb3V0ZXJTdGF0ZS5yb290LmNvbXBvbmVudCA9IHRoaXMucm9vdENvbXBvbmVudFR5cGU7XG4gICAgICAgIH07XG4gICAgICAgIFJvdXRlci5wcm90b3R5cGUuZ2V0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uID0gdGhpcy50cmFuc2l0aW9ucy52YWx1ZTtcbiAgICAgICAgICAgIC8vIFRoaXMgdmFsdWUgbmVlZHMgdG8gYmUgc2V0LiBPdGhlciB2YWx1ZXMgc3VjaCBhcyBleHRyYWN0ZWRVcmwgYXJlIHNldCBvbiBpbml0aWFsIG5hdmlnYXRpb25cbiAgICAgICAgICAgIC8vIGJ1dCB0aGUgdXJsQWZ0ZXJSZWRpcmVjdHMgbWF5IG5vdCBnZXQgc2V0IGlmIHdlIGFyZW4ndCBwcm9jZXNzaW5nIHRoZSBuZXcgVVJMICphbmQqIG5vdFxuICAgICAgICAgICAgLy8gcHJvY2Vzc2luZyB0aGUgcHJldmlvdXMgVVJMLlxuICAgICAgICAgICAgdHJhbnNpdGlvbi51cmxBZnRlclJlZGlyZWN0cyA9IHRoaXMuYnJvd3NlclVybFRyZWU7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNpdGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgUm91dGVyLnByb3RvdHlwZS5zZXRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbnMubmV4dChfX2Fzc2lnbiQxKHt9LCB0aGlzLmdldFRyYW5zaXRpb24oKSwgdCkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB1cCB0aGUgbG9jYXRpb24gY2hhbmdlIGxpc3RlbmVyIGFuZCBwZXJmb3JtcyB0aGUgaW5pdGlhbCBuYXZpZ2F0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgUm91dGVyLnByb3RvdHlwZS5pbml0aWFsTmF2aWdhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VXBMb2NhdGlvbkNoYW5nZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5uYXZpZ2F0aW9uSWQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5hdmlnYXRlQnlVcmwodGhpcy5sb2NhdGlvbi5wYXRoKHRydWUpLCB7IHJlcGxhY2VVcmw6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHVwIHRoZSBsb2NhdGlvbiBjaGFuZ2UgbGlzdGVuZXIuXG4gICAgICAgICAqL1xuICAgICAgICBSb3V0ZXIucHJvdG90eXBlLnNldFVwTG9jYXRpb25DaGFuZ2VMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAvLyBEb24ndCBuZWVkIHRvIHVzZSBab25lLndyYXAgYW55IG1vcmUsIGJlY2F1c2Ugem9uZS5qc1xuICAgICAgICAgICAgLy8gYWxyZWFkeSBwYXRjaCBvblBvcFN0YXRlLCBzbyBsb2NhdGlvbiBjaGFuZ2UgY2FsbGJhY2sgd2lsbFxuICAgICAgICAgICAgLy8gcnVuIGludG8gbmdab25lXG4gICAgICAgICAgICBpZiAoIXRoaXMubG9jYXRpb25TdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2F0aW9uU3Vic2NyaXB0aW9uID0gdGhpcy5sb2NhdGlvbi5zdWJzY3JpYmUoZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmF3VXJsVHJlZSA9IF90aGlzLnBhcnNlVXJsKGNoYW5nZVsndXJsJ10pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gY2hhbmdlWyd0eXBlJ10gPT09ICdwb3BzdGF0ZScgPyAncG9wc3RhdGUnIDogJ2hhc2hjaGFuZ2UnO1xuICAgICAgICAgICAgICAgICAgICAvLyBOYXZpZ2F0aW9ucyBjb21pbmcgZnJvbSBBbmd1bGFyIHJvdXRlciBoYXZlIGEgbmF2aWdhdGlvbklkIHN0YXRlIHByb3BlcnR5LiBXaGVuIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhpc3RzLCByZXN0b3JlIHRoZSBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gY2hhbmdlLnN0YXRlICYmIGNoYW5nZS5zdGF0ZS5uYXZpZ2F0aW9uSWQgPyBjaGFuZ2Uuc3RhdGUgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgX3RoaXMuc2NoZWR1bGVOYXZpZ2F0aW9uKHJhd1VybFRyZWUsIHNvdXJjZSwgc3RhdGUsIHsgcmVwbGFjZVVybDogdHJ1ZSB9KTsgfSwgMCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb3V0ZXIucHJvdG90eXBlLCBcInVybFwiLCB7XG4gICAgICAgICAgICAvKiogVGhlIGN1cnJlbnQgVVJMLiAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnNlcmlhbGl6ZVVybCh0aGlzLmN1cnJlbnRVcmxUcmVlKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBUaGUgY3VycmVudCBOYXZpZ2F0aW9uIG9iamVjdCBpZiBvbmUgZXhpc3RzICovXG4gICAgICAgIFJvdXRlci5wcm90b3R5cGUuZ2V0Q3VycmVudE5hdmlnYXRpb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmN1cnJlbnROYXZpZ2F0aW9uOyB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFJvdXRlci5wcm90b3R5cGUudHJpZ2dlckV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7IHRoaXMuZXZlbnRzLm5leHQoZXZlbnQpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzZXRzIHRoZSBjb25maWd1cmF0aW9uIHVzZWQgZm9yIG5hdmlnYXRpb24gYW5kIGdlbmVyYXRpbmcgbGlua3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb25maWcgVGhlIHJvdXRlIGFycmF5IGZvciB0aGUgbmV3IGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiByb3V0ZXIucmVzZXRDb25maWcoW1xuICAgICAgICAgKiAgeyBwYXRoOiAndGVhbS86aWQnLCBjb21wb25lbnQ6IFRlYW1DbXAsIGNoaWxkcmVuOiBbXG4gICAgICAgICAqICAgIHsgcGF0aDogJ3NpbXBsZScsIGNvbXBvbmVudDogU2ltcGxlQ21wIH0sXG4gICAgICAgICAqICAgIHsgcGF0aDogJ3VzZXIvOm5hbWUnLCBjb21wb25lbnQ6IFVzZXJDbXAgfVxuICAgICAgICAgKiAgXX1cbiAgICAgICAgICogXSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgUm91dGVyLnByb3RvdHlwZS5yZXNldENvbmZpZyA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlQ29uZmlnKGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZy5tYXAoc3RhbmRhcmRpemVDb25maWcpO1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubGFzdFN1Y2Nlc3NmdWxJZCA9IC0xO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICBSb3V0ZXIucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB0aGlzLmRpc3Bvc2UoKTsgfTtcbiAgICAgICAgLyoqIERpc3Bvc2VzIG9mIHRoZSByb3V0ZXIuICovXG4gICAgICAgIFJvdXRlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvY2F0aW9uU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhdGlvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMubG9jYXRpb25TdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbGllcyBhbiBhcnJheSBvZiBjb21tYW5kcyB0byB0aGUgY3VycmVudCBVUkwgdHJlZSBhbmQgY3JlYXRlcyBhIG5ldyBVUkwgdHJlZS5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiBnaXZlbiBhbiBhY3RpdmF0ZSByb3V0ZSwgYXBwbGllcyB0aGUgZ2l2ZW4gY29tbWFuZHMgc3RhcnRpbmcgZnJvbSB0aGUgcm91dGUuXG4gICAgICAgICAqIFdoZW4gbm90IGdpdmVuIGEgcm91dGUsIGFwcGxpZXMgdGhlIGdpdmVuIGNvbW1hbmQgc3RhcnRpbmcgZnJvbSB0aGUgcm9vdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNvbW1hbmRzIEFuIGFycmF5IG9mIGNvbW1hbmRzIHRvIGFwcGx5LlxuICAgICAgICAgKiBAcGFyYW0gbmF2aWdhdGlvbkV4dHJhc1xuICAgICAgICAgKiBAcmV0dXJucyBUaGUgbmV3IFVSTCB0cmVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogLy8gY3JlYXRlIC90ZWFtLzMzL3VzZXIvMTFcbiAgICAgICAgICogcm91dGVyLmNyZWF0ZVVybFRyZWUoWycvdGVhbScsIDMzLCAndXNlcicsIDExXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIGNyZWF0ZSAvdGVhbS8zMztleHBhbmQ9dHJ1ZS91c2VyLzExXG4gICAgICAgICAqIHJvdXRlci5jcmVhdGVVcmxUcmVlKFsnL3RlYW0nLCAzMywge2V4cGFuZDogdHJ1ZX0sICd1c2VyJywgMTFdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8geW91IGNhbiBjb2xsYXBzZSBzdGF0aWMgc2VnbWVudHMgbGlrZSB0aGlzICh0aGlzIHdvcmtzIG9ubHkgd2l0aCB0aGUgZmlyc3QgcGFzc2VkLWluIHZhbHVlKTpcbiAgICAgICAgICogcm91dGVyLmNyZWF0ZVVybFRyZWUoWycvdGVhbS8zMy91c2VyJywgdXNlcklkXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIElmIHRoZSBmaXJzdCBzZWdtZW50IGNhbiBjb250YWluIHNsYXNoZXMsIGFuZCB5b3UgZG8gbm90IHdhbnQgdGhlIHJvdXRlciB0byBzcGxpdCBpdCwgeW91XG4gICAgICAgICAqIC8vIGNhbiBkbyB0aGUgZm9sbG93aW5nOlxuICAgICAgICAgKlxuICAgICAgICAgKiByb3V0ZXIuY3JlYXRlVXJsVHJlZShbe3NlZ21lbnRQYXRoOiAnL29uZS90d28nfV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBjcmVhdGUgL3RlYW0vMzMvKHVzZXIvMTEvL3JpZ2h0OmNoYXQpXG4gICAgICAgICAqIHJvdXRlci5jcmVhdGVVcmxUcmVlKFsnL3RlYW0nLCAzMywge291dGxldHM6IHtwcmltYXJ5OiAndXNlci8xMScsIHJpZ2h0OiAnY2hhdCd9fV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyByZW1vdmUgdGhlIHJpZ2h0IHNlY29uZGFyeSBub2RlXG4gICAgICAgICAqIHJvdXRlci5jcmVhdGVVcmxUcmVlKFsnL3RlYW0nLCAzMywge291dGxldHM6IHtwcmltYXJ5OiAndXNlci8xMScsIHJpZ2h0OiBudWxsfX1dKTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gYXNzdW1pbmcgdGhlIGN1cnJlbnQgdXJsIGlzIGAvdGVhbS8zMy91c2VyLzExYCBhbmQgdGhlIHJvdXRlIHBvaW50cyB0byBgdXNlci8xMWBcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gbmF2aWdhdGUgdG8gL3RlYW0vMzMvdXNlci8xMS9kZXRhaWxzXG4gICAgICAgICAqIHJvdXRlci5jcmVhdGVVcmxUcmVlKFsnZGV0YWlscyddLCB7cmVsYXRpdmVUbzogcm91dGV9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gbmF2aWdhdGUgdG8gL3RlYW0vMzMvdXNlci8yMlxuICAgICAgICAgKiByb3V0ZXIuY3JlYXRlVXJsVHJlZShbJy4uLzIyJ10sIHtyZWxhdGl2ZVRvOiByb3V0ZX0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBuYXZpZ2F0ZSB0byAvdGVhbS80NC91c2VyLzIyXG4gICAgICAgICAqIHJvdXRlci5jcmVhdGVVcmxUcmVlKFsnLi4vLi4vdGVhbS80NC91c2VyLzIyJ10sIHtyZWxhdGl2ZVRvOiByb3V0ZX0pO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIFJvdXRlci5wcm90b3R5cGUuY3JlYXRlVXJsVHJlZSA9IGZ1bmN0aW9uIChjb21tYW5kcywgbmF2aWdhdGlvbkV4dHJhcykge1xuICAgICAgICAgICAgaWYgKG5hdmlnYXRpb25FeHRyYXMgPT09IHZvaWQgMCkgeyBuYXZpZ2F0aW9uRXh0cmFzID0ge307IH1cbiAgICAgICAgICAgIHZhciByZWxhdGl2ZVRvID0gbmF2aWdhdGlvbkV4dHJhcy5yZWxhdGl2ZVRvLCBxdWVyeVBhcmFtcyA9IG5hdmlnYXRpb25FeHRyYXMucXVlcnlQYXJhbXMsIGZyYWdtZW50ID0gbmF2aWdhdGlvbkV4dHJhcy5mcmFnbWVudCwgcHJlc2VydmVRdWVyeVBhcmFtcyA9IG5hdmlnYXRpb25FeHRyYXMucHJlc2VydmVRdWVyeVBhcmFtcywgcXVlcnlQYXJhbXNIYW5kbGluZyA9IG5hdmlnYXRpb25FeHRyYXMucXVlcnlQYXJhbXNIYW5kbGluZywgcHJlc2VydmVGcmFnbWVudCA9IG5hdmlnYXRpb25FeHRyYXMucHJlc2VydmVGcmFnbWVudDtcbiAgICAgICAgICAgIGlmIChjb3JlLmlzRGV2TW9kZSgpICYmIHByZXNlcnZlUXVlcnlQYXJhbXMgJiYgY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3ByZXNlcnZlUXVlcnlQYXJhbXMgaXMgZGVwcmVjYXRlZCwgdXNlIHF1ZXJ5UGFyYW1zSGFuZGxpbmcgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhID0gcmVsYXRpdmVUbyB8fCB0aGlzLnJvdXRlclN0YXRlLnJvb3Q7XG4gICAgICAgICAgICB2YXIgZiA9IHByZXNlcnZlRnJhZ21lbnQgPyB0aGlzLmN1cnJlbnRVcmxUcmVlLmZyYWdtZW50IDogZnJhZ21lbnQ7XG4gICAgICAgICAgICB2YXIgcSA9IG51bGw7XG4gICAgICAgICAgICBpZiAocXVlcnlQYXJhbXNIYW5kbGluZykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocXVlcnlQYXJhbXNIYW5kbGluZykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtZXJnZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBxID0gX19hc3NpZ24kMSh7fSwgdGhpcy5jdXJyZW50VXJsVHJlZS5xdWVyeVBhcmFtcywgcXVlcnlQYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3ByZXNlcnZlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHEgPSB0aGlzLmN1cnJlbnRVcmxUcmVlLnF1ZXJ5UGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBxID0gcXVlcnlQYXJhbXMgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBxID0gcHJlc2VydmVRdWVyeVBhcmFtcyA/IHRoaXMuY3VycmVudFVybFRyZWUucXVlcnlQYXJhbXMgOiBxdWVyeVBhcmFtcyB8fCBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBxID0gdGhpcy5yZW1vdmVFbXB0eVByb3BzKHEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVVybFRyZWUoYSwgdGhpcy5jdXJyZW50VXJsVHJlZSwgY29tbWFuZHMsIHEsIGYpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTmF2aWdhdGUgYmFzZWQgb24gdGhlIHByb3ZpZGVkIFVSTCwgd2hpY2ggbXVzdCBiZSBhYnNvbHV0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHVybCBBbiBhYnNvbHV0ZSBVUkwuIFRoZSBmdW5jdGlvbiBkb2VzIG5vdCBhcHBseSBhbnkgZGVsdGEgdG8gdGhlIGN1cnJlbnQgVVJMLlxuICAgICAgICAgKiBAcGFyYW0gZXh0cmFzIEFuIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgdGhhdCBtb2RpZnkgdGhlIG5hdmlnYXRpb24gc3RyYXRlZ3kuXG4gICAgICAgICAqIFRoZSBmdW5jdGlvbiBpZ25vcmVzIGFueSBwcm9wZXJ0aWVzIGluIHRoZSBgTmF2aWdhdGlvbkV4dHJhc2AgdGhhdCB3b3VsZCBjaGFuZ2UgdGhlXG4gICAgICAgICAqIHByb3ZpZGVkIFVSTC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gJ3RydWUnIHdoZW4gbmF2aWdhdGlvbiBzdWNjZWVkcyxcbiAgICAgICAgICogdG8gJ2ZhbHNlJyB3aGVuIG5hdmlnYXRpb24gZmFpbHMsIG9yIGlzIHJlamVjdGVkIG9uIGVycm9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogcm91dGVyLm5hdmlnYXRlQnlVcmwoXCIvdGVhbS8zMy91c2VyLzExXCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBOYXZpZ2F0ZSB3aXRob3V0IHVwZGF0aW5nIHRoZSBVUkxcbiAgICAgICAgICogcm91dGVyLm5hdmlnYXRlQnlVcmwoXCIvdGVhbS8zMy91c2VyLzExXCIsIHsgc2tpcExvY2F0aW9uQ2hhbmdlOiB0cnVlIH0pO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIFJvdXRlci5wcm90b3R5cGUubmF2aWdhdGVCeVVybCA9IGZ1bmN0aW9uICh1cmwsIGV4dHJhcykge1xuICAgICAgICAgICAgaWYgKGV4dHJhcyA9PT0gdm9pZCAwKSB7IGV4dHJhcyA9IHsgc2tpcExvY2F0aW9uQ2hhbmdlOiBmYWxzZSB9OyB9XG4gICAgICAgICAgICBpZiAoY29yZS5pc0Rldk1vZGUoKSAmJiB0aGlzLmlzTmdab25lRW5hYmxlZCAmJiAhY29yZS5OZ1pvbmUuaXNJbkFuZ3VsYXJab25lKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnNvbGUud2FybihcIk5hdmlnYXRpb24gdHJpZ2dlcmVkIG91dHNpZGUgQW5ndWxhciB6b25lLCBkaWQgeW91IGZvcmdldCB0byBjYWxsICduZ1pvbmUucnVuKCknP1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB1cmxUcmVlID0gaXNVcmxUcmVlKHVybCkgPyB1cmwgOiB0aGlzLnBhcnNlVXJsKHVybCk7XG4gICAgICAgICAgICB2YXIgbWVyZ2VkVHJlZSA9IHRoaXMudXJsSGFuZGxpbmdTdHJhdGVneS5tZXJnZSh1cmxUcmVlLCB0aGlzLnJhd1VybFRyZWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NoZWR1bGVOYXZpZ2F0aW9uKG1lcmdlZFRyZWUsICdpbXBlcmF0aXZlJywgbnVsbCwgZXh0cmFzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hdmlnYXRlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBhcnJheSBvZiBjb21tYW5kcyBhbmQgYSBzdGFydGluZyBwb2ludC5cbiAgICAgICAgICogSWYgbm8gc3RhcnRpbmcgcm91dGUgaXMgcHJvdmlkZWQsIHRoZSBuYXZpZ2F0aW9uIGlzIGFic29sdXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0OlxuICAgICAgICAgKiAtIHJlc29sdmVzIHRvICd0cnVlJyB3aGVuIG5hdmlnYXRpb24gc3VjY2VlZHMsXG4gICAgICAgICAqIC0gcmVzb2x2ZXMgdG8gJ2ZhbHNlJyB3aGVuIG5hdmlnYXRpb24gZmFpbHMsXG4gICAgICAgICAqIC0gaXMgcmVqZWN0ZWQgd2hlbiBhbiBlcnJvciBoYXBwZW5zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogcm91dGVyLm5hdmlnYXRlKFsndGVhbScsIDMzLCAndXNlcicsIDExXSwge3JlbGF0aXZlVG86IHJvdXRlfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIE5hdmlnYXRlIHdpdGhvdXQgdXBkYXRpbmcgdGhlIFVSTFxuICAgICAgICAgKiByb3V0ZXIubmF2aWdhdGUoWyd0ZWFtJywgMzMsICd1c2VyJywgMTFdLCB7cmVsYXRpdmVUbzogcm91dGUsIHNraXBMb2NhdGlvbkNoYW5nZTogdHJ1ZX0pO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGZpcnN0IHBhcmFtZXRlciBvZiBgbmF2aWdhdGUoKWAgaXMgYSBkZWx0YSB0byBiZSBhcHBsaWVkIHRvIHRoZSBjdXJyZW50IFVSTFxuICAgICAgICAgKiBvciB0aGUgb25lIHByb3ZpZGVkIGluIHRoZSBgcmVsYXRpdmVUb2AgcHJvcGVydHkgb2YgdGhlIHNlY29uZCBwYXJhbWV0ZXIgKHRoZVxuICAgICAgICAgKiBgTmF2aWdhdGlvbkV4dHJhc2ApLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJbiBvcmRlciB0byBhZmZlY3QgdGhpcyBicm93c2VyJ3MgYGhpc3Rvcnkuc3RhdGVgIGVudHJ5LCB0aGUgYHN0YXRlYFxuICAgICAgICAgKiBwYXJhbWV0ZXIgY2FuIGJlIHBhc3NlZC4gVGhpcyBtdXN0IGJlIGFuIG9iamVjdCBiZWNhdXNlIHRoZSByb3V0ZXJcbiAgICAgICAgICogd2lsbCBhZGQgdGhlIGBuYXZpZ2F0aW9uSWRgIHByb3BlcnR5IHRvIHRoaXMgb2JqZWN0IGJlZm9yZSBjcmVhdGluZ1xuICAgICAgICAgKiB0aGUgbmV3IGhpc3RvcnkgaXRlbS5cbiAgICAgICAgICovXG4gICAgICAgIFJvdXRlci5wcm90b3R5cGUubmF2aWdhdGUgPSBmdW5jdGlvbiAoY29tbWFuZHMsIGV4dHJhcykge1xuICAgICAgICAgICAgaWYgKGV4dHJhcyA9PT0gdm9pZCAwKSB7IGV4dHJhcyA9IHsgc2tpcExvY2F0aW9uQ2hhbmdlOiBmYWxzZSB9OyB9XG4gICAgICAgICAgICB2YWxpZGF0ZUNvbW1hbmRzKGNvbW1hbmRzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hdmlnYXRlQnlVcmwodGhpcy5jcmVhdGVVcmxUcmVlKGNvbW1hbmRzLCBleHRyYXMpLCBleHRyYXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogU2VyaWFsaXplcyBhIGBVcmxUcmVlYCBpbnRvIGEgc3RyaW5nICovXG4gICAgICAgIFJvdXRlci5wcm90b3R5cGUuc2VyaWFsaXplVXJsID0gZnVuY3Rpb24gKHVybCkgeyByZXR1cm4gdGhpcy51cmxTZXJpYWxpemVyLnNlcmlhbGl6ZSh1cmwpOyB9O1xuICAgICAgICAvKiogUGFyc2VzIGEgc3RyaW5nIGludG8gYSBgVXJsVHJlZWAgKi9cbiAgICAgICAgUm91dGVyLnByb3RvdHlwZS5wYXJzZVVybCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgIHZhciB1cmxUcmVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB1cmxUcmVlID0gdGhpcy51cmxTZXJpYWxpemVyLnBhcnNlKHVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHVybFRyZWUgPSB0aGlzLm1hbGZvcm1lZFVyaUVycm9ySGFuZGxlcihlLCB0aGlzLnVybFNlcmlhbGl6ZXIsIHVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXJsVHJlZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIFJldHVybnMgd2hldGhlciB0aGUgdXJsIGlzIGFjdGl2YXRlZCAqL1xuICAgICAgICBSb3V0ZXIucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKHVybCwgZXhhY3QpIHtcbiAgICAgICAgICAgIGlmIChpc1VybFRyZWUodXJsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250YWluc1RyZWUodGhpcy5jdXJyZW50VXJsVHJlZSwgdXJsLCBleGFjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdXJsVHJlZSA9IHRoaXMucGFyc2VVcmwodXJsKTtcbiAgICAgICAgICAgIHJldHVybiBjb250YWluc1RyZWUodGhpcy5jdXJyZW50VXJsVHJlZSwgdXJsVHJlZSwgZXhhY3QpO1xuICAgICAgICB9O1xuICAgICAgICBSb3V0ZXIucHJvdG90eXBlLnJlbW92ZUVtcHR5UHJvcHMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMocGFyYW1zKS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwga2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfTtcbiAgICAgICAgUm91dGVyLnByb3RvdHlwZS5wcm9jZXNzTmF2aWdhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9ucy5zdWJzY3JpYmUoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5uYXZpZ2F0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF90aGlzLmxhc3RTdWNjZXNzZnVsSWQgPSB0LmlkO1xuICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50c1xuICAgICAgICAgICAgICAgICAgICAubmV4dChuZXcgTmF2aWdhdGlvbkVuZCh0LmlkLCBfdGhpcy5zZXJpYWxpemVVcmwodC5leHRyYWN0ZWRVcmwpLCBfdGhpcy5zZXJpYWxpemVVcmwoX3RoaXMuY3VycmVudFVybFRyZWUpKSk7XG4gICAgICAgICAgICAgICAgX3RoaXMubGFzdFN1Y2Nlc3NmdWxOYXZpZ2F0aW9uID0gX3RoaXMuY3VycmVudE5hdmlnYXRpb247XG4gICAgICAgICAgICAgICAgX3RoaXMuY3VycmVudE5hdmlnYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIHQucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7IF90aGlzLmNvbnNvbGUud2FybihcIlVuaGFuZGxlZCBOYXZpZ2F0aW9uIEVycm9yOiBcIik7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBSb3V0ZXIucHJvdG90eXBlLnNjaGVkdWxlTmF2aWdhdGlvbiA9IGZ1bmN0aW9uIChyYXdVcmwsIHNvdXJjZSwgcmVzdG9yZWRTdGF0ZSwgZXh0cmFzKSB7XG4gICAgICAgICAgICB2YXIgbGFzdE5hdmlnYXRpb24gPSB0aGlzLmdldFRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIHRyaWdnZXJzIGEgbmF2aWdhdGlvbiBpbXBlcmF0aXZlbHkgKGUuZy4sIGJ5IHVzaW5nIG5hdmlnYXRlQnlVcmwpLFxuICAgICAgICAgICAgLy8gYW5kIHRoYXQgbmF2aWdhdGlvbiByZXN1bHRzIGluICdyZXBsYWNlU3RhdGUnIHRoYXQgbGVhZHMgdG8gdGhlIHNhbWUgVVJMLFxuICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIHNraXAgdGhvc2UuXG4gICAgICAgICAgICBpZiAobGFzdE5hdmlnYXRpb24gJiYgc291cmNlICE9PSAnaW1wZXJhdGl2ZScgJiYgbGFzdE5hdmlnYXRpb24uc291cmNlID09PSAnaW1wZXJhdGl2ZScgJiZcbiAgICAgICAgICAgICAgICBsYXN0TmF2aWdhdGlvbi5yYXdVcmwudG9TdHJpbmcoKSA9PT0gcmF3VXJsLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpOyAvLyByZXR1cm4gdmFsdWUgaXMgbm90IHVzZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEJlY2F1c2Ugb2YgYSBidWcgaW4gSUUgYW5kIEVkZ2UsIHRoZSBsb2NhdGlvbiBjbGFzcyBmaXJlcyB0d28gZXZlbnRzIChwb3BzdGF0ZSBhbmRcbiAgICAgICAgICAgIC8vIGhhc2hjaGFuZ2UpIGV2ZXJ5IHNpbmdsZSB0aW1lLiBUaGUgc2Vjb25kIG9uZSBzaG91bGQgYmUgaWdub3JlZC4gT3RoZXJ3aXNlLCB0aGUgVVJMIHdpbGxcbiAgICAgICAgICAgIC8vIGZsaWNrZXIuIEhhbmRsZXMgdGhlIGNhc2Ugd2hlbiBhIHBvcHN0YXRlIHdhcyBlbWl0dGVkIGZpcnN0LlxuICAgICAgICAgICAgaWYgKGxhc3ROYXZpZ2F0aW9uICYmIHNvdXJjZSA9PSAnaGFzaGNoYW5nZScgJiYgbGFzdE5hdmlnYXRpb24uc291cmNlID09PSAncG9wc3RhdGUnICYmXG4gICAgICAgICAgICAgICAgbGFzdE5hdmlnYXRpb24ucmF3VXJsLnRvU3RyaW5nKCkgPT09IHJhd1VybC50b1N0cmluZygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTsgLy8gcmV0dXJuIHZhbHVlIGlzIG5vdCB1c2VkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBCZWNhdXNlIG9mIGEgYnVnIGluIElFIGFuZCBFZGdlLCB0aGUgbG9jYXRpb24gY2xhc3MgZmlyZXMgdHdvIGV2ZW50cyAocG9wc3RhdGUgYW5kXG4gICAgICAgICAgICAvLyBoYXNoY2hhbmdlKSBldmVyeSBzaW5nbGUgdGltZS4gVGhlIHNlY29uZCBvbmUgc2hvdWxkIGJlIGlnbm9yZWQuIE90aGVyd2lzZSwgdGhlIFVSTCB3aWxsXG4gICAgICAgICAgICAvLyBmbGlja2VyLiBIYW5kbGVzIHRoZSBjYXNlIHdoZW4gYSBoYXNoY2hhbmdlIHdhcyBlbWl0dGVkIGZpcnN0LlxuICAgICAgICAgICAgaWYgKGxhc3ROYXZpZ2F0aW9uICYmIHNvdXJjZSA9PSAncG9wc3RhdGUnICYmIGxhc3ROYXZpZ2F0aW9uLnNvdXJjZSA9PT0gJ2hhc2hjaGFuZ2UnICYmXG4gICAgICAgICAgICAgICAgbGFzdE5hdmlnYXRpb24ucmF3VXJsLnRvU3RyaW5nKCkgPT09IHJhd1VybC50b1N0cmluZygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTsgLy8gcmV0dXJuIHZhbHVlIGlzIG5vdCB1c2VkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzb2x2ZSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgcmVqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcywgcmVqKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHJlcztcbiAgICAgICAgICAgICAgICByZWplY3QgPSByZWo7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBpZCA9ICsrdGhpcy5uYXZpZ2F0aW9uSWQ7XG4gICAgICAgICAgICB0aGlzLnNldFRyYW5zaXRpb24oe1xuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICByZXN0b3JlZFN0YXRlOiByZXN0b3JlZFN0YXRlLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRVcmxUcmVlOiB0aGlzLmN1cnJlbnRVcmxUcmVlLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRSYXdVcmw6IHRoaXMucmF3VXJsVHJlZSwgcmF3VXJsOiByYXdVcmwsIGV4dHJhczogZXh0cmFzLCByZXNvbHZlOiByZXNvbHZlLCByZWplY3Q6IHJlamVjdCwgcHJvbWlzZTogcHJvbWlzZSxcbiAgICAgICAgICAgICAgICBjdXJyZW50U25hcHNob3Q6IHRoaXMucm91dGVyU3RhdGUuc25hcHNob3QsXG4gICAgICAgICAgICAgICAgY3VycmVudFJvdXRlclN0YXRlOiB0aGlzLnJvdXRlclN0YXRlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBlcnJvciBpcyBwcm9wYWdhdGVkIGV2ZW4gdGhvdWdoIGBwcm9jZXNzTmF2aWdhdGlvbnNgIGNhdGNoXG4gICAgICAgICAgICAvLyBoYW5kbGVyIGRvZXMgbm90IHJldGhyb3dcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLmNhdGNoKGZ1bmN0aW9uIChlKSB7IHJldHVybiBQcm9taXNlLnJlamVjdChlKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFJvdXRlci5wcm90b3R5cGUuc2V0QnJvd3NlclVybCA9IGZ1bmN0aW9uICh1cmwsIHJlcGxhY2VVcmwsIGlkLCBzdGF0ZSkge1xuICAgICAgICAgICAgdmFyIHBhdGggPSB0aGlzLnVybFNlcmlhbGl6ZXIuc2VyaWFsaXplKHVybCk7XG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlIHx8IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMubG9jYXRpb24uaXNDdXJyZW50UGF0aEVxdWFsVG8ocGF0aCkgfHwgcmVwbGFjZVVybCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8oamFzb25hZGVuKTogUmVtb3ZlIGZpcnN0IGBuYXZpZ2F0aW9uSWRgIGFuZCByZWx5IG9uIGBuZ2AgbmFtZXNwYWNlLlxuICAgICAgICAgICAgICAgIHRoaXMubG9jYXRpb24ucmVwbGFjZVN0YXRlKHBhdGgsICcnLCBfX2Fzc2lnbiQxKHt9LCBzdGF0ZSwgeyBuYXZpZ2F0aW9uSWQ6IGlkIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubG9jYXRpb24uZ28ocGF0aCwgJycsIF9fYXNzaWduJDEoe30sIHN0YXRlLCB7IG5hdmlnYXRpb25JZDogaWQgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBSb3V0ZXIucHJvdG90eXBlLnJlc2V0U3RhdGVBbmRVcmwgPSBmdW5jdGlvbiAoc3RvcmVkU3RhdGUsIHN0b3JlZFVybCwgcmF3VXJsKSB7XG4gICAgICAgICAgICB0aGlzLnJvdXRlclN0YXRlID0gc3RvcmVkU3RhdGU7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRVcmxUcmVlID0gc3RvcmVkVXJsO1xuICAgICAgICAgICAgdGhpcy5yYXdVcmxUcmVlID0gdGhpcy51cmxIYW5kbGluZ1N0cmF0ZWd5Lm1lcmdlKHRoaXMuY3VycmVudFVybFRyZWUsIHJhd1VybCk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0VXJsVG9DdXJyZW50VXJsVHJlZSgpO1xuICAgICAgICB9O1xuICAgICAgICBSb3V0ZXIucHJvdG90eXBlLnJlc2V0VXJsVG9DdXJyZW50VXJsVHJlZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYXRpb24ucmVwbGFjZVN0YXRlKHRoaXMudXJsU2VyaWFsaXplci5zZXJpYWxpemUodGhpcy5yYXdVcmxUcmVlKSwgJycsIHsgbmF2aWdhdGlvbklkOiB0aGlzLmxhc3RTdWNjZXNzZnVsSWQgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSb3V0ZXI7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUNvbW1hbmRzKGNvbW1hbmRzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tbWFuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjbWQgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgICAgIGlmIChjbWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByZXF1ZXN0ZWQgcGF0aCBjb250YWlucyBcIiArIGNtZCArIFwiIHNlZ21lbnQgYXQgaW5kZXggXCIgKyBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIExldHMgeW91IGxpbmsgdG8gc3BlY2lmaWMgcm91dGVzIGluIHlvdXIgYXBwLlxuICAgICAqXG4gICAgICogQ29uc2lkZXIgdGhlIGZvbGxvd2luZyByb3V0ZSBjb25maWd1cmF0aW9uOlxuICAgICAqIGBbeyBwYXRoOiAndXNlci86bmFtZScsIGNvbXBvbmVudDogVXNlckNtcCB9XWAuXG4gICAgICogV2hlbiBsaW5raW5nIHRvIHRoaXMgYHVzZXIvOm5hbWVgIHJvdXRlLCB5b3UgdXNlIHRoZSBgUm91dGVyTGlua2AgZGlyZWN0aXZlLlxuICAgICAqXG4gICAgICogSWYgdGhlIGxpbmsgaXMgc3RhdGljLCB5b3UgY2FuIHVzZSB0aGUgZGlyZWN0aXZlIGFzIGZvbGxvd3M6XG4gICAgICogYDxhIHJvdXRlckxpbms9XCIvdXNlci9ib2JcIj5saW5rIHRvIHVzZXIgY29tcG9uZW50PC9hPmBcbiAgICAgKlxuICAgICAqIElmIHlvdSB1c2UgZHluYW1pYyB2YWx1ZXMgdG8gZ2VuZXJhdGUgdGhlIGxpbmssIHlvdSBjYW4gcGFzcyBhbiBhcnJheSBvZiBwYXRoXG4gICAgICogc2VnbWVudHMsIGZvbGxvd2VkIGJ5IHRoZSBwYXJhbXMgZm9yIGVhY2ggc2VnbWVudC5cbiAgICAgKlxuICAgICAqIEZvciBpbnN0YW5jZSBgWycvdGVhbScsIHRlYW1JZCwgJ3VzZXInLCB1c2VyTmFtZSwge2RldGFpbHM6IHRydWV9XWBcbiAgICAgKiBtZWFucyB0aGF0IHdlIHdhbnQgdG8gZ2VuZXJhdGUgYSBsaW5rIHRvIGAvdGVhbS8xMS91c2VyL2JvYjtkZXRhaWxzPXRydWVgLlxuICAgICAqXG4gICAgICogTXVsdGlwbGUgc3RhdGljIHNlZ21lbnRzIGNhbiBiZSBtZXJnZWQgaW50byBvbmVcbiAgICAgKiAoZS5nLiwgYFsnL3RlYW0vMTEvdXNlcicsIHVzZXJOYW1lLCB7ZGV0YWlsczogdHJ1ZX1dYCkuXG4gICAgICpcbiAgICAgKiBUaGUgZmlyc3Qgc2VnbWVudCBuYW1lIGNhbiBiZSBwcmVwZW5kZWQgd2l0aCBgL2AsIGAuL2AsIG9yIGAuLi9gOlxuICAgICAqICogSWYgdGhlIGZpcnN0IHNlZ21lbnQgYmVnaW5zIHdpdGggYC9gLCB0aGUgcm91dGVyIHdpbGwgbG9vayB1cCB0aGUgcm91dGUgZnJvbSB0aGUgcm9vdCBvZiB0aGVcbiAgICAgKiAgIGFwcC5cbiAgICAgKiAqIElmIHRoZSBmaXJzdCBzZWdtZW50IGJlZ2lucyB3aXRoIGAuL2AsIG9yIGRvZXNuJ3QgYmVnaW4gd2l0aCBhIHNsYXNoLCB0aGUgcm91dGVyIHdpbGxcbiAgICAgKiAgIGluc3RlYWQgbG9vayBpbiB0aGUgY2hpbGRyZW4gb2YgdGhlIGN1cnJlbnQgYWN0aXZhdGVkIHJvdXRlLlxuICAgICAqICogQW5kIGlmIHRoZSBmaXJzdCBzZWdtZW50IGJlZ2lucyB3aXRoIGAuLi9gLCB0aGUgcm91dGVyIHdpbGwgZ28gdXAgb25lIGxldmVsLlxuICAgICAqXG4gICAgICogWW91IGNhbiBzZXQgcXVlcnkgcGFyYW1zIGFuZCBmcmFnbWVudCBhcyBmb2xsb3dzOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogPGEgW3JvdXRlckxpbmtdPVwiWycvdXNlci9ib2InXVwiIFtxdWVyeVBhcmFtc109XCJ7ZGVidWc6IHRydWV9XCIgZnJhZ21lbnQ9XCJlZHVjYXRpb25cIj5cbiAgICAgKiAgIGxpbmsgdG8gdXNlciBjb21wb25lbnRcbiAgICAgKiA8L2E+XG4gICAgICogYGBgXG4gICAgICogUm91dGVyTGluayB3aWxsIHVzZSB0aGVzZSB0byBnZW5lcmF0ZSB0aGlzIGxpbms6IGAvdXNlci9ib2IjZWR1Y2F0aW9uP2RlYnVnPXRydWVgLlxuICAgICAqXG4gICAgICogKERlcHJlY2F0ZWQgaW4gdjQuMC4wIHVzZSBgcXVlcnlQYXJhbXNIYW5kbGluZ2AgaW5zdGVhZCkgWW91IGNhbiBhbHNvIHRlbGwgdGhlXG4gICAgICogZGlyZWN0aXZlIHRvIHByZXNlcnZlIHRoZSBjdXJyZW50IHF1ZXJ5IHBhcmFtcyBhbmQgZnJhZ21lbnQ6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiA8YSBbcm91dGVyTGlua109XCJbJy91c2VyL2JvYiddXCIgcHJlc2VydmVRdWVyeVBhcmFtcyBwcmVzZXJ2ZUZyYWdtZW50PlxuICAgICAqICAgbGluayB0byB1c2VyIGNvbXBvbmVudFxuICAgICAqIDwvYT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFlvdSBjYW4gdGVsbCB0aGUgZGlyZWN0aXZlIGhvdyB0byBoYW5kbGUgcXVlcnlQYXJhbXMuIEF2YWlsYWJsZSBvcHRpb25zIGFyZTpcbiAgICAgKiAgLSBgJ21lcmdlJ2A6IG1lcmdlIHRoZSBxdWVyeVBhcmFtcyBpbnRvIHRoZSBjdXJyZW50IHF1ZXJ5UGFyYW1zXG4gICAgICogIC0gYCdwcmVzZXJ2ZSdgOiBwcmVzZXJ2ZSB0aGUgY3VycmVudCBxdWVyeVBhcmFtc1xuICAgICAqICAtIGRlZmF1bHQvYCcnYDogdXNlIHRoZSBxdWVyeVBhcmFtcyBvbmx5XG4gICAgICpcbiAgICAgKiBTYW1lIG9wdGlvbnMgZm9yIHtAbGluayBOYXZpZ2F0aW9uRXh0cmFzI3F1ZXJ5UGFyYW1zSGFuZGxpbmdcbiAgICAgKiBOYXZpZ2F0aW9uRXh0cmFzI3F1ZXJ5UGFyYW1zSGFuZGxpbmd9LlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogPGEgW3JvdXRlckxpbmtdPVwiWycvdXNlci9ib2InXVwiIFtxdWVyeVBhcmFtc109XCJ7ZGVidWc6IHRydWV9XCIgcXVlcnlQYXJhbXNIYW5kbGluZz1cIm1lcmdlXCI+XG4gICAgICogICBsaW5rIHRvIHVzZXIgY29tcG9uZW50XG4gICAgICogPC9hPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogWW91IGNhbiBwcm92aWRlIGEgYHN0YXRlYCB2YWx1ZSB0byBiZSBwZXJzaXN0ZWQgdG8gdGhlIGJyb3dzZXIncyBIaXN0b3J5LnN0YXRlXG4gICAgICogcHJvcGVydHkgKFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSGlzdG9yeSNQcm9wZXJ0aWVzKS4gSXQnc1xuICAgICAqIHVzZWQgYXMgZm9sbG93czpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIDxhIFtyb3V0ZXJMaW5rXT1cIlsnL3VzZXIvYm9iJ11cIiBbc3RhdGVdPVwie3RyYWNpbmdJZDogMTIzfVwiPlxuICAgICAqICAgbGluayB0byB1c2VyIGNvbXBvbmVudFxuICAgICAqIDwvYT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEFuZCBsYXRlciB0aGUgdmFsdWUgY2FuIGJlIHJlYWQgZnJvbSB0aGUgcm91dGVyIHRocm91Z2ggYHJvdXRlci5nZXRDdXJyZW50TmF2aWdhdGlvbmAuXG4gICAgICogRm9yIGV4YW1wbGUsIHRvIGNhcHR1cmUgdGhlIGB0cmFjaW5nSWRgIGFib3ZlIGR1cmluZyB0aGUgYE5hdmlnYXRpb25TdGFydGAgZXZlbnQ6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiAvLyBHZXQgTmF2aWdhdGlvblN0YXJ0IGV2ZW50c1xuICAgICAqIHJvdXRlci5ldmVudHMucGlwZShmaWx0ZXIoZSA9PiBlIGluc3RhbmNlb2YgTmF2aWdhdGlvblN0YXJ0KSkuc3Vic2NyaWJlKGUgPT4ge1xuICAgICAqICAgY29uc3QgbmF2aWdhdGlvbiA9IHJvdXRlci5nZXRDdXJyZW50TmF2aWdhdGlvbigpO1xuICAgICAqICAgdHJhY2luZ1NlcnZpY2UudHJhY2Uoe2lkOiBuYXZpZ2F0aW9uLmV4dHJhcy5zdGF0ZS50cmFjaW5nSWR9KTtcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRoZSByb3V0ZXIgbGluayBkaXJlY3RpdmUgYWx3YXlzIHRyZWF0cyB0aGUgcHJvdmlkZWQgaW5wdXQgYXMgYSBkZWx0YSB0byB0aGUgY3VycmVudCB1cmwuXG4gICAgICpcbiAgICAgKiBGb3IgaW5zdGFuY2UsIGlmIHRoZSBjdXJyZW50IHVybCBpcyBgL3VzZXIvKGJveC8vYXV4OnRlYW0pYC5cbiAgICAgKlxuICAgICAqIFRoZW4gdGhlIGZvbGxvd2luZyBsaW5rIGA8YSBbcm91dGVyTGlua109XCJbJy91c2VyL2ppbSddXCI+SmltPC9hPmAgd2lsbCBnZW5lcmF0ZSB0aGUgbGlua1xuICAgICAqIGAvdXNlci8oamltLy9hdXg6dGVhbSlgLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBSb3V0ZXIjY3JlYXRlVXJsVHJlZSBjcmVhdGVVcmxUcmVlfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIEBuZ01vZHVsZSBSb3V0ZXJNb2R1bGVcbiAgICAgKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgUm91dGVyTGluayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUm91dGVyTGluayhyb3V0ZXIsIHJvdXRlLCB0YWJJbmRleCwgcmVuZGVyZXIsIGVsKSB7XG4gICAgICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgICAgIHRoaXMucm91dGUgPSByb3V0ZTtcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZHMgPSBbXTtcbiAgICAgICAgICAgIGlmICh0YWJJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuc2V0QXR0cmlidXRlKGVsLm5hdGl2ZUVsZW1lbnQsICd0YWJpbmRleCcsICcwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJvdXRlckxpbmsucHJvdG90eXBlLCBcInJvdXRlckxpbmtcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoY29tbWFuZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tbWFuZHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRzID0gQXJyYXkuaXNBcnJheShjb21tYW5kcykgPyBjb21tYW5kcyA6IFtjb21tYW5kc107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb3V0ZXJMaW5rLnByb3RvdHlwZSwgXCJwcmVzZXJ2ZVF1ZXJ5UGFyYW1zXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGRlcHJlY2F0ZWQgNC4wLjAgdXNlIGBxdWVyeVBhcmFtc0hhbmRsaW5nYCBpbnN0ZWFkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChjb3JlLmlzRGV2TW9kZSgpICYmIGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigncHJlc2VydmVRdWVyeVBhcmFtcyBpcyBkZXByZWNhdGVkISwgdXNlIHF1ZXJ5UGFyYW1zSGFuZGxpbmcgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wcmVzZXJ2ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIFJvdXRlckxpbmsucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZXh0cmFzID0ge1xuICAgICAgICAgICAgICAgIHNraXBMb2NhdGlvbkNoYW5nZTogYXR0ckJvb2xWYWx1ZSh0aGlzLnNraXBMb2NhdGlvbkNoYW5nZSksXG4gICAgICAgICAgICAgICAgcmVwbGFjZVVybDogYXR0ckJvb2xWYWx1ZSh0aGlzLnJlcGxhY2VVcmwpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucm91dGVyLm5hdmlnYXRlQnlVcmwodGhpcy51cmxUcmVlLCBleHRyYXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb3V0ZXJMaW5rLnByb3RvdHlwZSwgXCJ1cmxUcmVlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJvdXRlci5jcmVhdGVVcmxUcmVlKHRoaXMuY29tbWFuZHMsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVUbzogdGhpcy5yb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHRoaXMucXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50OiB0aGlzLmZyYWdtZW50LFxuICAgICAgICAgICAgICAgICAgICBwcmVzZXJ2ZVF1ZXJ5UGFyYW1zOiBhdHRyQm9vbFZhbHVlKHRoaXMucHJlc2VydmUpLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtc0hhbmRsaW5nOiB0aGlzLnF1ZXJ5UGFyYW1zSGFuZGxpbmcsXG4gICAgICAgICAgICAgICAgICAgIHByZXNlcnZlRnJhZ21lbnQ6IGF0dHJCb29sVmFsdWUodGhpcy5wcmVzZXJ2ZUZyYWdtZW50KSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBfX2RlY29yYXRlJDEoW1xuICAgICAgICAgICAgY29yZS5JbnB1dCgpLFxuICAgICAgICAgICAgX19tZXRhZGF0YSQxKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgICAgICBdLCBSb3V0ZXJMaW5rLnByb3RvdHlwZSwgXCJxdWVyeVBhcmFtc1wiLCB2b2lkIDApO1xuICAgICAgICBfX2RlY29yYXRlJDEoW1xuICAgICAgICAgICAgY29yZS5JbnB1dCgpLFxuICAgICAgICAgICAgX19tZXRhZGF0YSQxKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgICAgICBdLCBSb3V0ZXJMaW5rLnByb3RvdHlwZSwgXCJmcmFnbWVudFwiLCB2b2lkIDApO1xuICAgICAgICBfX2RlY29yYXRlJDEoW1xuICAgICAgICAgICAgY29yZS5JbnB1dCgpLFxuICAgICAgICAgICAgX19tZXRhZGF0YSQxKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgICAgICBdLCBSb3V0ZXJMaW5rLnByb3RvdHlwZSwgXCJxdWVyeVBhcmFtc0hhbmRsaW5nXCIsIHZvaWQgMCk7XG4gICAgICAgIF9fZGVjb3JhdGUkMShbXG4gICAgICAgICAgICBjb3JlLklucHV0KCksXG4gICAgICAgICAgICBfX21ldGFkYXRhJDEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgICAgICBdLCBSb3V0ZXJMaW5rLnByb3RvdHlwZSwgXCJwcmVzZXJ2ZUZyYWdtZW50XCIsIHZvaWQgMCk7XG4gICAgICAgIF9fZGVjb3JhdGUkMShbXG4gICAgICAgICAgICBjb3JlLklucHV0KCksXG4gICAgICAgICAgICBfX21ldGFkYXRhJDEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgICAgICBdLCBSb3V0ZXJMaW5rLnByb3RvdHlwZSwgXCJza2lwTG9jYXRpb25DaGFuZ2VcIiwgdm9pZCAwKTtcbiAgICAgICAgX19kZWNvcmF0ZSQxKFtcbiAgICAgICAgICAgIGNvcmUuSW5wdXQoKSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEkMShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgICAgIF0sIFJvdXRlckxpbmsucHJvdG90eXBlLCBcInJlcGxhY2VVcmxcIiwgdm9pZCAwKTtcbiAgICAgICAgX19kZWNvcmF0ZSQxKFtcbiAgICAgICAgICAgIGNvcmUuSW5wdXQoKSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEkMShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICAgICAgXSwgUm91dGVyTGluay5wcm90b3R5cGUsIFwic3RhdGVcIiwgdm9pZCAwKTtcbiAgICAgICAgX19kZWNvcmF0ZSQxKFtcbiAgICAgICAgICAgIGNvcmUuSW5wdXQoKSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEkMShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgICAgICAgICBfX21ldGFkYXRhJDEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcbiAgICAgICAgXSwgUm91dGVyTGluay5wcm90b3R5cGUsIFwicm91dGVyTGlua1wiLCBudWxsKTtcbiAgICAgICAgX19kZWNvcmF0ZSQxKFtcbiAgICAgICAgICAgIGNvcmUuSW5wdXQoKSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEkMShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgICAgICAgICAgX19tZXRhZGF0YSQxKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jvb2xlYW5dKVxuICAgICAgICBdLCBSb3V0ZXJMaW5rLnByb3RvdHlwZSwgXCJwcmVzZXJ2ZVF1ZXJ5UGFyYW1zXCIsIG51bGwpO1xuICAgICAgICBfX2RlY29yYXRlJDEoW1xuICAgICAgICAgICAgY29yZS5Ib3N0TGlzdGVuZXIoJ2NsaWNrJyksXG4gICAgICAgICAgICBfX21ldGFkYXRhJDEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgICAgICAgICBfX21ldGFkYXRhJDEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgICAgICAgICBfX21ldGFkYXRhJDEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBCb29sZWFuKVxuICAgICAgICBdLCBSb3V0ZXJMaW5rLnByb3RvdHlwZSwgXCJvbkNsaWNrXCIsIG51bGwpO1xuICAgICAgICBSb3V0ZXJMaW5rID0gX19kZWNvcmF0ZSQxKFtcbiAgICAgICAgICAgIGNvcmUuRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICc6bm90KGEpOm5vdChhcmVhKVtyb3V0ZXJMaW5rXScgfSksXG4gICAgICAgICAgICBfX3BhcmFtJDEoMiwgY29yZS5BdHRyaWJ1dGUoJ3RhYmluZGV4JykpLFxuICAgICAgICAgICAgX19tZXRhZGF0YSQxKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1JvdXRlciwgQWN0aXZhdGVkUm91dGUsIFN0cmluZywgY29yZS5SZW5kZXJlcjIsIGNvcmUuRWxlbWVudFJlZl0pXG4gICAgICAgIF0sIFJvdXRlckxpbmspO1xuICAgICAgICByZXR1cm4gUm91dGVyTGluaztcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogTGV0cyB5b3UgbGluayB0byBzcGVjaWZpYyByb3V0ZXMgaW4geW91ciBhcHAuXG4gICAgICpcbiAgICAgKiBTZWUgYFJvdXRlckxpbmtgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQG5nTW9kdWxlIFJvdXRlck1vZHVsZVxuICAgICAqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBSb3V0ZXJMaW5rV2l0aEhyZWYgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJvdXRlckxpbmtXaXRoSHJlZihyb3V0ZXIsIHJvdXRlLCBsb2NhdGlvblN0cmF0ZWd5KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgICAgICAgICB0aGlzLnJvdXRlID0gcm91dGU7XG4gICAgICAgICAgICB0aGlzLmxvY2F0aW9uU3RyYXRlZ3kgPSBsb2NhdGlvblN0cmF0ZWd5O1xuICAgICAgICAgICAgdGhpcy5jb21tYW5kcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSByb3V0ZXIuZXZlbnRzLnN1YnNjcmliZShmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgICAgIGlmIChzIGluc3RhbmNlb2YgTmF2aWdhdGlvbkVuZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVUYXJnZXRVcmxBbmRIcmVmKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJvdXRlckxpbmtXaXRoSHJlZi5wcm90b3R5cGUsIFwicm91dGVyTGlua1wiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChjb21tYW5kcykge1xuICAgICAgICAgICAgICAgIGlmIChjb21tYW5kcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZHMgPSBBcnJheS5pc0FycmF5KGNvbW1hbmRzKSA/IGNvbW1hbmRzIDogW2NvbW1hbmRzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZHMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJvdXRlckxpbmtXaXRoSHJlZi5wcm90b3R5cGUsIFwicHJlc2VydmVRdWVyeVBhcmFtc1wiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChjb3JlLmlzRGV2TW9kZSgpICYmIGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigncHJlc2VydmVRdWVyeVBhcmFtcyBpcyBkZXByZWNhdGVkLCB1c2UgcXVlcnlQYXJhbXNIYW5kbGluZyBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnByZXNlcnZlID0gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgUm91dGVyTGlua1dpdGhIcmVmLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7IHRoaXMudXBkYXRlVGFyZ2V0VXJsQW5kSHJlZigpOyB9O1xuICAgICAgICBSb3V0ZXJMaW5rV2l0aEhyZWYucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpOyB9O1xuICAgICAgICBSb3V0ZXJMaW5rV2l0aEhyZWYucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoYnV0dG9uLCBjdHJsS2V5LCBtZXRhS2V5LCBzaGlmdEtleSkge1xuICAgICAgICAgICAgaWYgKGJ1dHRvbiAhPT0gMCB8fCBjdHJsS2V5IHx8IG1ldGFLZXkgfHwgc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy50YXJnZXQgPT09ICdzdHJpbmcnICYmIHRoaXMudGFyZ2V0ICE9ICdfc2VsZicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBleHRyYXMgPSB7XG4gICAgICAgICAgICAgICAgc2tpcExvY2F0aW9uQ2hhbmdlOiBhdHRyQm9vbFZhbHVlKHRoaXMuc2tpcExvY2F0aW9uQ2hhbmdlKSxcbiAgICAgICAgICAgICAgICByZXBsYWNlVXJsOiBhdHRyQm9vbFZhbHVlKHRoaXMucmVwbGFjZVVybCksXG4gICAgICAgICAgICAgICAgc3RhdGU6IHRoaXMuc3RhdGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnJvdXRlci5uYXZpZ2F0ZUJ5VXJsKHRoaXMudXJsVHJlZSwgZXh0cmFzKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgUm91dGVyTGlua1dpdGhIcmVmLnByb3RvdHlwZS51cGRhdGVUYXJnZXRVcmxBbmRIcmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5ocmVmID0gdGhpcy5sb2NhdGlvblN0cmF0ZWd5LnByZXBhcmVFeHRlcm5hbFVybCh0aGlzLnJvdXRlci5zZXJpYWxpemVVcmwodGhpcy51cmxUcmVlKSk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb3V0ZXJMaW5rV2l0aEhyZWYucHJvdG90eXBlLCBcInVybFRyZWVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm91dGVyLmNyZWF0ZVVybFRyZWUodGhpcy5jb21tYW5kcywge1xuICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVRvOiB0aGlzLnJvdXRlLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogdGhpcy5xdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQ6IHRoaXMuZnJhZ21lbnQsXG4gICAgICAgICAgICAgICAgICAgIHByZXNlcnZlUXVlcnlQYXJhbXM6IGF0dHJCb29sVmFsdWUodGhpcy5wcmVzZXJ2ZSksXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zSGFuZGxpbmc6IHRoaXMucXVlcnlQYXJhbXNIYW5kbGluZyxcbiAgICAgICAgICAgICAgICAgICAgcHJlc2VydmVGcmFnbWVudDogYXR0ckJvb2xWYWx1ZSh0aGlzLnByZXNlcnZlRnJhZ21lbnQpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIF9fZGVjb3JhdGUkMShbXG4gICAgICAgICAgICBjb3JlLkhvc3RCaW5kaW5nKCdhdHRyLnRhcmdldCcpLCBjb3JlLklucHV0KCksXG4gICAgICAgICAgICBfX21ldGFkYXRhJDEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgICAgIF0sIFJvdXRlckxpbmtXaXRoSHJlZi5wcm90b3R5cGUsIFwidGFyZ2V0XCIsIHZvaWQgMCk7XG4gICAgICAgIF9fZGVjb3JhdGUkMShbXG4gICAgICAgICAgICBjb3JlLklucHV0KCksXG4gICAgICAgICAgICBfX21ldGFkYXRhJDEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgICAgIF0sIFJvdXRlckxpbmtXaXRoSHJlZi5wcm90b3R5cGUsIFwicXVlcnlQYXJhbXNcIiwgdm9pZCAwKTtcbiAgICAgICAgX19kZWNvcmF0ZSQxKFtcbiAgICAgICAgICAgIGNvcmUuSW5wdXQoKSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEkMShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICAgICAgXSwgUm91dGVyTGlua1dpdGhIcmVmLnByb3RvdHlwZSwgXCJmcmFnbWVudFwiLCB2b2lkIDApO1xuICAgICAgICBfX2RlY29yYXRlJDEoW1xuICAgICAgICAgICAgY29yZS5JbnB1dCgpLFxuICAgICAgICAgICAgX19tZXRhZGF0YSQxKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgICAgICBdLCBSb3V0ZXJMaW5rV2l0aEhyZWYucHJvdG90eXBlLCBcInF1ZXJ5UGFyYW1zSGFuZGxpbmdcIiwgdm9pZCAwKTtcbiAgICAgICAgX19kZWNvcmF0ZSQxKFtcbiAgICAgICAgICAgIGNvcmUuSW5wdXQoKSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEkMShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgICAgIF0sIFJvdXRlckxpbmtXaXRoSHJlZi5wcm90b3R5cGUsIFwicHJlc2VydmVGcmFnbWVudFwiLCB2b2lkIDApO1xuICAgICAgICBfX2RlY29yYXRlJDEoW1xuICAgICAgICAgICAgY29yZS5JbnB1dCgpLFxuICAgICAgICAgICAgX19tZXRhZGF0YSQxKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICAgICAgXSwgUm91dGVyTGlua1dpdGhIcmVmLnByb3RvdHlwZSwgXCJza2lwTG9jYXRpb25DaGFuZ2VcIiwgdm9pZCAwKTtcbiAgICAgICAgX19kZWNvcmF0ZSQxKFtcbiAgICAgICAgICAgIGNvcmUuSW5wdXQoKSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEkMShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgICAgIF0sIFJvdXRlckxpbmtXaXRoSHJlZi5wcm90b3R5cGUsIFwicmVwbGFjZVVybFwiLCB2b2lkIDApO1xuICAgICAgICBfX2RlY29yYXRlJDEoW1xuICAgICAgICAgICAgY29yZS5JbnB1dCgpLFxuICAgICAgICAgICAgX19tZXRhZGF0YSQxKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgICAgICBdLCBSb3V0ZXJMaW5rV2l0aEhyZWYucHJvdG90eXBlLCBcInN0YXRlXCIsIHZvaWQgMCk7XG4gICAgICAgIF9fZGVjb3JhdGUkMShbXG4gICAgICAgICAgICBjb3JlLkhvc3RCaW5kaW5nKCksXG4gICAgICAgICAgICBfX21ldGFkYXRhJDEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgICAgIF0sIFJvdXRlckxpbmtXaXRoSHJlZi5wcm90b3R5cGUsIFwiaHJlZlwiLCB2b2lkIDApO1xuICAgICAgICBfX2RlY29yYXRlJDEoW1xuICAgICAgICAgICAgY29yZS5JbnB1dCgpLFxuICAgICAgICAgICAgX19tZXRhZGF0YSQxKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEkMShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuICAgICAgICBdLCBSb3V0ZXJMaW5rV2l0aEhyZWYucHJvdG90eXBlLCBcInJvdXRlckxpbmtcIiwgbnVsbCk7XG4gICAgICAgIF9fZGVjb3JhdGUkMShbXG4gICAgICAgICAgICBjb3JlLklucHV0KCksXG4gICAgICAgICAgICBfX21ldGFkYXRhJDEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEkMShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbiAgICAgICAgXSwgUm91dGVyTGlua1dpdGhIcmVmLnByb3RvdHlwZSwgXCJwcmVzZXJ2ZVF1ZXJ5UGFyYW1zXCIsIG51bGwpO1xuICAgICAgICBfX2RlY29yYXRlJDEoW1xuICAgICAgICAgICAgY29yZS5Ib3N0TGlzdGVuZXIoJ2NsaWNrJywgWyckZXZlbnQuYnV0dG9uJywgJyRldmVudC5jdHJsS2V5JywgJyRldmVudC5tZXRhS2V5JywgJyRldmVudC5zaGlmdEtleSddKSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEkMShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEkMShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOdW1iZXIsIEJvb2xlYW4sIEJvb2xlYW4sIEJvb2xlYW5dKSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEkMShcImRlc2lnbjpyZXR1cm50eXBlXCIsIEJvb2xlYW4pXG4gICAgICAgIF0sIFJvdXRlckxpbmtXaXRoSHJlZi5wcm90b3R5cGUsIFwib25DbGlja1wiLCBudWxsKTtcbiAgICAgICAgUm91dGVyTGlua1dpdGhIcmVmID0gX19kZWNvcmF0ZSQxKFtcbiAgICAgICAgICAgIGNvcmUuRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdhW3JvdXRlckxpbmtdLGFyZWFbcm91dGVyTGlua10nIH0pLFxuICAgICAgICAgICAgX19tZXRhZGF0YSQxKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1JvdXRlciwgQWN0aXZhdGVkUm91dGUsXG4gICAgICAgICAgICAgICAgY29tbW9uLkxvY2F0aW9uU3RyYXRlZ3ldKVxuICAgICAgICBdLCBSb3V0ZXJMaW5rV2l0aEhyZWYpO1xuICAgICAgICByZXR1cm4gUm91dGVyTGlua1dpdGhIcmVmO1xuICAgIH0oKSk7XG4gICAgZnVuY3Rpb24gYXR0ckJvb2xWYWx1ZShzKSB7XG4gICAgICAgIHJldHVybiBzID09PSAnJyB8fCAhIXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBMZXRzIHlvdSBhZGQgYSBDU1MgY2xhc3MgdG8gYW4gZWxlbWVudCB3aGVuIHRoZSBsaW5rJ3Mgcm91dGUgYmVjb21lcyBhY3RpdmUuXG4gICAgICpcbiAgICAgKiBUaGlzIGRpcmVjdGl2ZSBsZXRzIHlvdSBhZGQgYSBDU1MgY2xhc3MgdG8gYW4gZWxlbWVudCB3aGVuIHRoZSBsaW5rJ3Mgcm91dGVcbiAgICAgKiBiZWNvbWVzIGFjdGl2ZS5cbiAgICAgKlxuICAgICAqIENvbnNpZGVyIHRoZSBmb2xsb3dpbmcgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIDxhIHJvdXRlckxpbms9XCIvdXNlci9ib2JcIiByb3V0ZXJMaW5rQWN0aXZlPVwiYWN0aXZlLWxpbmtcIj5Cb2I8L2E+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBXaGVuIHRoZSB1cmwgaXMgZWl0aGVyICcvdXNlcicgb3IgJy91c2VyL2JvYicsIHRoZSBhY3RpdmUtbGluayBjbGFzcyB3aWxsXG4gICAgICogYmUgYWRkZWQgdG8gdGhlIGBhYCB0YWcuIElmIHRoZSB1cmwgY2hhbmdlcywgdGhlIGNsYXNzIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gc2V0IG1vcmUgdGhhbiBvbmUgY2xhc3MsIGFzIGZvbGxvd3M6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiA8YSByb3V0ZXJMaW5rPVwiL3VzZXIvYm9iXCIgcm91dGVyTGlua0FjdGl2ZT1cImNsYXNzMSBjbGFzczJcIj5Cb2I8L2E+XG4gICAgICogPGEgcm91dGVyTGluaz1cIi91c2VyL2JvYlwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cIlsnY2xhc3MxJywgJ2NsYXNzMiddXCI+Qm9iPC9hPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogWW91IGNhbiBjb25maWd1cmUgUm91dGVyTGlua0FjdGl2ZSBieSBwYXNzaW5nIGBleGFjdDogdHJ1ZWAuIFRoaXMgd2lsbCBhZGQgdGhlIGNsYXNzZXNcbiAgICAgKiBvbmx5IHdoZW4gdGhlIHVybCBtYXRjaGVzIHRoZSBsaW5rIGV4YWN0bHkuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiA8YSByb3V0ZXJMaW5rPVwiL3VzZXIvYm9iXCIgcm91dGVyTGlua0FjdGl2ZT1cImFjdGl2ZS1saW5rXCIgW3JvdXRlckxpbmtBY3RpdmVPcHRpb25zXT1cIntleGFjdDpcbiAgICAgKiB0cnVlfVwiPkJvYjwvYT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFlvdSBjYW4gYXNzaWduIHRoZSBSb3V0ZXJMaW5rQWN0aXZlIGluc3RhbmNlIHRvIGEgdGVtcGxhdGUgdmFyaWFibGUgYW5kIGRpcmVjdGx5IGNoZWNrXG4gICAgICogdGhlIGBpc0FjdGl2ZWAgc3RhdHVzLlxuICAgICAqIGBgYFxuICAgICAqIDxhIHJvdXRlckxpbms9XCIvdXNlci9ib2JcIiByb3V0ZXJMaW5rQWN0aXZlICNybGE9XCJyb3V0ZXJMaW5rQWN0aXZlXCI+XG4gICAgICogICBCb2Ige3sgcmxhLmlzQWN0aXZlID8gJyhhbHJlYWR5IG9wZW4pJyA6ICcnfX1cbiAgICAgKiA8L2E+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBGaW5hbGx5LCB5b3UgY2FuIGFwcGx5IHRoZSBSb3V0ZXJMaW5rQWN0aXZlIGRpcmVjdGl2ZSB0byBhbiBhbmNlc3RvciBvZiBhIFJvdXRlckxpbmsuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiA8ZGl2IHJvdXRlckxpbmtBY3RpdmU9XCJhY3RpdmUtbGlua1wiIFtyb3V0ZXJMaW5rQWN0aXZlT3B0aW9uc109XCJ7ZXhhY3Q6IHRydWV9XCI+XG4gICAgICogICA8YSByb3V0ZXJMaW5rPVwiL3VzZXIvamltXCI+SmltPC9hPlxuICAgICAqICAgPGEgcm91dGVyTGluaz1cIi91c2VyL2JvYlwiPkJvYjwvYT5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCBzZXQgdGhlIGFjdGl2ZS1saW5rIGNsYXNzIG9uIHRoZSBkaXYgdGFnIGlmIHRoZSB1cmwgaXMgZWl0aGVyICcvdXNlci9qaW0nIG9yXG4gICAgICogJy91c2VyL2JvYicuXG4gICAgICpcbiAgICAgKiBAbmdNb2R1bGUgUm91dGVyTW9kdWxlXG4gICAgICpcbiAgICAgKiBAcHVibGljQXBpXG4gICAgICovXG4gICAgdmFyIFJvdXRlckxpbmtBY3RpdmUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJvdXRlckxpbmtBY3RpdmUocm91dGVyLCBlbGVtZW50LCByZW5kZXJlciwgbGluaywgbGlua1dpdGhIcmVmKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5saW5rID0gbGluaztcbiAgICAgICAgICAgIHRoaXMubGlua1dpdGhIcmVmID0gbGlua1dpdGhIcmVmO1xuICAgICAgICAgICAgdGhpcy5jbGFzc2VzID0gW107XG4gICAgICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnJvdXRlckxpbmtBY3RpdmVPcHRpb25zID0geyBleGFjdDogZmFsc2UgfTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gcm91dGVyLmV2ZW50cy5zdWJzY3JpYmUoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocyBpbnN0YW5jZW9mIE5hdmlnYXRpb25FbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgUm91dGVyTGlua0FjdGl2ZS5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMubGlua3MuY2hhbmdlcy5zdWJzY3JpYmUoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF90aGlzLnVwZGF0ZSgpOyB9KTtcbiAgICAgICAgICAgIHRoaXMubGlua3NXaXRoSHJlZnMuY2hhbmdlcy5zdWJzY3JpYmUoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF90aGlzLnVwZGF0ZSgpOyB9KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb3V0ZXJMaW5rQWN0aXZlLnByb3RvdHlwZSwgXCJyb3V0ZXJMaW5rQWN0aXZlXCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NlcyA9IEFycmF5LmlzQXJyYXkoZGF0YSkgPyBkYXRhIDogZGF0YS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NlcyA9IGNsYXNzZXMuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiAhIWM7IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIFJvdXRlckxpbmtBY3RpdmUucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHsgdGhpcy51cGRhdGUoKTsgfTtcbiAgICAgICAgUm91dGVyTGlua0FjdGl2ZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7IH07XG4gICAgICAgIFJvdXRlckxpbmtBY3RpdmUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIXRoaXMubGlua3MgfHwgIXRoaXMubGlua3NXaXRoSHJlZnMgfHwgIXRoaXMucm91dGVyLm5hdmlnYXRlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGFzQWN0aXZlTGlua3MgPSBfdGhpcy5oYXNBY3RpdmVMaW5rcygpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc0FjdGl2ZSAhPT0gaGFzQWN0aXZlTGlua3MpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXNBY3RpdmUgPSBoYXNBY3RpdmVMaW5rcztcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzQWN0aXZlTGlua3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhfdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3MoX3RoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCBjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFJvdXRlckxpbmtBY3RpdmUucHJvdG90eXBlLmlzTGlua0FjdGl2ZSA9IGZ1bmN0aW9uIChyb3V0ZXIpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm91dGVyLmlzQWN0aXZlKGxpbmsudXJsVHJlZSwgX3RoaXMucm91dGVyTGlua0FjdGl2ZU9wdGlvbnMuZXhhY3QpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgUm91dGVyTGlua0FjdGl2ZS5wcm90b3R5cGUuaGFzQWN0aXZlTGlua3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaXNBY3RpdmVDaGVja0ZuID0gdGhpcy5pc0xpbmtBY3RpdmUodGhpcy5yb3V0ZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGluayAmJiBpc0FjdGl2ZUNoZWNrRm4odGhpcy5saW5rKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMubGlua1dpdGhIcmVmICYmIGlzQWN0aXZlQ2hlY2tGbih0aGlzLmxpbmtXaXRoSHJlZikgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmtzLnNvbWUoaXNBY3RpdmVDaGVja0ZuKSB8fCB0aGlzLmxpbmtzV2l0aEhyZWZzLnNvbWUoaXNBY3RpdmVDaGVja0ZuKTtcbiAgICAgICAgfTtcbiAgICAgICAgX19kZWNvcmF0ZSQxKFtcbiAgICAgICAgICAgIGNvcmUuQ29udGVudENoaWxkcmVuKFJvdXRlckxpbmssIHsgZGVzY2VuZGFudHM6IHRydWUgfSksXG4gICAgICAgICAgICBfX21ldGFkYXRhJDEoXCJkZXNpZ246dHlwZVwiLCBjb3JlLlF1ZXJ5TGlzdClcbiAgICAgICAgXSwgUm91dGVyTGlua0FjdGl2ZS5wcm90b3R5cGUsIFwibGlua3NcIiwgdm9pZCAwKTtcbiAgICAgICAgX19kZWNvcmF0ZSQxKFtcbiAgICAgICAgICAgIGNvcmUuQ29udGVudENoaWxkcmVuKFJvdXRlckxpbmtXaXRoSHJlZiwgeyBkZXNjZW5kYW50czogdHJ1ZSB9KSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEkMShcImRlc2lnbjp0eXBlXCIsIGNvcmUuUXVlcnlMaXN0KVxuICAgICAgICBdLCBSb3V0ZXJMaW5rQWN0aXZlLnByb3RvdHlwZSwgXCJsaW5rc1dpdGhIcmVmc1wiLCB2b2lkIDApO1xuICAgICAgICBfX2RlY29yYXRlJDEoW1xuICAgICAgICAgICAgY29yZS5JbnB1dCgpLFxuICAgICAgICAgICAgX19tZXRhZGF0YSQxKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgICAgICBdLCBSb3V0ZXJMaW5rQWN0aXZlLnByb3RvdHlwZSwgXCJyb3V0ZXJMaW5rQWN0aXZlT3B0aW9uc1wiLCB2b2lkIDApO1xuICAgICAgICBfX2RlY29yYXRlJDEoW1xuICAgICAgICAgICAgY29yZS5JbnB1dCgpLFxuICAgICAgICAgICAgX19tZXRhZGF0YSQxKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEkMShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuICAgICAgICBdLCBSb3V0ZXJMaW5rQWN0aXZlLnByb3RvdHlwZSwgXCJyb3V0ZXJMaW5rQWN0aXZlXCIsIG51bGwpO1xuICAgICAgICBSb3V0ZXJMaW5rQWN0aXZlID0gX19kZWNvcmF0ZSQxKFtcbiAgICAgICAgICAgIGNvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tyb3V0ZXJMaW5rQWN0aXZlXScsXG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdyb3V0ZXJMaW5rQWN0aXZlJyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgX19wYXJhbSQxKDMsIGNvcmUuT3B0aW9uYWwoKSksXG4gICAgICAgICAgICBfX3BhcmFtJDEoNCwgY29yZS5PcHRpb25hbCgpKSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEkMShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtSb3V0ZXIsIGNvcmUuRWxlbWVudFJlZiwgY29yZS5SZW5kZXJlcjIsXG4gICAgICAgICAgICAgICAgUm91dGVyTGluayxcbiAgICAgICAgICAgICAgICBSb3V0ZXJMaW5rV2l0aEhyZWZdKVxuICAgICAgICBdLCBSb3V0ZXJMaW5rQWN0aXZlKTtcbiAgICAgICAgcmV0dXJuIFJvdXRlckxpbmtBY3RpdmU7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBTdG9yZSBjb250ZXh0dWFsIGluZm9ybWF0aW9uIGFib3V0IGEgYFJvdXRlck91dGxldGBcbiAgICAgKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgT3V0bGV0Q29udGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gT3V0bGV0Q29udGV4dCgpIHtcbiAgICAgICAgICAgIHRoaXMub3V0bGV0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucm91dGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IENoaWxkcmVuT3V0bGV0Q29udGV4dHMoKTtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoUmVmID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT3V0bGV0Q29udGV4dDtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFN0b3JlIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNoaWxkcmVuICg9IG5lc3RlZCkgYFJvdXRlck91dGxldGBcbiAgICAgKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgQ2hpbGRyZW5PdXRsZXRDb250ZXh0cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ2hpbGRyZW5PdXRsZXRDb250ZXh0cygpIHtcbiAgICAgICAgICAgIC8vIGNvbnRleHRzIGZvciBjaGlsZCBvdXRsZXRzLCBieSBuYW1lLlxuICAgICAgICAgICAgdGhpcy5jb250ZXh0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICAvKiogQ2FsbGVkIHdoZW4gYSBgUm91dGVyT3V0bGV0YCBkaXJlY3RpdmUgaXMgaW5zdGFudGlhdGVkICovXG4gICAgICAgIENoaWxkcmVuT3V0bGV0Q29udGV4dHMucHJvdG90eXBlLm9uQ2hpbGRPdXRsZXRDcmVhdGVkID0gZnVuY3Rpb24gKGNoaWxkTmFtZSwgb3V0bGV0KSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuZ2V0T3JDcmVhdGVDb250ZXh0KGNoaWxkTmFtZSk7XG4gICAgICAgICAgICBjb250ZXh0Lm91dGxldCA9IG91dGxldDtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dHMuc2V0KGNoaWxkTmFtZSwgY29udGV4dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgd2hlbiBhIGBSb3V0ZXJPdXRsZXRgIGRpcmVjdGl2ZSBpcyBkZXN0cm95ZWQuXG4gICAgICAgICAqIFdlIG5lZWQgdG8ga2VlcCB0aGUgY29udGV4dCBhcyB0aGUgb3V0bGV0IGNvdWxkIGJlIGRlc3Ryb3llZCBpbnNpZGUgYSBOZ0lmIGFuZCBtaWdodCBiZVxuICAgICAgICAgKiByZS1jcmVhdGVkIGxhdGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgQ2hpbGRyZW5PdXRsZXRDb250ZXh0cy5wcm90b3R5cGUub25DaGlsZE91dGxldERlc3Ryb3llZCA9IGZ1bmN0aW9uIChjaGlsZE5hbWUpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KGNoaWxkTmFtZSk7XG4gICAgICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQub3V0bGV0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb3JyZXNwb25kaW5nIHJvdXRlIGlzIGRlYWN0aXZhdGVkIGR1cmluZyBuYXZpZ2F0aW9uLlxuICAgICAgICAgKiBCZWNhdXNlIHRoZSBjb21wb25lbnQgZ2V0IGRlc3Ryb3llZCwgYWxsIGNoaWxkcmVuIG91dGxldCBhcmUgZGVzdHJveWVkLlxuICAgICAgICAgKi9cbiAgICAgICAgQ2hpbGRyZW5PdXRsZXRDb250ZXh0cy5wcm90b3R5cGUub25PdXRsZXREZWFjdGl2YXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0cyA9IHRoaXMuY29udGV4dHM7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHRzO1xuICAgICAgICB9O1xuICAgICAgICBDaGlsZHJlbk91dGxldENvbnRleHRzLnByb3RvdHlwZS5vbk91dGxldFJlQXR0YWNoZWQgPSBmdW5jdGlvbiAoY29udGV4dHMpIHsgdGhpcy5jb250ZXh0cyA9IGNvbnRleHRzOyB9O1xuICAgICAgICBDaGlsZHJlbk91dGxldENvbnRleHRzLnByb3RvdHlwZS5nZXRPckNyZWF0ZUNvbnRleHQgPSBmdW5jdGlvbiAoY2hpbGROYW1lKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dChjaGlsZE5hbWUpO1xuICAgICAgICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgY29udGV4dCA9IG5ldyBPdXRsZXRDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0cy5zZXQoY2hpbGROYW1lLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgICAgICB9O1xuICAgICAgICBDaGlsZHJlbk91dGxldENvbnRleHRzLnByb3RvdHlwZS5nZXRDb250ZXh0ID0gZnVuY3Rpb24gKGNoaWxkTmFtZSkgeyByZXR1cm4gdGhpcy5jb250ZXh0cy5nZXQoY2hpbGROYW1lKSB8fCBudWxsOyB9O1xuICAgICAgICByZXR1cm4gQ2hpbGRyZW5PdXRsZXRDb250ZXh0cztcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogQWN0cyBhcyBhIHBsYWNlaG9sZGVyIHRoYXQgQW5ndWxhciBkeW5hbWljYWxseSBmaWxscyBiYXNlZCBvbiB0aGUgY3VycmVudCByb3V0ZXIgc3RhdGUuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiA8cm91dGVyLW91dGxldD48L3JvdXRlci1vdXRsZXQ+XG4gICAgICogPHJvdXRlci1vdXRsZXQgbmFtZT0nbGVmdCc+PC9yb3V0ZXItb3V0bGV0PlxuICAgICAqIDxyb3V0ZXItb3V0bGV0IG5hbWU9J3JpZ2h0Jz48L3JvdXRlci1vdXRsZXQ+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBBIHJvdXRlciBvdXRsZXQgd2lsbCBlbWl0IGFuIGFjdGl2YXRlIGV2ZW50IGFueSB0aW1lIGEgbmV3IGNvbXBvbmVudCBpcyBiZWluZyBpbnN0YW50aWF0ZWQsXG4gICAgICogYW5kIGEgZGVhY3RpdmF0ZSBldmVudCB3aGVuIGl0IGlzIGJlaW5nIGRlc3Ryb3llZC5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIDxyb3V0ZXItb3V0bGV0XG4gICAgICogICAoYWN0aXZhdGUpPSdvbkFjdGl2YXRlKCRldmVudCknXG4gICAgICogICAoZGVhY3RpdmF0ZSk9J29uRGVhY3RpdmF0ZSgkZXZlbnQpJz48L3JvdXRlci1vdXRsZXQ+XG4gICAgICogYGBgXG4gICAgICogQG5nTW9kdWxlIFJvdXRlck1vZHVsZVxuICAgICAqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBSb3V0ZXJPdXRsZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJvdXRlck91dGxldChwYXJlbnRDb250ZXh0cywgbG9jYXRpb24sIHJlc29sdmVyLCBuYW1lLCBjaGFuZ2VEZXRlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRDb250ZXh0cyA9IHBhcmVudENvbnRleHRzO1xuICAgICAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlciA9IHJlc29sdmVyO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvciA9IGNoYW5nZURldGVjdG9yO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZhdGVkUm91dGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZUV2ZW50cyA9IG5ldyBjb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlRXZlbnRzID0gbmV3IGNvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lIHx8IFBSSU1BUllfT1VUTEVUO1xuICAgICAgICAgICAgcGFyZW50Q29udGV4dHMub25DaGlsZE91dGxldENyZWF0ZWQodGhpcy5uYW1lLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBSb3V0ZXJPdXRsZXQucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB0aGlzLnBhcmVudENvbnRleHRzLm9uQ2hpbGRPdXRsZXREZXN0cm95ZWQodGhpcy5uYW1lKTsgfTtcbiAgICAgICAgUm91dGVyT3V0bGV0LnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hY3RpdmF0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb3V0bGV0IHdhcyBub3QgaW5zdGFudGlhdGVkIGF0IHRoZSB0aW1lIHRoZSByb3V0ZSBnb3QgYWN0aXZhdGVkIHdlIG5lZWQgdG8gcG9wdWxhdGVcbiAgICAgICAgICAgICAgICAvLyB0aGUgb3V0bGV0IHdoZW4gaXQgaXMgaW5pdGlhbGl6ZWQgKGllIGluc2lkZSBhIE5nSWYpXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLnBhcmVudENvbnRleHRzLmdldENvbnRleHQodGhpcy5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0LnJvdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LmF0dGFjaFJlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYGF0dGFjaFJlZmAgaXMgcG9wdWxhdGVkIHdoZW4gdGhlcmUgaXMgYW4gZXhpc3RpbmcgY29tcG9uZW50IHRvIG1vdW50XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaChjb250ZXh0LmF0dGFjaFJlZiwgY29udGV4dC5yb3V0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgdGhlIGNvbXBvbmVudCBkZWZpbmVkIGluIHRoZSBjb25maWd1cmF0aW9uIGlzIGNyZWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVXaXRoKGNvbnRleHQucm91dGUsIGNvbnRleHQucmVzb2x2ZXIgfHwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb3V0ZXJPdXRsZXQucHJvdG90eXBlLCBcImlzQWN0aXZhdGVkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gISF0aGlzLmFjdGl2YXRlZDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb3V0ZXJPdXRsZXQucHJvdG90eXBlLCBcImNvbXBvbmVudFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYWN0aXZhdGVkKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ091dGxldCBpcyBub3QgYWN0aXZhdGVkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZhdGVkLmluc3RhbmNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb3V0ZXJPdXRsZXQucHJvdG90eXBlLCBcImFjdGl2YXRlZFJvdXRlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5hY3RpdmF0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3V0bGV0IGlzIG5vdCBhY3RpdmF0ZWQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZhdGVkUm91dGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJvdXRlck91dGxldC5wcm90b3R5cGUsIFwiYWN0aXZhdGVkUm91dGVEYXRhXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hY3RpdmF0ZWRSb3V0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZhdGVkUm91dGUuc25hcHNob3QuZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgd2hlbiB0aGUgYFJvdXRlUmV1c2VTdHJhdGVneWAgaW5zdHJ1Y3RzIHRvIGRldGFjaCB0aGUgc3VidHJlZVxuICAgICAgICAgKi9cbiAgICAgICAgUm91dGVyT3V0bGV0LnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWN0aXZhdGVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3V0bGV0IGlzIG5vdCBhY3RpdmF0ZWQnKTtcbiAgICAgICAgICAgIHRoaXMubG9jYXRpb24uZGV0YWNoKCk7XG4gICAgICAgICAgICB2YXIgY21wID0gdGhpcy5hY3RpdmF0ZWQ7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmF0ZWRSb3V0ZSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gY21wO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIHdoZW4gdGhlIGBSb3V0ZVJldXNlU3RyYXRlZ3lgIGluc3RydWN0cyB0byByZS1hdHRhY2ggYSBwcmV2aW91c2x5IGRldGFjaGVkIHN1YnRyZWVcbiAgICAgICAgICovXG4gICAgICAgIFJvdXRlck91dGxldC5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKHJlZiwgYWN0aXZhdGVkUm91dGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVkID0gcmVmO1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZhdGVkUm91dGUgPSBhY3RpdmF0ZWRSb3V0ZTtcbiAgICAgICAgICAgIHRoaXMubG9jYXRpb24uaW5zZXJ0KHJlZi5ob3N0Vmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIFJvdXRlck91dGxldC5wcm90b3R5cGUuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2YXRlZCkge1xuICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZWQuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmF0ZWRSb3V0ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlRXZlbnRzLmVtaXQoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFJvdXRlck91dGxldC5wcm90b3R5cGUuYWN0aXZhdGVXaXRoID0gZnVuY3Rpb24gKGFjdGl2YXRlZFJvdXRlLCByZXNvbHZlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmF0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhY3RpdmF0ZSBhbiBhbHJlYWR5IGFjdGl2YXRlZCBvdXRsZXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2FjdGl2YXRlZFJvdXRlID0gYWN0aXZhdGVkUm91dGU7XG4gICAgICAgICAgICB2YXIgc25hcHNob3QgPSBhY3RpdmF0ZWRSb3V0ZS5fZnV0dXJlU25hcHNob3Q7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gc25hcHNob3Qucm91dGVDb25maWcuY29tcG9uZW50O1xuICAgICAgICAgICAgcmVzb2x2ZXIgPSByZXNvbHZlciB8fCB0aGlzLnJlc29sdmVyO1xuICAgICAgICAgICAgdmFyIGZhY3RvcnkgPSByZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShjb21wb25lbnQpO1xuICAgICAgICAgICAgdmFyIGNoaWxkQ29udGV4dHMgPSB0aGlzLnBhcmVudENvbnRleHRzLmdldE9yQ3JlYXRlQ29udGV4dCh0aGlzLm5hbWUpLmNoaWxkcmVuO1xuICAgICAgICAgICAgdmFyIGluamVjdG9yID0gbmV3IE91dGxldEluamVjdG9yKGFjdGl2YXRlZFJvdXRlLCBjaGlsZENvbnRleHRzLCB0aGlzLmxvY2F0aW9uLmluamVjdG9yKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVkID0gdGhpcy5sb2NhdGlvbi5jcmVhdGVDb21wb25lbnQoZmFjdG9yeSwgdGhpcy5sb2NhdGlvbi5sZW5ndGgsIGluamVjdG9yKTtcbiAgICAgICAgICAgIC8vIENhbGxpbmcgYG1hcmtGb3JDaGVja2AgdG8gbWFrZSBzdXJlIHdlIHdpbGwgcnVuIHRoZSBjaGFuZ2UgZGV0ZWN0aW9uIHdoZW4gdGhlXG4gICAgICAgICAgICAvLyBgUm91dGVyT3V0bGV0YCBpcyBpbnNpZGUgYSBgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoYCBjb21wb25lbnQuXG4gICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZUV2ZW50cy5lbWl0KHRoaXMuYWN0aXZhdGVkLmluc3RhbmNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgX19kZWNvcmF0ZSQxKFtcbiAgICAgICAgICAgIGNvcmUuT3V0cHV0KCdhY3RpdmF0ZScpLFxuICAgICAgICAgICAgX19tZXRhZGF0YSQxKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgICAgICBdLCBSb3V0ZXJPdXRsZXQucHJvdG90eXBlLCBcImFjdGl2YXRlRXZlbnRzXCIsIHZvaWQgMCk7XG4gICAgICAgIF9fZGVjb3JhdGUkMShbXG4gICAgICAgICAgICBjb3JlLk91dHB1dCgnZGVhY3RpdmF0ZScpLFxuICAgICAgICAgICAgX19tZXRhZGF0YSQxKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgICAgICBdLCBSb3V0ZXJPdXRsZXQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVFdmVudHNcIiwgdm9pZCAwKTtcbiAgICAgICAgUm91dGVyT3V0bGV0ID0gX19kZWNvcmF0ZSQxKFtcbiAgICAgICAgICAgIGNvcmUuRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdyb3V0ZXItb3V0bGV0JywgZXhwb3J0QXM6ICdvdXRsZXQnIH0pLFxuICAgICAgICAgICAgX19wYXJhbSQxKDMsIGNvcmUuQXR0cmlidXRlKCduYW1lJykpLFxuICAgICAgICAgICAgX19tZXRhZGF0YSQxKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NoaWxkcmVuT3V0bGV0Q29udGV4dHMsIGNvcmUuVmlld0NvbnRhaW5lclJlZixcbiAgICAgICAgICAgICAgICBjb3JlLkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgU3RyaW5nLCBjb3JlLkNoYW5nZURldGVjdG9yUmVmXSlcbiAgICAgICAgXSwgUm91dGVyT3V0bGV0KTtcbiAgICAgICAgcmV0dXJuIFJvdXRlck91dGxldDtcbiAgICB9KCkpO1xuICAgIHZhciBPdXRsZXRJbmplY3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gT3V0bGV0SW5qZWN0b3Iocm91dGUsIGNoaWxkQ29udGV4dHMsIHBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5yb3V0ZSA9IHJvdXRlO1xuICAgICAgICAgICAgdGhpcy5jaGlsZENvbnRleHRzID0gY2hpbGRDb250ZXh0cztcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIE91dGxldEluamVjdG9yLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodG9rZW4sIG5vdEZvdW5kVmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gQWN0aXZhdGVkUm91dGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yb3V0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gQ2hpbGRyZW5PdXRsZXRDb250ZXh0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkQ29udGV4dHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0KHRva2VuLCBub3RGb3VuZFZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE91dGxldEluamVjdG9yO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAqQGxpY2Vuc2VcbiAgICAqQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgKlxuICAgICpVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICpmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgKi9cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFByb3ZpZGVzIGEgcHJlbG9hZGluZyBzdHJhdGVneS5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgUHJlbG9hZGluZ1N0cmF0ZWd5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBQcmVsb2FkaW5nU3RyYXRlZ3koKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByZWxvYWRpbmdTdHJhdGVneTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogUHJvdmlkZXMgYSBwcmVsb2FkaW5nIHN0cmF0ZWd5IHRoYXQgcHJlbG9hZHMgYWxsIG1vZHVsZXMgYXMgcXVpY2tseSBhcyBwb3NzaWJsZS5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIFJvdXRlTW9kdWxlLmZvclJvb3QoUk9VVEVTLCB7cHJlbG9hZGluZ1N0cmF0ZWd5OiBQcmVsb2FkQWxsTW9kdWxlc30pXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcHVibGljQXBpXG4gICAgICovXG4gICAgdmFyIFByZWxvYWRBbGxNb2R1bGVzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBQcmVsb2FkQWxsTW9kdWxlcygpIHtcbiAgICAgICAgfVxuICAgICAgICBQcmVsb2FkQWxsTW9kdWxlcy5wcm90b3R5cGUucHJlbG9hZCA9IGZ1bmN0aW9uIChyb3V0ZSwgZm4pIHtcbiAgICAgICAgICAgIHJldHVybiBmbigpLnBpcGUob3BlcmF0b3JzLmNhdGNoRXJyb3IoZnVuY3Rpb24gKCkgeyByZXR1cm4gcnhqcy5vZihudWxsKTsgfSkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUHJlbG9hZEFsbE1vZHVsZXM7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFByb3ZpZGVzIGEgcHJlbG9hZGluZyBzdHJhdGVneSB0aGF0IGRvZXMgbm90IHByZWxvYWQgYW55IG1vZHVsZXMuXG4gICAgICpcbiAgICAgKiBUaGlzIHN0cmF0ZWd5IGlzIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgTm9QcmVsb2FkaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOb1ByZWxvYWRpbmcoKSB7XG4gICAgICAgIH1cbiAgICAgICAgTm9QcmVsb2FkaW5nLnByb3RvdHlwZS5wcmVsb2FkID0gZnVuY3Rpb24gKHJvdXRlLCBmbikgeyByZXR1cm4gcnhqcy5vZihudWxsKTsgfTtcbiAgICAgICAgcmV0dXJuIE5vUHJlbG9hZGluZztcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFRoZSBwcmVsb2FkZXIgb3B0aW1pc3RpY2FsbHkgbG9hZHMgYWxsIHJvdXRlciBjb25maWd1cmF0aW9ucyB0b1xuICAgICAqIG1ha2UgbmF2aWdhdGlvbnMgaW50byBsYXppbHktbG9hZGVkIHNlY3Rpb25zIG9mIHRoZSBhcHBsaWNhdGlvbiBmYXN0ZXIuXG4gICAgICpcbiAgICAgKiBUaGUgcHJlbG9hZGVyIHJ1bnMgaW4gdGhlIGJhY2tncm91bmQuIFdoZW4gdGhlIHJvdXRlciBib290c3RyYXBzLCB0aGUgcHJlbG9hZGVyXG4gICAgICogc3RhcnRzIGxpc3RlbmluZyB0byBhbGwgbmF2aWdhdGlvbiBldmVudHMuIEFmdGVyIGV2ZXJ5IHN1Y2ggZXZlbnQsIHRoZSBwcmVsb2FkZXJcbiAgICAgKiB3aWxsIGNoZWNrIGlmIGFueSBjb25maWd1cmF0aW9ucyBjYW4gYmUgbG9hZGVkIGxhemlseS5cbiAgICAgKlxuICAgICAqIElmIGEgcm91dGUgaXMgcHJvdGVjdGVkIGJ5IGBjYW5Mb2FkYCBndWFyZHMsIHRoZSBwcmVsb2FkZWQgd2lsbCBub3QgbG9hZCBpdC5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgUm91dGVyUHJlbG9hZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSb3V0ZXJQcmVsb2FkZXIocm91dGVyLCBtb2R1bGVMb2FkZXIsIGNvbXBpbGVyLCBpbmplY3RvciwgcHJlbG9hZGluZ1N0cmF0ZWd5KSB7XG4gICAgICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcbiAgICAgICAgICAgIHRoaXMucHJlbG9hZGluZ1N0cmF0ZWd5ID0gcHJlbG9hZGluZ1N0cmF0ZWd5O1xuICAgICAgICAgICAgdmFyIG9uU3RhcnRMb2FkID0gZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHJvdXRlci50cmlnZ2VyRXZlbnQobmV3IFJvdXRlQ29uZmlnTG9hZFN0YXJ0KHIpKTsgfTtcbiAgICAgICAgICAgIHZhciBvbkVuZExvYWQgPSBmdW5jdGlvbiAocikgeyByZXR1cm4gcm91dGVyLnRyaWdnZXJFdmVudChuZXcgUm91dGVDb25maWdMb2FkRW5kKHIpKTsgfTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJvdXRlckNvbmZpZ0xvYWRlcihtb2R1bGVMb2FkZXIsIGNvbXBpbGVyLCBvblN0YXJ0TG9hZCwgb25FbmRMb2FkKTtcbiAgICAgICAgfVxuICAgICAgICBSb3V0ZXJQcmVsb2FkZXIucHJvdG90eXBlLnNldFVwUHJlbG9hZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9XG4gICAgICAgICAgICAgICAgdGhpcy5yb3V0ZXIuZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIC5waXBlKG9wZXJhdG9ycy5maWx0ZXIoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uRW5kOyB9KSwgb3BlcmF0b3JzLmNvbmNhdE1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5wcmVsb2FkKCk7IH0pKVxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFJvdXRlclByZWxvYWRlci5wcm90b3R5cGUucHJlbG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuZ01vZHVsZSA9IHRoaXMuaW5qZWN0b3IuZ2V0KGNvcmUuTmdNb2R1bGVSZWYpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JvdXRlcyhuZ01vZHVsZSwgdGhpcy5yb3V0ZXIuY29uZmlnKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVE9ETyhqYXNvbmFkZW4pOiBUaGlzIGNsYXNzIHJlbGllcyBvbiBjb2RlIGV4dGVybmFsIHRvIHRoZSBjbGFzcyB0byBjYWxsIHNldFVwUHJlbG9hZGluZy4gSWZcbiAgICAgICAgLy8gdGhpcyBoYXNuJ3QgYmVlbiBkb25lLCBuZ09uRGVzdHJveSB3aWxsIGZhaWwgYXMgdGhpcy5zdWJzY3JpcHRpb24gd2lsbCBiZSB1bmRlZmluZWQuIFRoaXNcbiAgICAgICAgLy8gc2hvdWxkIGJlIHJlZmFjdG9yZWQuXG4gICAgICAgIFJvdXRlclByZWxvYWRlci5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7IH07XG4gICAgICAgIFJvdXRlclByZWxvYWRlci5wcm90b3R5cGUucHJvY2Vzc1JvdXRlcyA9IGZ1bmN0aW9uIChuZ01vZHVsZSwgcm91dGVzKSB7XG4gICAgICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcm91dGVzXzEgPSBfX3ZhbHVlcyhyb3V0ZXMpLCByb3V0ZXNfMV8xID0gcm91dGVzXzEubmV4dCgpOyAhcm91dGVzXzFfMS5kb25lOyByb3V0ZXNfMV8xID0gcm91dGVzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByb3V0ZSA9IHJvdXRlc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGFscmVhZHkgaGF2ZSB0aGUgY29uZmlnIGxvYWRlZCwganVzdCByZWN1cnNlXG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3V0ZS5sb2FkQ2hpbGRyZW4gJiYgIXJvdXRlLmNhbkxvYWQgJiYgcm91dGUuX2xvYWRlZENvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkQ29uZmlnID0gcm91dGUuX2xvYWRlZENvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKHRoaXMucHJvY2Vzc1JvdXRlcyhjaGlsZENvbmZpZy5tb2R1bGUsIGNoaWxkQ29uZmlnLnJvdXRlcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gY29uZmlnIGxvYWRlZCwgZmV0Y2ggdGhlIGNvbmZpZ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJvdXRlLmxvYWRDaGlsZHJlbiAmJiAhcm91dGUuY2FuTG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2godGhpcy5wcmVsb2FkQ29uZmlnKG5nTW9kdWxlLCByb3V0ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVjdXJzZSBpbnRvIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocm91dGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKHRoaXMucHJvY2Vzc1JvdXRlcyhuZ01vZHVsZSwgcm91dGUuY2hpbGRyZW4pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocm91dGVzXzFfMSAmJiAhcm91dGVzXzFfMS5kb25lICYmIChfYSA9IHJvdXRlc18xLnJldHVybikpIF9hLmNhbGwocm91dGVzXzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnhqcy5mcm9tKHJlcykucGlwZShvcGVyYXRvcnMubWVyZ2VBbGwoKSwgb3BlcmF0b3JzLm1hcChmdW5jdGlvbiAoXykgeyByZXR1cm4gdm9pZCAwOyB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIFJvdXRlclByZWxvYWRlci5wcm90b3R5cGUucHJlbG9hZENvbmZpZyA9IGZ1bmN0aW9uIChuZ01vZHVsZSwgcm91dGUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmVsb2FkaW5nU3RyYXRlZ3kucHJlbG9hZChyb3V0ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBsb2FkZWQkID0gX3RoaXMubG9hZGVyLmxvYWQobmdNb2R1bGUuaW5qZWN0b3IsIHJvdXRlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZGVkJC5waXBlKG9wZXJhdG9ycy5tZXJnZU1hcChmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlLl9sb2FkZWRDb25maWcgPSBjb25maWc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm9jZXNzUm91dGVzKGNvbmZpZy5tb2R1bGUsIGNvbmZpZy5yb3V0ZXMpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBSb3V0ZXJQcmVsb2FkZXIgPSBfX2RlY29yYXRlJDEoW1xuICAgICAgICAgICAgY29yZS5JbmplY3RhYmxlKCksXG4gICAgICAgICAgICBfX21ldGFkYXRhJDEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbUm91dGVyLCBjb3JlLk5nTW9kdWxlRmFjdG9yeUxvYWRlciwgY29yZS5Db21waWxlcixcbiAgICAgICAgICAgICAgICBjb3JlLkluamVjdG9yLCBQcmVsb2FkaW5nU3RyYXRlZ3ldKVxuICAgICAgICBdLCBSb3V0ZXJQcmVsb2FkZXIpO1xuICAgICAgICByZXR1cm4gUm91dGVyUHJlbG9hZGVyO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIFJvdXRlclNjcm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSb3V0ZXJTY3JvbGxlcihyb3V0ZXIsIFxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqLyB2aWV3cG9ydFNjcm9sbGVyLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0U2Nyb2xsZXIgPSB2aWV3cG9ydFNjcm9sbGVyO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgIHRoaXMubGFzdElkID0gMDtcbiAgICAgICAgICAgIHRoaXMubGFzdFNvdXJjZSA9ICdpbXBlcmF0aXZlJztcbiAgICAgICAgICAgIHRoaXMucmVzdG9yZWRJZCA9IDA7XG4gICAgICAgICAgICB0aGlzLnN0b3JlID0ge307XG4gICAgICAgICAgICAvLyBEZWZhdWx0IGJvdGggb3B0aW9ucyB0byAnZGlzYWJsZWQnXG4gICAgICAgICAgICBvcHRpb25zLnNjcm9sbFBvc2l0aW9uUmVzdG9yYXRpb24gPSBvcHRpb25zLnNjcm9sbFBvc2l0aW9uUmVzdG9yYXRpb24gfHwgJ2Rpc2FibGVkJztcbiAgICAgICAgICAgIG9wdGlvbnMuYW5jaG9yU2Nyb2xsaW5nID0gb3B0aW9ucy5hbmNob3JTY3JvbGxpbmcgfHwgJ2Rpc2FibGVkJztcbiAgICAgICAgfVxuICAgICAgICBSb3V0ZXJTY3JvbGxlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHdlIHdhbnQgdG8gZGlzYWJsZSB0aGUgYXV0b21hdGljIHNjcm9sbGluZyBiZWNhdXNlIGhhdmluZyB0d28gcGxhY2VzXG4gICAgICAgICAgICAvLyByZXNwb25zaWJsZSBmb3Igc2Nyb2xsaW5nIHJlc3VsdHMgcmFjZSBjb25kaXRpb25zLCBlc3BlY2lhbGx5IGdpdmVuXG4gICAgICAgICAgICAvLyB0aGF0IGJyb3dzZXIgZG9uJ3QgaW1wbGVtZW50IHRoaXMgYmVoYXZpb3IgY29uc2lzdGVudGx5XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNjcm9sbFBvc2l0aW9uUmVzdG9yYXRpb24gIT09ICdkaXNhYmxlZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0U2Nyb2xsZXIuc2V0SGlzdG9yeVNjcm9sbFJlc3RvcmF0aW9uKCdtYW51YWwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucm91dGVyRXZlbnRzU3Vic2NyaXB0aW9uID0gdGhpcy5jcmVhdGVTY3JvbGxFdmVudHMoKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRXZlbnRzU3Vic2NyaXB0aW9uID0gdGhpcy5jb25zdW1lU2Nyb2xsRXZlbnRzKCk7XG4gICAgICAgIH07XG4gICAgICAgIFJvdXRlclNjcm9sbGVyLnByb3RvdHlwZS5jcmVhdGVTY3JvbGxFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm91dGVyLmV2ZW50cy5zdWJzY3JpYmUoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIE5hdmlnYXRpb25TdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IHN0YWJsZSBuYXZpZ2F0aW9ucy5cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RvcmVbX3RoaXMubGFzdElkXSA9IF90aGlzLnZpZXdwb3J0U2Nyb2xsZXIuZ2V0U2Nyb2xsUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubGFzdFNvdXJjZSA9IGUubmF2aWdhdGlvblRyaWdnZXI7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc3RvcmVkSWQgPSBlLnJlc3RvcmVkU3RhdGUgPyBlLnJlc3RvcmVkU3RhdGUubmF2aWdhdGlvbklkIDogMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZSBpbnN0YW5jZW9mIE5hdmlnYXRpb25FbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubGFzdElkID0gZS5pZDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2NoZWR1bGVTY3JvbGxFdmVudChlLCBfdGhpcy5yb3V0ZXIucGFyc2VVcmwoZS51cmxBZnRlclJlZGlyZWN0cykuZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBSb3V0ZXJTY3JvbGxlci5wcm90b3R5cGUuY29uc3VtZVNjcm9sbEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3V0ZXIuZXZlbnRzLnN1YnNjcmliZShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBTY3JvbGwpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gYSBwb3BzdGF0ZSBldmVudC4gVGhlIHBvcCBzdGF0ZSBldmVudCB3aWxsIGFsd2F5cyBpZ25vcmUgYW5jaG9yIHNjcm9sbGluZy5cbiAgICAgICAgICAgICAgICBpZiAoZS5wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5zY3JvbGxQb3NpdGlvblJlc3RvcmF0aW9uID09PSAndG9wJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudmlld3BvcnRTY3JvbGxlci5zY3JvbGxUb1Bvc2l0aW9uKFswLCAwXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMub3B0aW9ucy5zY3JvbGxQb3NpdGlvblJlc3RvcmF0aW9uID09PSAnZW5hYmxlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnZpZXdwb3J0U2Nyb2xsZXIuc2Nyb2xsVG9Qb3NpdGlvbihlLnBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpbXBlcmF0aXZlIG5hdmlnYXRpb24gXCJmb3J3YXJkXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmFuY2hvciAmJiBfdGhpcy5vcHRpb25zLmFuY2hvclNjcm9sbGluZyA9PT0gJ2VuYWJsZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy52aWV3cG9ydFNjcm9sbGVyLnNjcm9sbFRvQW5jaG9yKGUuYW5jaG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5vcHRpb25zLnNjcm9sbFBvc2l0aW9uUmVzdG9yYXRpb24gIT09ICdkaXNhYmxlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnZpZXdwb3J0U2Nyb2xsZXIuc2Nyb2xsVG9Qb3NpdGlvbihbMCwgMF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFJvdXRlclNjcm9sbGVyLnByb3RvdHlwZS5zY2hlZHVsZVNjcm9sbEV2ZW50ID0gZnVuY3Rpb24gKHJvdXRlckV2ZW50LCBhbmNob3IpIHtcbiAgICAgICAgICAgIHRoaXMucm91dGVyLnRyaWdnZXJFdmVudChuZXcgU2Nyb2xsKHJvdXRlckV2ZW50LCB0aGlzLmxhc3RTb3VyY2UgPT09ICdwb3BzdGF0ZScgPyB0aGlzLnN0b3JlW3RoaXMucmVzdG9yZWRJZF0gOiBudWxsLCBhbmNob3IpKTtcbiAgICAgICAgfTtcbiAgICAgICAgUm91dGVyU2Nyb2xsZXIucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucm91dGVyRXZlbnRzU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3V0ZXJFdmVudHNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnNjcm9sbEV2ZW50c1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRXZlbnRzU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSb3V0ZXJTY3JvbGxlcjtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogQ29udGFpbnMgYSBsaXN0IG9mIGRpcmVjdGl2ZXNcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgdmFyIFJPVVRFUl9ESVJFQ1RJVkVTID0gW1JvdXRlck91dGxldCwgUm91dGVyTGluaywgUm91dGVyTGlua1dpdGhIcmVmLCBSb3V0ZXJMaW5rQWN0aXZlLCDJtUVtcHR5T3V0bGV0Q29tcG9uZW50XTtcbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIElzIHVzZWQgaW4gREkgdG8gY29uZmlndXJlIHRoZSByb3V0ZXIuXG4gICAgICpcbiAgICAgKiBAcHVibGljQXBpXG4gICAgICovXG4gICAgdmFyIFJPVVRFUl9DT05GSUdVUkFUSU9OID0gbmV3IGNvcmUuSW5qZWN0aW9uVG9rZW4oJ1JPVVRFUl9DT05GSUdVUkFUSU9OJyk7XG4gICAgLyoqXG4gICAgICogQGRvY3NOb3RSZXF1aXJlZFxuICAgICAqL1xuICAgIHZhciBST1VURVJfRk9SUk9PVF9HVUFSRCA9IG5ldyBjb3JlLkluamVjdGlvblRva2VuKCdST1VURVJfRk9SUk9PVF9HVUFSRCcpO1xuICAgIHZhciDJtTAgPSB7IGVuYWJsZVRyYWNpbmc6IGZhbHNlIH07XG4gICAgdmFyIFJPVVRFUl9QUk9WSURFUlMgPSBbXG4gICAgICAgIGNvbW1vbi5Mb2NhdGlvbixcbiAgICAgICAgeyBwcm92aWRlOiBVcmxTZXJpYWxpemVyLCB1c2VDbGFzczogRGVmYXVsdFVybFNlcmlhbGl6ZXIgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgcHJvdmlkZTogUm91dGVyLFxuICAgICAgICAgICAgdXNlRmFjdG9yeTogc2V0dXBSb3V0ZXIsXG4gICAgICAgICAgICBkZXBzOiBbXG4gICAgICAgICAgICAgICAgY29yZS5BcHBsaWNhdGlvblJlZiwgVXJsU2VyaWFsaXplciwgQ2hpbGRyZW5PdXRsZXRDb250ZXh0cywgY29tbW9uLkxvY2F0aW9uLCBjb3JlLkluamVjdG9yLFxuICAgICAgICAgICAgICAgIGNvcmUuTmdNb2R1bGVGYWN0b3J5TG9hZGVyLCBjb3JlLkNvbXBpbGVyLCBST1VURVMsIFJPVVRFUl9DT05GSUdVUkFUSU9OLFxuICAgICAgICAgICAgICAgIFtVcmxIYW5kbGluZ1N0cmF0ZWd5LCBuZXcgY29yZS5PcHRpb25hbCgpXSwgW1JvdXRlUmV1c2VTdHJhdGVneSwgbmV3IGNvcmUuT3B0aW9uYWwoKV1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgQ2hpbGRyZW5PdXRsZXRDb250ZXh0cyxcbiAgICAgICAgeyBwcm92aWRlOiBBY3RpdmF0ZWRSb3V0ZSwgdXNlRmFjdG9yeTogcm9vdFJvdXRlLCBkZXBzOiBbUm91dGVyXSB9LFxuICAgICAgICB7IHByb3ZpZGU6IGNvcmUuTmdNb2R1bGVGYWN0b3J5TG9hZGVyLCB1c2VDbGFzczogY29yZS5TeXN0ZW1Kc05nTW9kdWxlTG9hZGVyIH0sXG4gICAgICAgIFJvdXRlclByZWxvYWRlcixcbiAgICAgICAgTm9QcmVsb2FkaW5nLFxuICAgICAgICBQcmVsb2FkQWxsTW9kdWxlcyxcbiAgICAgICAgeyBwcm92aWRlOiBST1VURVJfQ09ORklHVVJBVElPTiwgdXNlVmFsdWU6IMm1MCB9LFxuICAgIF07XG4gICAgZnVuY3Rpb24gcm91dGVyTmdQcm9iZVRva2VuKCkge1xuICAgICAgICByZXR1cm4gbmV3IGNvcmUuTmdQcm9iZVRva2VuKCdSb3V0ZXInLCBSb3V0ZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqXG4gICAgICogUm91dGVyTW9kdWxlIGNhbiBiZSBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lczogb25jZSBwZXIgbGF6aWx5LWxvYWRlZCBidW5kbGUuXG4gICAgICogU2luY2UgdGhlIHJvdXRlciBkZWFscyB3aXRoIGEgZ2xvYmFsIHNoYXJlZCByZXNvdXJjZS0tbG9jYXRpb24sIHdlIGNhbm5vdCBoYXZlXG4gICAgICogbW9yZSB0aGFuIG9uZSByb3V0ZXIgc2VydmljZSBhY3RpdmUuXG4gICAgICpcbiAgICAgKiBUaGF0IGlzIHdoeSB0aGVyZSBhcmUgdHdvIHdheXMgdG8gY3JlYXRlIHRoZSBtb2R1bGU6IGBSb3V0ZXJNb2R1bGUuZm9yUm9vdGAgYW5kXG4gICAgICogYFJvdXRlck1vZHVsZS5mb3JDaGlsZGAuXG4gICAgICpcbiAgICAgKiAqIGBmb3JSb290YCBjcmVhdGVzIGEgbW9kdWxlIHRoYXQgY29udGFpbnMgYWxsIHRoZSBkaXJlY3RpdmVzLCB0aGUgZ2l2ZW4gcm91dGVzLCBhbmQgdGhlIHJvdXRlclxuICAgICAqICAgc2VydmljZSBpdHNlbGYuXG4gICAgICogKiBgZm9yQ2hpbGRgIGNyZWF0ZXMgYSBtb2R1bGUgdGhhdCBjb250YWlucyBhbGwgdGhlIGRpcmVjdGl2ZXMgYW5kIHRoZSBnaXZlbiByb3V0ZXMsIGJ1dCBkb2VzIG5vdFxuICAgICAqICAgaW5jbHVkZSB0aGUgcm91dGVyIHNlcnZpY2UuXG4gICAgICpcbiAgICAgKiBXaGVuIHJlZ2lzdGVyZWQgYXQgdGhlIHJvb3QsIHRoZSBtb2R1bGUgc2hvdWxkIGJlIHVzZWQgYXMgZm9sbG93c1xuICAgICAqXG4gICAgICogYGBgXG4gICAgICogQE5nTW9kdWxlKHtcbiAgICAgKiAgIGltcG9ydHM6IFtSb3V0ZXJNb2R1bGUuZm9yUm9vdChST1VURVMpXVxuICAgICAqIH0pXG4gICAgICogY2xhc3MgTXlOZ01vZHVsZSB7fVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogRm9yIHN1Ym1vZHVsZXMgYW5kIGxhenkgbG9hZGVkIHN1Ym1vZHVsZXMgdGhlIG1vZHVsZSBzaG91bGQgYmUgdXNlZCBhcyBmb2xsb3dzOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogQE5nTW9kdWxlKHtcbiAgICAgKiAgIGltcG9ydHM6IFtSb3V0ZXJNb2R1bGUuZm9yQ2hpbGQoUk9VVEVTKV1cbiAgICAgKiB9KVxuICAgICAqIGNsYXNzIE15TmdNb2R1bGUge31cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogQWRkcyByb3V0ZXIgZGlyZWN0aXZlcyBhbmQgcHJvdmlkZXJzLlxuICAgICAqXG4gICAgICogTWFuYWdpbmcgc3RhdGUgdHJhbnNpdGlvbnMgaXMgb25lIG9mIHRoZSBoYXJkZXN0IHBhcnRzIG9mIGJ1aWxkaW5nIGFwcGxpY2F0aW9ucy4gVGhpcyBpc1xuICAgICAqIGVzcGVjaWFsbHkgdHJ1ZSBvbiB0aGUgd2ViLCB3aGVyZSB5b3UgYWxzbyBuZWVkIHRvIGVuc3VyZSB0aGF0IHRoZSBzdGF0ZSBpcyByZWZsZWN0ZWQgaW4gdGhlIFVSTC5cbiAgICAgKiBJbiBhZGRpdGlvbiwgd2Ugb2Z0ZW4gd2FudCB0byBzcGxpdCBhcHBsaWNhdGlvbnMgaW50byBtdWx0aXBsZSBidW5kbGVzIGFuZCBsb2FkIHRoZW0gb24gZGVtYW5kLlxuICAgICAqIERvaW5nIHRoaXMgdHJhbnNwYXJlbnRseSBpcyBub3QgdHJpdmlhbC5cbiAgICAgKlxuICAgICAqIFRoZSBBbmd1bGFyIHJvdXRlciBzb2x2ZXMgdGhlc2UgcHJvYmxlbXMuIFVzaW5nIHRoZSByb3V0ZXIsIHlvdSBjYW4gZGVjbGFyYXRpdmVseSBzcGVjaWZ5XG4gICAgICogYXBwbGljYXRpb24gc3RhdGVzLCBtYW5hZ2Ugc3RhdGUgdHJhbnNpdGlvbnMgd2hpbGUgdGFraW5nIGNhcmUgb2YgdGhlIFVSTCwgYW5kIGxvYWQgYnVuZGxlcyBvblxuICAgICAqIGRlbWFuZC5cbiAgICAgKlxuICAgICAqIFtSZWFkIHRoaXMgZGV2ZWxvcGVyIGd1aWRlXShodHRwczovL2FuZ3VsYXIuaW8vZG9jcy90cy9sYXRlc3QvZ3VpZGUvcm91dGVyLmh0bWwpIHRvIGdldCBhblxuICAgICAqIG92ZXJ2aWV3IG9mIGhvdyB0aGUgcm91dGVyIHNob3VsZCBiZSB1c2VkLlxuICAgICAqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBSb3V0ZXJNb2R1bGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIE5vdGU6IFdlIGFyZSBpbmplY3RpbmcgdGhlIFJvdXRlciBzbyBpdCBnZXRzIGNyZWF0ZWQgZWFnZXJseS4uLlxuICAgICAgICBmdW5jdGlvbiBSb3V0ZXJNb2R1bGUoZ3VhcmQsIHJvdXRlcikge1xuICAgICAgICB9XG4gICAgICAgIFJvdXRlck1vZHVsZV8xID0gUm91dGVyTW9kdWxlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG1vZHVsZSB3aXRoIGFsbCB0aGUgcm91dGVyIHByb3ZpZGVycyBhbmQgZGlyZWN0aXZlcy4gSXQgYWxzbyBvcHRpb25hbGx5IHNldHMgdXAgYW5cbiAgICAgICAgICogYXBwbGljYXRpb24gbGlzdGVuZXIgdG8gcGVyZm9ybSBhbiBpbml0aWFsIG5hdmlnYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIENvbmZpZ3VyYXRpb24gT3B0aW9uczpcbiAgICAgICAgICpcbiAgICAgICAgICogKiBgZW5hYmxlVHJhY2luZ2AgVG9nZ2xlcyB3aGV0aGVyIHRoZSByb3V0ZXIgc2hvdWxkIGxvZyBhbGwgbmF2aWdhdGlvbiBldmVudHMgdG8gdGhlIGNvbnNvbGUuXG4gICAgICAgICAqICogYHVzZUhhc2hgIEVuYWJsZXMgdGhlIGxvY2F0aW9uIHN0cmF0ZWd5IHRoYXQgdXNlcyB0aGUgVVJMIGZyYWdtZW50IGluc3RlYWQgb2YgdGhlIGhpc3RvcnlcbiAgICAgICAgICogQVBJLlxuICAgICAgICAgKiAqIGBpbml0aWFsTmF2aWdhdGlvbmAgRGlzYWJsZXMgdGhlIGluaXRpYWwgbmF2aWdhdGlvbi5cbiAgICAgICAgICogKiBgZXJyb3JIYW5kbGVyYCBEZWZpbmVzIGEgY3VzdG9tIGVycm9yIGhhbmRsZXIgZm9yIGZhaWxlZCBuYXZpZ2F0aW9ucy5cbiAgICAgICAgICogKiBgcHJlbG9hZGluZ1N0cmF0ZWd5YCBDb25maWd1cmVzIGEgcHJlbG9hZGluZyBzdHJhdGVneS4gU2VlIGBQcmVsb2FkQWxsTW9kdWxlc2AuXG4gICAgICAgICAqICogYG9uU2FtZVVybE5hdmlnYXRpb25gIERlZmluZSB3aGF0IHRoZSByb3V0ZXIgc2hvdWxkIGRvIGlmIGl0IHJlY2VpdmVzIGEgbmF2aWdhdGlvbiByZXF1ZXN0IHRvXG4gICAgICAgICAqIHRoZSBjdXJyZW50IFVSTC5cbiAgICAgICAgICogKiBgc2Nyb2xsUG9zaXRpb25SZXN0b3JhdGlvbmAgQ29uZmlndXJlcyBpZiB0aGUgc2Nyb2xsIHBvc2l0aW9uIG5lZWRzIHRvIGJlIHJlc3RvcmVkIHdoZW5cbiAgICAgICAgICogbmF2aWdhdGluZyBiYWNrLlxuICAgICAgICAgKiAqIGBhbmNob3JTY3JvbGxpbmdgIENvbmZpZ3VyZXMgaWYgdGhlIHJvdXRlciBzaG91bGQgc2Nyb2xsIHRvIHRoZSBlbGVtZW50IHdoZW4gdGhlIHVybCBoYXMgYVxuICAgICAgICAgKiBmcmFnbWVudC5cbiAgICAgICAgICogKiBgc2Nyb2xsT2Zmc2V0YCBDb25maWd1cmVzIHRoZSBzY3JvbGwgb2Zmc2V0IHRoZSByb3V0ZXIgd2lsbCB1c2Ugd2hlbiBzY3JvbGxpbmcgdG8gYW4gZWxlbWVudC5cbiAgICAgICAgICogKiBgcGFyYW1zSW5oZXJpdGFuY2VTdHJhdGVneWAgRGVmaW5lcyBob3cgdGhlIHJvdXRlciBtZXJnZXMgcGFyYW1zLCBkYXRhIGFuZCByZXNvbHZlZCBkYXRhIGZyb21cbiAgICAgICAgICogcGFyZW50IHRvIGNoaWxkIHJvdXRlcy5cbiAgICAgICAgICogKiBgbWFsZm9ybWVkVXJpRXJyb3JIYW5kbGVyYCBEZWZpbmVzIGEgY3VzdG9tIG1hbGZvcm1lZCB1cmkgZXJyb3IgaGFuZGxlciBmdW5jdGlvbi4gVGhpc1xuICAgICAgICAgKiBoYW5kbGVyIGlzIGludm9rZWQgd2hlbiBlbmNvZGVkVVJJIGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVyIHNlcXVlbmNlcy5cbiAgICAgICAgICogKiBgdXJsVXBkYXRlU3RyYXRlZ3lgIERlZmluZXMgd2hlbiB0aGUgcm91dGVyIHVwZGF0ZXMgdGhlIGJyb3dzZXIgVVJMLiBUaGUgZGVmYXVsdCBiZWhhdmlvciBpc1xuICAgICAgICAgKiB0byB1cGRhdGUgYWZ0ZXIgc3VjY2Vzc2Z1bCBuYXZpZ2F0aW9uLlxuICAgICAgICAgKiAqIGByZWxhdGl2ZUxpbmtSZXNvbHV0aW9uYCBFbmFibGVzIHRoZSBjb3JyZWN0IHJlbGF0aXZlIGxpbmsgcmVzb2x1dGlvbiBpbiBjb21wb25lbnRzIHdpdGhcbiAgICAgICAgICogZW1wdHkgcGF0aHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBgRXh0cmFPcHRpb25zYCBmb3IgbW9yZSBkZXRhaWxzIGFib3V0IHRoZSBhYm92ZSBvcHRpb25zLlxuICAgICAgICAqL1xuICAgICAgICBSb3V0ZXJNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uIChyb3V0ZXMsIGNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuZ01vZHVsZTogUm91dGVyTW9kdWxlXzEsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIFJPVVRFUl9QUk9WSURFUlMsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVSb3V0ZXMocm91dGVzKSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogUk9VVEVSX0ZPUlJPT1RfR1VBUkQsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VGYWN0b3J5OiBwcm92aWRlRm9yUm9vdEd1YXJkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwczogW1tSb3V0ZXIsIG5ldyBjb3JlLk9wdGlvbmFsKCksIG5ldyBjb3JlLlNraXBTZWxmKCldXVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IFJPVVRFUl9DT05GSUdVUkFUSU9OLCB1c2VWYWx1ZTogY29uZmlnID8gY29uZmlnIDoge30gfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogY29tbW9uLkxvY2F0aW9uU3RyYXRlZ3ksXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VGYWN0b3J5OiBwcm92aWRlTG9jYXRpb25TdHJhdGVneSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tb24uUGxhdGZvcm1Mb2NhdGlvbiwgW25ldyBjb3JlLkluamVjdChjb21tb24uQVBQX0JBU0VfSFJFRiksIG5ldyBjb3JlLk9wdGlvbmFsKCldLCBST1VURVJfQ09ORklHVVJBVElPTlxuICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBSb3V0ZXJTY3JvbGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUZhY3Rvcnk6IGNyZWF0ZVJvdXRlclNjcm9sbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwczogW1JvdXRlciwgY29tbW9uLlZpZXdwb3J0U2Nyb2xsZXIsIFJPVVRFUl9DT05GSUdVUkFUSU9OXVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBQcmVsb2FkaW5nU3RyYXRlZ3ksXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogY29uZmlnICYmIGNvbmZpZy5wcmVsb2FkaW5nU3RyYXRlZ3kgPyBjb25maWcucHJlbG9hZGluZ1N0cmF0ZWd5IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBOb1ByZWxvYWRpbmdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBjb3JlLk5nUHJvYmVUb2tlbiwgbXVsdGk6IHRydWUsIHVzZUZhY3Rvcnk6IHJvdXRlck5nUHJvYmVUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlUm91dGVySW5pdGlhbGl6ZXIoKSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBtb2R1bGUgd2l0aCBhbGwgdGhlIHJvdXRlciBkaXJlY3RpdmVzIGFuZCBhIHByb3ZpZGVyIHJlZ2lzdGVyaW5nIHJvdXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIFJvdXRlck1vZHVsZS5mb3JDaGlsZCA9IGZ1bmN0aW9uIChyb3V0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG5nTW9kdWxlOiBSb3V0ZXJNb2R1bGVfMSwgcHJvdmlkZXJzOiBbcHJvdmlkZVJvdXRlcyhyb3V0ZXMpXSB9O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgUm91dGVyTW9kdWxlXzE7XG4gICAgICAgIFJvdXRlck1vZHVsZSA9IFJvdXRlck1vZHVsZV8xID0gX19kZWNvcmF0ZSQxKFtcbiAgICAgICAgICAgIGNvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogUk9VVEVSX0RJUkVDVElWRVMsXG4gICAgICAgICAgICAgICAgZXhwb3J0czogUk9VVEVSX0RJUkVDVElWRVMsXG4gICAgICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBbybVFbXB0eU91dGxldENvbXBvbmVudF1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgX19wYXJhbSQxKDAsIGNvcmUuT3B0aW9uYWwoKSksIF9fcGFyYW0kMSgwLCBjb3JlLkluamVjdChST1VURVJfRk9SUk9PVF9HVUFSRCkpLCBfX3BhcmFtJDEoMSwgY29yZS5PcHRpb25hbCgpKSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEkMShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3QsIFJvdXRlcl0pXG4gICAgICAgIF0sIFJvdXRlck1vZHVsZSk7XG4gICAgICAgIHJldHVybiBSb3V0ZXJNb2R1bGU7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBjcmVhdGVSb3V0ZXJTY3JvbGxlcihyb3V0ZXIsIHZpZXdwb3J0U2Nyb2xsZXIsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnLnNjcm9sbE9mZnNldCkge1xuICAgICAgICAgICAgdmlld3BvcnRTY3JvbGxlci5zZXRPZmZzZXQoY29uZmlnLnNjcm9sbE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSb3V0ZXJTY3JvbGxlcihyb3V0ZXIsIHZpZXdwb3J0U2Nyb2xsZXIsIGNvbmZpZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb3ZpZGVMb2NhdGlvblN0cmF0ZWd5KHBsYXRmb3JtTG9jYXRpb25TdHJhdGVneSwgYmFzZUhyZWYsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnMudXNlSGFzaCA/IG5ldyBjb21tb24uSGFzaExvY2F0aW9uU3RyYXRlZ3kocGxhdGZvcm1Mb2NhdGlvblN0cmF0ZWd5LCBiYXNlSHJlZikgOlxuICAgICAgICAgICAgbmV3IGNvbW1vbi5QYXRoTG9jYXRpb25TdHJhdGVneShwbGF0Zm9ybUxvY2F0aW9uU3RyYXRlZ3ksIGJhc2VIcmVmKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvdmlkZUZvclJvb3RHdWFyZChyb3V0ZXIpIHtcbiAgICAgICAgaWYgKHJvdXRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm91dGVyTW9kdWxlLmZvclJvb3QoKSBjYWxsZWQgdHdpY2UuIExhenkgbG9hZGVkIG1vZHVsZXMgc2hvdWxkIHVzZSBSb3V0ZXJNb2R1bGUuZm9yQ2hpbGQoKSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ2d1YXJkZWQnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFJlZ2lzdGVycyByb3V0ZXMuXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBATmdNb2R1bGUoe1xuICAgICAqICAgaW1wb3J0czogW1JvdXRlck1vZHVsZS5mb3JDaGlsZChST1VURVMpXSxcbiAgICAgKiAgIHByb3ZpZGVyczogW3Byb3ZpZGVSb3V0ZXMoRVhUUkFfUk9VVEVTKV1cbiAgICAgKiB9KVxuICAgICAqIGNsYXNzIE15TmdNb2R1bGUge31cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm92aWRlUm91dGVzKHJvdXRlcykge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm92aWRlOiBjb3JlLkFOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFMsIG11bHRpOiB0cnVlLCB1c2VWYWx1ZTogcm91dGVzIH0sXG4gICAgICAgICAgICB7IHByb3ZpZGU6IFJPVVRFUywgbXVsdGk6IHRydWUsIHVzZVZhbHVlOiByb3V0ZXMgfSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0dXBSb3V0ZXIocmVmLCB1cmxTZXJpYWxpemVyLCBjb250ZXh0cywgbG9jYXRpb24sIGluamVjdG9yLCBsb2FkZXIsIGNvbXBpbGVyLCBjb25maWcsIG9wdHMsIHVybEhhbmRsaW5nU3RyYXRlZ3ksIHJvdXRlUmV1c2VTdHJhdGVneSkge1xuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7IG9wdHMgPSB7fTsgfVxuICAgICAgICB2YXIgcm91dGVyID0gbmV3IFJvdXRlcihudWxsLCB1cmxTZXJpYWxpemVyLCBjb250ZXh0cywgbG9jYXRpb24sIGluamVjdG9yLCBsb2FkZXIsIGNvbXBpbGVyLCBmbGF0dGVuKGNvbmZpZykpO1xuICAgICAgICBpZiAodXJsSGFuZGxpbmdTdHJhdGVneSkge1xuICAgICAgICAgICAgcm91dGVyLnVybEhhbmRsaW5nU3RyYXRlZ3kgPSB1cmxIYW5kbGluZ1N0cmF0ZWd5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3V0ZVJldXNlU3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIHJvdXRlci5yb3V0ZVJldXNlU3RyYXRlZ3kgPSByb3V0ZVJldXNlU3RyYXRlZ3k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuZXJyb3JIYW5kbGVyKSB7XG4gICAgICAgICAgICByb3V0ZXIuZXJyb3JIYW5kbGVyID0gb3B0cy5lcnJvckhhbmRsZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMubWFsZm9ybWVkVXJpRXJyb3JIYW5kbGVyKSB7XG4gICAgICAgICAgICByb3V0ZXIubWFsZm9ybWVkVXJpRXJyb3JIYW5kbGVyID0gb3B0cy5tYWxmb3JtZWRVcmlFcnJvckhhbmRsZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuZW5hYmxlVHJhY2luZykge1xuICAgICAgICAgICAgdmFyIGRvbV8xID0gcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCk7XG4gICAgICAgICAgICByb3V0ZXIuZXZlbnRzLnN1YnNjcmliZShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGRvbV8xLmxvZ0dyb3VwKFwiUm91dGVyIEV2ZW50OiBcIiArIGUuY29uc3RydWN0b3IubmFtZSk7XG4gICAgICAgICAgICAgICAgZG9tXzEubG9nKGUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgZG9tXzEubG9nKGUpO1xuICAgICAgICAgICAgICAgIGRvbV8xLmxvZ0dyb3VwRW5kKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5vblNhbWVVcmxOYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgICByb3V0ZXIub25TYW1lVXJsTmF2aWdhdGlvbiA9IG9wdHMub25TYW1lVXJsTmF2aWdhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5wYXJhbXNJbmhlcml0YW5jZVN0cmF0ZWd5KSB7XG4gICAgICAgICAgICByb3V0ZXIucGFyYW1zSW5oZXJpdGFuY2VTdHJhdGVneSA9IG9wdHMucGFyYW1zSW5oZXJpdGFuY2VTdHJhdGVneTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy51cmxVcGRhdGVTdHJhdGVneSkge1xuICAgICAgICAgICAgcm91dGVyLnVybFVwZGF0ZVN0cmF0ZWd5ID0gb3B0cy51cmxVcGRhdGVTdHJhdGVneTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5yZWxhdGl2ZUxpbmtSZXNvbHV0aW9uKSB7XG4gICAgICAgICAgICByb3V0ZXIucmVsYXRpdmVMaW5rUmVzb2x1dGlvbiA9IG9wdHMucmVsYXRpdmVMaW5rUmVzb2x1dGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm91dGVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiByb290Um91dGUocm91dGVyKSB7XG4gICAgICAgIHJldHVybiByb3V0ZXIucm91dGVyU3RhdGUucm9vdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG8gaW5pdGlhbGl6ZSB0aGUgcm91dGVyIHByb3Blcmx5IHdlIG5lZWQgdG8gZG8gaW4gdHdvIHN0ZXBzOlxuICAgICAqXG4gICAgICogV2UgbmVlZCB0byBzdGFydCB0aGUgbmF2aWdhdGlvbiBpbiBhIEFQUF9JTklUSUFMSVpFUiB0byBibG9jayB0aGUgYm9vdHN0cmFwIGlmXG4gICAgICogYSByZXNvbHZlciBvciBhIGd1YXJkcyBleGVjdXRlcyBhc3luY2hyb25vdXNseS4gU2Vjb25kLCB3ZSBuZWVkIHRvIGFjdHVhbGx5IHJ1blxuICAgICAqIGFjdGl2YXRpb24gaW4gYSBCT09UU1RSQVBfTElTVEVORVIuIFdlIHV0aWxpemUgdGhlIGFmdGVyUHJlYWN0aXZhdGlvblxuICAgICAqIGhvb2sgcHJvdmlkZWQgYnkgdGhlIHJvdXRlciB0byBkbyB0aGF0LlxuICAgICAqXG4gICAgICogVGhlIHJvdXRlciBuYXZpZ2F0aW9uIHN0YXJ0cywgcmVhY2hlcyB0aGUgcG9pbnQgd2hlbiBwcmVhY3RpdmF0aW9uIGlzIGRvbmUsIGFuZCB0aGVuXG4gICAgICogcGF1c2VzLiBJdCB3YWl0cyBmb3IgdGhlIGhvb2sgdG8gYmUgcmVzb2x2ZWQuIFdlIHRoZW4gcmVzb2x2ZSBpdCBvbmx5IGluIGEgYm9vdHN0cmFwIGxpc3RlbmVyLlxuICAgICAqL1xuICAgIHZhciBSb3V0ZXJJbml0aWFsaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUm91dGVySW5pdGlhbGl6ZXIoaW5qZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcbiAgICAgICAgICAgIHRoaXMuaW5pdE5hdmlnYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0T2ZQcmVhY3RpdmF0aW9uRG9uZSA9IG5ldyByeGpzLlN1YmplY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBSb3V0ZXJJbml0aWFsaXplci5wcm90b3R5cGUuYXBwSW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHAgPSB0aGlzLmluamVjdG9yLmdldChjb21tb24uTE9DQVRJT05fSU5JVElBTElaRUQsIFByb21pc2UucmVzb2x2ZShudWxsKSk7XG4gICAgICAgICAgICByZXR1cm4gcC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzb2x2ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyKSB7IHJldHVybiByZXNvbHZlID0gcjsgfSk7XG4gICAgICAgICAgICAgICAgdmFyIHJvdXRlciA9IF90aGlzLmluamVjdG9yLmdldChSb3V0ZXIpO1xuICAgICAgICAgICAgICAgIHZhciBvcHRzID0gX3RoaXMuaW5qZWN0b3IuZ2V0KFJPVVRFUl9DT05GSUdVUkFUSU9OKTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaXNMZWdhY3lEaXNhYmxlZChvcHRzKSB8fCBfdGhpcy5pc0xlZ2FjeUVuYWJsZWQob3B0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3B0cy5pbml0aWFsTmF2aWdhdGlvbiA9PT0gJ2Rpc2FibGVkJykge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZXIuc2V0VXBMb2NhdGlvbkNoYW5nZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdHMuaW5pdGlhbE5hdmlnYXRpb24gPT09ICdlbmFibGVkJykge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZXIuaG9va3MuYWZ0ZXJQcmVhY3RpdmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSB0aGUgaW5pdGlhbCBuYXZpZ2F0aW9uIHNob3VsZCBiZSBkZWxheWVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmluaXROYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW5pdE5hdmlnYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlc3VsdE9mUHJlYWN0aXZhdGlvbkRvbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3Vic2VxdWVudCBuYXZpZ2F0aW9ucyBzaG91bGQgbm90IGJlIGRlbGF5ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByeGpzLm9mKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByb3V0ZXIuaW5pdGlhbE5hdmlnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5pdGlhbE5hdmlnYXRpb24gb3B0aW9uczogJ1wiICsgb3B0cy5pbml0aWFsTmF2aWdhdGlvbiArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBSb3V0ZXJJbml0aWFsaXplci5wcm90b3R5cGUuYm9vdHN0cmFwTGlzdGVuZXIgPSBmdW5jdGlvbiAoYm9vdHN0cmFwcGVkQ29tcG9uZW50UmVmKSB7XG4gICAgICAgICAgICB2YXIgb3B0cyA9IHRoaXMuaW5qZWN0b3IuZ2V0KFJPVVRFUl9DT05GSUdVUkFUSU9OKTtcbiAgICAgICAgICAgIHZhciBwcmVsb2FkZXIgPSB0aGlzLmluamVjdG9yLmdldChSb3V0ZXJQcmVsb2FkZXIpO1xuICAgICAgICAgICAgdmFyIHJvdXRlclNjcm9sbGVyID0gdGhpcy5pbmplY3Rvci5nZXQoUm91dGVyU2Nyb2xsZXIpO1xuICAgICAgICAgICAgdmFyIHJvdXRlciA9IHRoaXMuaW5qZWN0b3IuZ2V0KFJvdXRlcik7XG4gICAgICAgICAgICB2YXIgcmVmID0gdGhpcy5pbmplY3Rvci5nZXQoY29yZS5BcHBsaWNhdGlvblJlZik7XG4gICAgICAgICAgICBpZiAoYm9vdHN0cmFwcGVkQ29tcG9uZW50UmVmICE9PSByZWYuY29tcG9uZW50c1swXSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzTGVnYWN5RW5hYmxlZChvcHRzKSkge1xuICAgICAgICAgICAgICAgIHJvdXRlci5pbml0aWFsTmF2aWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc0xlZ2FjeURpc2FibGVkKG9wdHMpKSB7XG4gICAgICAgICAgICAgICAgcm91dGVyLnNldFVwTG9jYXRpb25DaGFuZ2VMaXN0ZW5lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlbG9hZGVyLnNldFVwUHJlbG9hZGluZygpO1xuICAgICAgICAgICAgcm91dGVyU2Nyb2xsZXIuaW5pdCgpO1xuICAgICAgICAgICAgcm91dGVyLnJlc2V0Um9vdENvbXBvbmVudFR5cGUocmVmLmNvbXBvbmVudFR5cGVzWzBdKTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0T2ZQcmVhY3RpdmF0aW9uRG9uZS5uZXh0KG51bGwpO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRPZlByZWFjdGl2YXRpb25Eb25lLmNvbXBsZXRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIFJvdXRlckluaXRpYWxpemVyLnByb3RvdHlwZS5pc0xlZ2FjeUVuYWJsZWQgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICAgICAgcmV0dXJuIG9wdHMuaW5pdGlhbE5hdmlnYXRpb24gPT09ICdsZWdhY3lfZW5hYmxlZCcgfHwgb3B0cy5pbml0aWFsTmF2aWdhdGlvbiA9PT0gdHJ1ZSB8fFxuICAgICAgICAgICAgICAgIG9wdHMuaW5pdGlhbE5hdmlnYXRpb24gPT09IHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICAgICAgUm91dGVySW5pdGlhbGl6ZXIucHJvdG90eXBlLmlzTGVnYWN5RGlzYWJsZWQgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICAgICAgcmV0dXJuIG9wdHMuaW5pdGlhbE5hdmlnYXRpb24gPT09ICdsZWdhY3lfZGlzYWJsZWQnIHx8IG9wdHMuaW5pdGlhbE5hdmlnYXRpb24gPT09IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBSb3V0ZXJJbml0aWFsaXplciA9IF9fZGVjb3JhdGUkMShbXG4gICAgICAgICAgICBjb3JlLkluamVjdGFibGUoKSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEkMShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtjb3JlLkluamVjdG9yXSlcbiAgICAgICAgXSwgUm91dGVySW5pdGlhbGl6ZXIpO1xuICAgICAgICByZXR1cm4gUm91dGVySW5pdGlhbGl6ZXI7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBnZXRBcHBJbml0aWFsaXplcihyKSB7XG4gICAgICAgIHJldHVybiByLmFwcEluaXRpYWxpemVyLmJpbmQocik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEJvb3RzdHJhcExpc3RlbmVyKHIpIHtcbiAgICAgICAgcmV0dXJuIHIuYm9vdHN0cmFwTGlzdGVuZXIuYmluZChyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSB0b2tlbiBmb3IgdGhlIHJvdXRlciBpbml0aWFsaXplciB0aGF0IHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSBhcHAgaXMgYm9vdHN0cmFwcGVkLlxuICAgICAqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBST1VURVJfSU5JVElBTElaRVIgPSBuZXcgY29yZS5JbmplY3Rpb25Ub2tlbignUm91dGVyIEluaXRpYWxpemVyJyk7XG4gICAgZnVuY3Rpb24gcHJvdmlkZVJvdXRlckluaXRpYWxpemVyKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgUm91dGVySW5pdGlhbGl6ZXIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogY29yZS5BUFBfSU5JVElBTElaRVIsXG4gICAgICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgICAgICAgICAgdXNlRmFjdG9yeTogZ2V0QXBwSW5pdGlhbGl6ZXIsXG4gICAgICAgICAgICAgICAgZGVwczogW1JvdXRlckluaXRpYWxpemVyXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgcHJvdmlkZTogUk9VVEVSX0lOSVRJQUxJWkVSLCB1c2VGYWN0b3J5OiBnZXRCb290c3RyYXBMaXN0ZW5lciwgZGVwczogW1JvdXRlckluaXRpYWxpemVyXSB9LFxuICAgICAgICAgICAgeyBwcm92aWRlOiBjb3JlLkFQUF9CT09UU1RSQVBfTElTVEVORVIsIG11bHRpOiB0cnVlLCB1c2VFeGlzdGluZzogUk9VVEVSX0lOSVRJQUxJWkVSIH0sXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgVkVSU0lPTiA9IG5ldyBjb3JlLlZlcnNpb24oJzguMC4wJyk7XG5cbiAgICB2YXIgX19hc3NpZ24kMiA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9fYXNzaWduJDIgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX19hc3NpZ24kMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgdmFyIF9fZGVjb3JhdGUkMiA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgICAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgICAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgICAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICAgIH07XG4gICAgdmFyIF9fbWV0YWRhdGEkMiA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbiAgICB9O1xuICAgIHZhciBfX3BhcmFtJDIgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxuICAgIH07XG4gICAgdmFyIEZJUkVCQVNFX0VWRU5UX09SSUdJTl9LRVkgPSAnZmlyZWJhc2VfZXZlbnRfb3JpZ2luJztcbiAgICB2YXIgRklSRUJBU0VfUFJFVklPVVNfU0NSRUVOX0NMQVNTX0tFWSA9ICdmaXJlYmFzZV9wcmV2aW91c19jbGFzcyc7XG4gICAgdmFyIEZJUkVCQVNFX1BSRVZJT1VTX1NDUkVFTl9JTlNUQU5DRV9JRF9LRVkgPSAnZmlyZWJhc2VfcHJldmlvdXNfaWQnO1xuICAgIHZhciBGSVJFQkFTRV9QUkVWSU9VU19TQ1JFRU5fTkFNRV9LRVkgPSAnZmlyZWJhc2VfcHJldmlvdXNfc2NyZWVuJztcbiAgICB2YXIgRklSRUJBU0VfU0NSRUVOX0NMQVNTX0tFWSA9ICdmaXJlYmFzZV9zY3JlZW5fY2xhc3MnO1xuICAgIHZhciBGSVJFQkFTRV9TQ1JFRU5fSU5TVEFOQ0VfSURfS0VZID0gJ2ZpcmViYXNlX3NjcmVlbl9pZCc7XG4gICAgdmFyIEZJUkVCQVNFX1NDUkVFTl9OQU1FX0tFWSA9ICdmaXJlYmFzZV9zY3JlZW4nO1xuICAgIHZhciBPVVRMRVRfS0VZID0gJ291dGxldCc7XG4gICAgdmFyIFBBR0VfUEFUSF9LRVkgPSAncGFnZV9wYXRoJztcbiAgICB2YXIgUEFHRV9USVRMRV9LRVkgPSAncGFnZV90aXRsZSc7XG4gICAgdmFyIFNDUkVFTl9DTEFTU19LRVkgPSAnc2NyZWVuX2NsYXNzJztcbiAgICB2YXIgU0NSRUVOX05BTUVfS0VZID0gJ3NjcmVlbl9uYW1lJztcbiAgICB2YXIgU0NSRUVOX1ZJRVdfRVZFTlQgPSAnc2NyZWVuX3ZpZXcnO1xuICAgIHZhciBFVkVOVF9PUklHSU5fQVVUTyA9ICdhdXRvJztcbiAgICB2YXIgREVGQVVMVF9TQ1JFRU5fQ0xBU1MgPSAnPz8/JztcbiAgICB2YXIgTkdfUFJJTUFSWV9PVVRMRVQgPSAncHJpbWFyeSc7XG4gICAgdmFyIFNDUkVFTl9JTlNUQU5DRV9ERUxJTUlURVIgPSAnIyc7XG4gICAgdmFyIEFOTk9UQVRJT05TID0gJ19fYW5ub3RhdGlvbnNfXyc7XG4gICAgdmFyIFNjcmVlblRyYWNraW5nU2VydmljZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFNjcmVlblRyYWNraW5nU2VydmljZShhbmFseXRpY3MsIHJvdXRlciwgdGl0bGUsIGNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgcGxhdGZvcm1JZCwgZGVidWdNb2RlRW5hYmxlZCwgem9uZSwgaW5qZWN0b3IpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIXJvdXRlciB8fCAhY29tbW9uLmlzUGxhdGZvcm1Ccm93c2VyKHBsYXRmb3JtSWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB6b25lLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWN0aXZhdGlvbkVuZEV2ZW50cyA9IHJvdXRlci5ldmVudHMucGlwZShvcGVyYXRvcnMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlIGluc3RhbmNlb2YgQWN0aXZhdGlvbkVuZDsgfSkpO1xuICAgICAgICAgICAgICAgIHZhciBuYXZpZ2F0aW9uRW5kRXZlbnRzID0gcm91dGVyLmV2ZW50cy5waXBlKG9wZXJhdG9ycy5maWx0ZXIoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uRW5kOyB9KSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGlzcG9zYWJsZSA9IG5hdmlnYXRpb25FbmRFdmVudHMucGlwZShvcGVyYXRvcnMud2l0aExhdGVzdEZyb20oYWN0aXZhdGlvbkVuZEV2ZW50cyksIG9wZXJhdG9ycy5zd2l0Y2hNYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYXZpZ2F0aW9uRW5kID0gX2FbMF0sIGFjdGl2YXRpb25FbmQgPSBfYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhZ2VfcGF0aCA9IG5hdmlnYXRpb25FbmQudXJsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2NyZWVuX25hbWUgPSBhY3RpdmF0aW9uRW5kLnNuYXBzaG90LnJvdXRlQ29uZmlnICYmIGFjdGl2YXRpb25FbmQuc25hcHNob3Qucm91dGVDb25maWcucGF0aCB8fCBwYWdlX3BhdGg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSAoX2IgPSB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iW1NDUkVFTl9OQU1FX0tFWV0gPSBzY3JlZW5fbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iW1BBR0VfUEFUSF9LRVldID0gcGFnZV9wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2JbRklSRUJBU0VfRVZFTlRfT1JJR0lOX0tFWV0gPSBFVkVOVF9PUklHSU5fQVVUTyxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iW0ZJUkVCQVNFX1NDUkVFTl9OQU1FX0tFWV0gPSBzY3JlZW5fbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iW09VVExFVF9LRVldID0gYWN0aXZhdGlvbkVuZC5zbmFwc2hvdC5vdXRsZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBfYik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zW1BBR0VfVElUTEVfS0VZXSA9IHRpdGxlLmdldFRpdGxlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IGFjdGl2YXRpb25FbmQuc25hcHNob3QuY29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm91dGVDb25maWcgPSBhY3RpdmF0aW9uRW5kLnNuYXBzaG90LnJvdXRlQ29uZmlnO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9hZENoaWxkcmVuID0gcm91dGVDb25maWcgJiYgcm91dGVDb25maWcubG9hZENoaWxkcmVuO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxvYWRDaGlsZHJlbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ4anMub2YoX19hc3NpZ24kMih7fSwgcGFyYW1zLCAoX2MgPSB7fSwgX2NbU0NSRUVOX0NMQVNTX0tFWV0gPSBsb2FkQ2hpbGRyZW4uc3BsaXQoJyMnKVsxXSwgX2MpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNvbXBvbmVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByeGpzLm9mKF9fYXNzaWduJDIoe30sIHBhcmFtcywgKF9kID0ge30sIF9kW1NDUkVFTl9DTEFTU19LRVldID0gY29tcG9uZW50LCBfZCkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRGYWN0b3J5ID0gY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnhqcy5vZihfX2Fzc2lnbiQyKHt9LCBwYXJhbXMsIChfZSA9IHt9LCBfZVtTQ1JFRU5fQ0xBU1NfS0VZXSA9IGNvbXBvbmVudEZhY3Rvcnkuc2VsZWN0b3IsIF9lKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxvYWRDaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvYWRlZENoaWxkcmVuID0gbG9hZENoaWxkcmVuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9hZGVkQ2hpbGRyZW4kID0gKGxvYWRlZENoaWxkcmVuIGluc3RhbmNlb2Ygcnhqcy5PYnNlcnZhYmxlKSA/IGxvYWRlZENoaWxkcmVuIDogcnhqcy5mcm9tKFByb21pc2UucmVzb2x2ZShsb2FkZWRDaGlsZHJlbikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlZENoaWxkcmVuJC5waXBlKG9wZXJhdG9ycy5tYXAoZnVuY3Rpb24gKGxhenlNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGF6eU1vZHVsZSBpbnN0YW5jZW9mIGNvcmUuTmdNb2R1bGVGYWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2R1bGVSZWYgPSBsYXp5TW9kdWxlLmNyZWF0ZShpbmplY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3V0ZXMgPSBtb2R1bGVSZWYuaW5qZWN0b3IuZ2V0KFJPVVRFUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRfMSA9IHJvdXRlc1swXVswXS5jb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50RmFjdG9yeSA9IG1vZHVsZVJlZi5jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoY29tcG9uZW50XzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduJDIoe30sIHBhcmFtcywgKF9hID0ge30sIF9hW1NDUkVFTl9DTEFTU19LRVldID0gY29tcG9uZW50RmFjdG9yeS5zZWxlY3RvciwgX2EpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduJDIoe30sIHBhcmFtcywgKF9iID0ge30sIF9iW1NDUkVFTl9DTEFTU19LRVldID0gREVGQVVMVF9TQ1JFRU5fQ0xBU1MsIF9iKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbnMgPSBbXS5jb25jYXQuYXBwbHkoW10sIChsYXp5TW9kdWxlW0FOTk9UQVRJT05TXSB8fCBbXSkubWFwKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmLmRlY2xhcmF0aW9uczsgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3JzID0gW10uY29uY2F0LmFwcGx5KFtdLCBkZWNsYXJhdGlvbnMubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiAoY1tBTk5PVEFUSU9OU10gfHwgW10pLm1hcChmdW5jdGlvbiAoZikgeyByZXR1cm4gZi5zZWxlY3RvcjsgfSk7IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduJDIoe30sIHBhcmFtcywgKF9jID0ge30sIF9jW1NDUkVFTl9DTEFTU19LRVldID0gc2VsZWN0b3JzWzBdIHx8IERFRkFVTFRfU0NSRUVOX0NMQVNTLCBfYykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByeGpzLm9mKF9fYXNzaWduJDIoe30sIHBhcmFtcywgKF9mID0ge30sIF9mW1NDUkVFTl9DTEFTU19LRVldID0gREVGQVVMVF9TQ1JFRU5fQ0xBU1MsIF9mKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksIG9wZXJhdG9ycy5tYXAoZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoX19hc3NpZ24kMigoX2EgPSB7fSwgX2FbRklSRUJBU0VfU0NSRUVOX0NMQVNTX0tFWV0gPSBwYXJhbXNbU0NSRUVOX0NMQVNTX0tFWV0sIF9hW0ZJUkVCQVNFX1NDUkVFTl9JTlNUQU5DRV9JRF9LRVldID0gZ2V0U2NyZWVuSW5zdGFuY2VJRChwYXJhbXMpLCBfYSksIHBhcmFtcykpO1xuICAgICAgICAgICAgICAgIH0pLCBvcGVyYXRvcnMudGFwKGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtc1tPVVRMRVRfS0VZXSA9PSBOR19QUklNQVJZX09VVExFVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5hbHl0aWNzLnNldEN1cnJlbnRTY3JlZW4ocGFyYW1zW1NDUkVFTl9OQU1FX0tFWV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5hbHl0aWNzLnVwZGF0ZUNvbmZpZygoX2EgPSB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYVtQQUdFX1BBVEhfS0VZXSA9IHBhcmFtc1tQQUdFX1BBVEhfS0VZXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYVtTQ1JFRU5fQ0xBU1NfS0VZXSA9IHBhcmFtc1tTQ1JFRU5fQ0xBU1NfS0VZXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5hbHl0aWNzLnVwZGF0ZUNvbmZpZygoX2IgPSB7fSwgX2JbUEFHRV9USVRMRV9LRVldID0gcGFyYW1zW1BBR0VfVElUTEVfS0VZXSwgX2IpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLCBvcGVyYXRvcnMuZ3JvdXBCeShmdW5jdGlvbiAocGFyYW1zKSB7IHJldHVybiBwYXJhbXNbT1VUTEVUX0tFWV07IH0pLCBvcGVyYXRvcnMubWVyZ2VNYXAoZnVuY3Rpb24gKGdyb3VwKSB7IHJldHVybiBncm91cC5waXBlKG9wZXJhdG9ycy5zdGFydFdpdGgodW5kZWZpbmVkKSwgb3BlcmF0b3JzLnBhaXJ3aXNlKCkpOyB9KSwgb3BlcmF0b3JzLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9iO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJpb3IgPSBfYVswXSwgY3VycmVudCA9IF9hWzFdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJpb3IgPyBfX2Fzc2lnbiQyKChfYiA9IHt9LCBfYltGSVJFQkFTRV9QUkVWSU9VU19TQ1JFRU5fQ0xBU1NfS0VZXSA9IHByaW9yW1NDUkVFTl9DTEFTU19LRVldLCBfYltGSVJFQkFTRV9QUkVWSU9VU19TQ1JFRU5fTkFNRV9LRVldID0gcHJpb3JbU0NSRUVOX05BTUVfS0VZXSwgX2JbRklSRUJBU0VfUFJFVklPVVNfU0NSRUVOX0lOU1RBTkNFX0lEX0tFWV0gPSBwcmlvcltGSVJFQkFTRV9TQ1JFRU5fSU5TVEFOQ0VfSURfS0VZXSwgX2IpLCBjdXJyZW50KSA6IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgfSksIG9wZXJhdG9ycy50YXAoZnVuY3Rpb24gKHBhcmFtcykgeyByZXR1cm4gZGVidWdNb2RlRW5hYmxlZCAmJiBjb25zb2xlLmluZm8oU0NSRUVOX1ZJRVdfRVZFTlQsIHBhcmFtcyk7IH0pLCBvcGVyYXRvcnMudGFwKGZ1bmN0aW9uIChwYXJhbXMpIHsgcmV0dXJuIHpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkgeyByZXR1cm4gYW5hbHl0aWNzLmxvZ0V2ZW50KFNDUkVFTl9WSUVXX0VWRU5ULCBwYXJhbXMpOyB9KTsgfSkpLnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgU2NyZWVuVHJhY2tpbmdTZXJ2aWNlLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc3Bvc2FibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2FibGUudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgU2NyZWVuVHJhY2tpbmdTZXJ2aWNlID0gX19kZWNvcmF0ZSQyKFtcbiAgICAgICAgICAgIGNvcmUuSW5qZWN0YWJsZSgpLFxuICAgICAgICAgICAgX19wYXJhbSQyKDEsIGNvcmUuT3B0aW9uYWwoKSksXG4gICAgICAgICAgICBfX3BhcmFtJDIoMiwgY29yZS5PcHRpb25hbCgpKSxcbiAgICAgICAgICAgIF9fcGFyYW0kMig0LCBjb3JlLkluamVjdChjb3JlLlBMQVRGT1JNX0lEKSksXG4gICAgICAgICAgICBfX3BhcmFtJDIoNSwgY29yZS5PcHRpb25hbCgpKSwgX19wYXJhbSQyKDUsIGNvcmUuSW5qZWN0KERFQlVHX01PREUpKSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEkMihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtBbmd1bGFyRmlyZUFuYWx5dGljcyxcbiAgICAgICAgICAgICAgICBSb3V0ZXIsXG4gICAgICAgICAgICAgICAgcGxhdGZvcm1Ccm93c2VyLlRpdGxlLFxuICAgICAgICAgICAgICAgIGNvcmUuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgICAgICAgICAgICAgIE9iamVjdCwgT2JqZWN0LCBjb3JlLk5nWm9uZSxcbiAgICAgICAgICAgICAgICBjb3JlLkluamVjdG9yXSlcbiAgICAgICAgXSwgU2NyZWVuVHJhY2tpbmdTZXJ2aWNlKTtcbiAgICAgICAgcmV0dXJuIFNjcmVlblRyYWNraW5nU2VydmljZTtcbiAgICB9KCkpO1xuICAgIHZhciBVc2VyVHJhY2tpbmdTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVXNlclRyYWNraW5nU2VydmljZShhbmFseXRpY3MsIHpvbmUsIHBsYXRmb3JtSWQpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgc2NoZWR1bGVycyA9IG5ldyBmaXJlLsm1QW5ndWxhckZpcmVTY2hlZHVsZXJzKHpvbmUpO1xuICAgICAgICAgICAgaWYgKCFjb21tb24uaXNQbGF0Zm9ybVNlcnZlcihwbGF0Zm9ybUlkKSkge1xuICAgICAgICAgICAgICAgIHpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaXNwb3NhYmxlID0gcnhqcy5mcm9tKGltcG9ydCgnZmlyZWJhc2UvYXV0aCcpKS5waXBlKG9wZXJhdG9ycy5vYnNlcnZlT24oc2NoZWR1bGVycy5vdXRzaWRlQW5ndWxhciksIG9wZXJhdG9ycy5zd2l0Y2hNYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gYW5hbHl0aWNzLmFwcDsgfSksIG9wZXJhdG9ycy5tYXAoZnVuY3Rpb24gKGFwcCkgeyByZXR1cm4gYXBwLmF1dGgoKTsgfSksIG9wZXJhdG9ycy5zd2l0Y2hNYXAoZnVuY3Rpb24gKGF1dGgpIHsgcmV0dXJuIG5ldyByeGpzLk9ic2VydmFibGUoYXV0aC5vbkF1dGhTdGF0ZUNoYW5nZWQuYmluZChhdXRoKSk7IH0pLCBvcGVyYXRvcnMuc3dpdGNoTWFwKGZ1bmN0aW9uICh1c2VyKSB7IHJldHVybiBhbmFseXRpY3Muc2V0VXNlcklkKHVzZXIgPyB1c2VyLnVpZCA6IG51bGwpOyB9KSkuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgVXNlclRyYWNraW5nU2VydmljZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXNwb3NhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NhYmxlLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFVzZXJUcmFja2luZ1NlcnZpY2UgPSBfX2RlY29yYXRlJDIoW1xuICAgICAgICAgICAgY29yZS5JbmplY3RhYmxlKCksXG4gICAgICAgICAgICBfX3BhcmFtJDIoMiwgY29yZS5JbmplY3QoY29yZS5QTEFURk9STV9JRCkpLFxuICAgICAgICAgICAgX19tZXRhZGF0YSQyKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0FuZ3VsYXJGaXJlQW5hbHl0aWNzLFxuICAgICAgICAgICAgICAgIGNvcmUuTmdab25lLFxuICAgICAgICAgICAgICAgIE9iamVjdF0pXG4gICAgICAgIF0sIFVzZXJUcmFja2luZ1NlcnZpY2UpO1xuICAgICAgICByZXR1cm4gVXNlclRyYWNraW5nU2VydmljZTtcbiAgICB9KCkpO1xuICAgIHZhciBuZXh0U2NyZWVuSW5zdGFuY2VJRCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChNYXRoLnBvdygyLCAzMikgLSAxKSkgLSBNYXRoLnBvdygyLCAzMSk7XG4gICAgdmFyIGtub3duU2NyZWVuSW5zdGFuY2VJRHMgPSB7fTtcbiAgICB2YXIgZ2V0U2NyZWVuSW5zdGFuY2VJRCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIHNjcmVlbkluc3RhbmNlS2V5ID0gW1xuICAgICAgICAgICAgcGFyYW1zW1NDUkVFTl9DTEFTU19LRVldLFxuICAgICAgICAgICAgcGFyYW1zW09VVExFVF9LRVldXG4gICAgICAgIF0uam9pbihTQ1JFRU5fSU5TVEFOQ0VfREVMSU1JVEVSKTtcbiAgICAgICAgaWYgKGtub3duU2NyZWVuSW5zdGFuY2VJRHMuaGFzT3duUHJvcGVydHkoc2NyZWVuSW5zdGFuY2VLZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4ga25vd25TY3JlZW5JbnN0YW5jZUlEc1tzY3JlZW5JbnN0YW5jZUtleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gbmV4dFNjcmVlbkluc3RhbmNlSUQrKztcbiAgICAgICAgICAgIGtub3duU2NyZWVuSW5zdGFuY2VJRHNbc2NyZWVuSW5zdGFuY2VLZXldID0gcmV0O1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIMm1MCQxID0gZ2V0U2NyZWVuSW5zdGFuY2VJRDtcblxuICAgIHZhciBfX2RlY29yYXRlJDMgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICAgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICAgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgICB9O1xuICAgIHZhciBfX21ldGFkYXRhJDMgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG4gICAgfTtcbiAgICB2YXIgX19wYXJhbSQzID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbiAgICB9O1xuICAgIHZhciBBbmd1bGFyRmlyZUFuYWx5dGljc01vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuZ3VsYXJGaXJlQW5hbHl0aWNzTW9kdWxlKGFuYWx5dGljcywgc2NyZWVuVHJhY2tpbmcsIHVzZXJUcmFja2luZykge1xuICAgICAgICAgICAgYW5hbHl0aWNzLmFwcDtcbiAgICAgICAgfVxuICAgICAgICBBbmd1bGFyRmlyZUFuYWx5dGljc01vZHVsZSA9IF9fZGVjb3JhdGUkMyhbXG4gICAgICAgICAgICBjb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtBbmd1bGFyRmlyZUFuYWx5dGljc11cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgX19wYXJhbSQzKDEsIGNvcmUuT3B0aW9uYWwoKSksXG4gICAgICAgICAgICBfX3BhcmFtJDMoMiwgY29yZS5PcHRpb25hbCgpKSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEkMyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtBbmd1bGFyRmlyZUFuYWx5dGljcyxcbiAgICAgICAgICAgICAgICBTY3JlZW5UcmFja2luZ1NlcnZpY2UsXG4gICAgICAgICAgICAgICAgVXNlclRyYWNraW5nU2VydmljZV0pXG4gICAgICAgIF0sIEFuZ3VsYXJGaXJlQW5hbHl0aWNzTW9kdWxlKTtcbiAgICAgICAgcmV0dXJuIEFuZ3VsYXJGaXJlQW5hbHl0aWNzTW9kdWxlO1xuICAgIH0oKSk7XG5cbiAgICBleHBvcnRzLkNPTExFQ1RJT05fRU5BQkxFRCA9IENPTExFQ1RJT05fRU5BQkxFRDtcbiAgICBleHBvcnRzLkFQUF9WRVJTSU9OID0gQVBQX1ZFUlNJT047XG4gICAgZXhwb3J0cy5BUFBfTkFNRSA9IEFQUF9OQU1FO1xuICAgIGV4cG9ydHMuREVCVUdfTU9ERSA9IERFQlVHX01PREU7XG4gICAgZXhwb3J0cy5DT05GSUcgPSBDT05GSUc7XG4gICAgZXhwb3J0cy5Bbmd1bGFyRmlyZUFuYWx5dGljcyA9IEFuZ3VsYXJGaXJlQW5hbHl0aWNzO1xuICAgIGV4cG9ydHMuQW5ndWxhckZpcmVBbmFseXRpY3NNb2R1bGUgPSBBbmd1bGFyRmlyZUFuYWx5dGljc01vZHVsZTtcbiAgICBleHBvcnRzLlNjcmVlblRyYWNraW5nU2VydmljZSA9IFNjcmVlblRyYWNraW5nU2VydmljZTtcbiAgICBleHBvcnRzLlVzZXJUcmFja2luZ1NlcnZpY2UgPSBVc2VyVHJhY2tpbmdTZXJ2aWNlO1xuICAgIGV4cG9ydHMuybUwID0gybUwJDE7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIl19